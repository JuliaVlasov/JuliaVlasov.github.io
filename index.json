[{"id":3,"pagetitle":"GEMPIC.jl Documentation","title":"GEMPIC.jl Documentation","ref":"/gempic/dev/#GEMPIC.jl-Documentation","content":" GEMPIC.jl Documentation Geometric ElectroMagnetic Particle-In-Cell Methods A Julia implementation of the  GEMPIC This package implements a Finite Element Particle-in-Cell method based on the discretization of the underlying Hamiltonian structure of the Vlasov-Maxwell system. "},{"id":6,"pagetitle":"Contents","title":"Contents","ref":"/gempic/dev/contents/#Contents","content":" Contents Contents Index Diagnostics Distributions Hamiltonian splitting Hamiltonian splitting Boris GEMPIC.jl Documentation Splines Maxwell solver Mesh Particle group Particle-Mesh coupling Particle sampling Special case of the Landau Damping Periodic spline Strong Landau Damping Initialize field solver Simulation function Time evolution of electric energy"},{"id":7,"pagetitle":"Contents","title":"Index","ref":"/gempic/dev/contents/#Index","content":" Index GEMPIC.CosGaussianParams GEMPIC.CosSumGaussian GEMPIC.HamiltonianSplitting GEMPIC.HamiltonianSplittingBoris GEMPIC.LandauDamping GEMPIC.Maxwell1DFEM GEMPIC.OneDGrid GEMPIC.ParticleGroup GEMPIC.ParticleMeshCoupling1D GEMPIC.ParticleMeshCoupling2D GEMPIC.ParticleSampler GEMPIC.SplinePP GEMPIC.SumCosGaussian GEMPIC.TimeHistoryDiagnostics GEMPIC.TwoDGrid GEMPIC.add_charge! GEMPIC.add_charge! GEMPIC.add_charge_pp! GEMPIC.add_charge_pp! GEMPIC.add_current_update_v! GEMPIC.add_current_update_v! GEMPIC.add_current_update_v_pp! GEMPIC.b_to_pp GEMPIC.b_to_pp_1d_cell! GEMPIC.b_to_pp_2d! GEMPIC.b_to_pp_2d_cell! GEMPIC.compute_b_from_e! GEMPIC.compute_e_from_b! GEMPIC.compute_e_from_j! GEMPIC.compute_rhs_from_function! GEMPIC.compute_shape_factor GEMPIC.eval_derivative_spline GEMPIC.eval_uniform_periodic_spline_curve GEMPIC.eval_v_density GEMPIC.eval_x_density GEMPIC.evaluate GEMPIC.evaluate GEMPIC.evaluate GEMPIC.evaluate_multiple GEMPIC.evaluate_pp GEMPIC.evaluate_pp GEMPIC.get_cell_and_offset GEMPIC.get_charge GEMPIC.get_mass GEMPIC.get_v GEMPIC.get_weights GEMPIC.get_x GEMPIC.get_x GEMPIC.horner_1d GEMPIC.horner_2d GEMPIC.horner_m_2d! GEMPIC.horner_primitive_1d GEMPIC.index_1dto2d_column_major GEMPIC.inner_product GEMPIC.l2norm_squared GEMPIC.l2norm_squared2 GEMPIC.l2projection! GEMPIC.lie_splitting! GEMPIC.lie_splitting_back! GEMPIC.newton GEMPIC.pic_diagnostics_hpi GEMPIC.pic_diagnostics_poynting GEMPIC.pic_diagnostics_transfer GEMPIC.pic_diagnostics_vvb GEMPIC.push_v_bpart! GEMPIC.push_v_epart! GEMPIC.push_x_accumulate_j! GEMPIC.sample! GEMPIC.sample! GEMPIC.sample! GEMPIC.sample! GEMPIC.sample_all GEMPIC.sample_sym GEMPIC.set_v! GEMPIC.set_v! GEMPIC.set_weights! GEMPIC.set_weights! GEMPIC.set_x! GEMPIC.set_x! GEMPIC.solve_poisson! GEMPIC.staggering! GEMPIC.strang_splitting! GEMPIC.strang_splitting! GEMPIC.uniform_bsplines_eval_basis GEMPIC.update_jv! GEMPIC.update_jv! GEMPIC.update_jv_pp! GEMPIC.write_step!"},{"id":10,"pagetitle":"Diagnostics","title":"Diagnostics","ref":"/gempic/dev/diagnostics/#Diagnostics","content":" Diagnostics"},{"id":11,"pagetitle":"Diagnostics","title":"GEMPIC.TimeHistoryDiagnostics","ref":"/gempic/dev/diagnostics/#GEMPIC.TimeHistoryDiagnostics","content":" GEMPIC.TimeHistoryDiagnostics  —  Type TimeHistoryDiagnostics( particle_group, maxwell_solver, \n                        kernel_smoother_0, kernel_smoother_1 ) Context to save and plot diagnostics particle_group  : Particles data maxwell_solver  : Maxwell solver kernel_smoother_0  : Mesh coupling operator kernel_smoother_1  : Mesh coupling operator data  : DataFrame containing time history values source"},{"id":12,"pagetitle":"Diagnostics","title":"GEMPIC.eval_derivative_spline","ref":"/gempic/dev/diagnostics/#GEMPIC.eval_derivative_spline-NTuple{6, Any}","content":" GEMPIC.eval_derivative_spline  —  Method eval_derivative_spline( position, xmin, delta_x, n_grid, \n                        field_dofs, degree, derivative ) Compute the spline coefficient of the derivative of some given spline expansion position  : particle position xmin  : lower boundary of the domain delta_x  : step  n_grid  : number of grid points field_dofs  : coefficients of spline representation of the field degree  : degree of spline derivative  : value of the derivative source"},{"id":13,"pagetitle":"Diagnostics","title":"GEMPIC.evaluate","ref":"/gempic/dev/diagnostics/#GEMPIC.evaluate-Tuple{ParticleMeshCoupling1D, AbstractArray, AbstractArray}","content":" GEMPIC.evaluate  —  Method evaluate( kernel_smoother, field_dofs,  xi, n_dofs ) Evaluate the field at points xi field_dofs  : field value on dofs xi  : positions where the field is evaluated source"},{"id":14,"pagetitle":"Diagnostics","title":"GEMPIC.pic_diagnostics_hpi","ref":"/gempic/dev/diagnostics/#GEMPIC.pic_diagnostics_hpi-Tuple{Any, Any, Any}","content":" GEMPIC.pic_diagnostics_hpi  —  Method pic_diagnostics_hpi( particle_group,  index, kinetic ) compute v(index)-part of kinetic energy particle_group index  : velocity component kinetic  : value of index part of kinetic energy source"},{"id":15,"pagetitle":"Diagnostics","title":"GEMPIC.pic_diagnostics_poynting","ref":"/gempic/dev/diagnostics/#GEMPIC.pic_diagnostics_poynting-NTuple{4, Any}","content":" GEMPIC.pic_diagnostics_poynting  —  Method pic_diagnostics_poynting( maxwell_solver, degree, efield_dofs, bfield_dofs, \n                          rho ) Compute  $e^T M_0^{-1}  R^T b$ maxwell_solver  : maxwell solver object degree  : degree of finite element efield_dofs  : coefficients of  efield bfield_dofs  : coefficients of  bfield source"},{"id":16,"pagetitle":"Diagnostics","title":"GEMPIC.pic_diagnostics_transfer","ref":"/gempic/dev/diagnostics/#GEMPIC.pic_diagnostics_transfer-Tuple{ParticleGroup{1, 2}, Any, Any, Any}","content":" GEMPIC.pic_diagnostics_transfer  —  Method pic_diagnostics_transfer( particle_group, kernel_smoother_0, \n                        kernel_smoother_1, efield_dofs, transfer) Compute  $\\sum_{particles} w_p ( v_1,p e_1(x_p) + v_2,p e_2(x_p))$ particle_group kernel_smoother_0   : Kernel smoother (order p+1) kernel_smoother_1   : Kernel smoother (order p)    efield_dofs  : coefficients of efield source"},{"id":17,"pagetitle":"Diagnostics","title":"GEMPIC.pic_diagnostics_vvb","ref":"/gempic/dev/diagnostics/#GEMPIC.pic_diagnostics_vvb-Tuple{Any, Any, Any}","content":" GEMPIC.pic_diagnostics_vvb  —  Method pic_diagnostics_vvb( particle_group, kernel_smoother_1, bfield_dofs ) Compute  $\\sum_{particles} ( w_p v_1, p b(x_p) v_2, p )$ particle_group     : particle group object kernel_smoother_1  : Kernel smoother (order p)   bfield_dofs  : coefficients of bfield source"},{"id":18,"pagetitle":"Diagnostics","title":"GEMPIC.solve_poisson!","ref":"/gempic/dev/diagnostics/#GEMPIC.solve_poisson!-Tuple{Vector{Float64}, GEMPIC.AbstractParticleGroup, GEMPIC.AbstractParticleMeshCoupling, Maxwell1DFEM, Vector{Float64}}","content":" GEMPIC.solve_poisson!  —  Method solve poisson!( efield, particle group, kernel smoother, maxwell solver, rho ) Accumulate rho and solve Poisson particle_group  : Particles maxwell_solver  : Maxwell solver (FEM 1D) kernel_smoother_0  : Particle-Mesh method rho  : preallocated array for Charge density efield_dofs  : spline coefficients of electric field (1D) source"},{"id":19,"pagetitle":"Diagnostics","title":"GEMPIC.write_step!","ref":"/gempic/dev/diagnostics/#GEMPIC.write_step!-Tuple{TimeHistoryDiagnostics, Vararg{Any, 6}}","content":" GEMPIC.write_step!  —  Method write_step!( thdiag, time, degree, efield_dofs, bfield_dofs,\n             efield_dofs_n, efield_poisson) write diagnostics for PIC time  : Time efield_dofs  : Electric field efield_dofs_n  : Electric field at half step efield_poisson  : Electric field compute from Poisson equation bfield_dofs  : Magnetic field degree  : Spline degree source"},{"id":22,"pagetitle":"Distributions","title":"Distributions","ref":"/gempic/dev/distributions/#Distributions","content":" Distributions"},{"id":23,"pagetitle":"Distributions","title":"GEMPIC.CosGaussianParams","ref":"/gempic/dev/distributions/#GEMPIC.CosGaussianParams","content":" GEMPIC.CosGaussianParams  —  Type CosGaussianParams( dims, k, α, σ, μ, δ ) Parameters of a distribution with is a product of a Cosine  distribution along x and a Normal distribution along v. n_gaussians  : Number of Gaussians n_cos        : Number of cosines normal       : Normalization constant of each Gaussian source"},{"id":24,"pagetitle":"Distributions","title":"GEMPIC.CosSumGaussian","ref":"/gempic/dev/distributions/#GEMPIC.CosSumGaussian","content":" GEMPIC.CosSumGaussian  —  Type CosSumGaussian{D,V}( n_cos, n_gaussians, k, α, σ, μ, δ ) Data type for parameters of initial distribution \\[(1+ \\cos( \\sum^{n_{cos}}_{i=1} k_i x)) \n\\cdot \n\\sum_{j=1}^{n_{gaussians}} \n\\delta_j \n\\exp \\big( -\\frac{1}{2} \n\\frac{(v-\\mu_j)^2}{\\sigma_j^2} \\big)\\] Parameters k  : values of the wave numbers (one array for each cosines) α  : strength of perturbations σ  : variance of the Gaussian (one velocity vector for each gaussian). μ  : mean value of the Gaussian (one velocity vector for each gaussian). δ  : portion of each Gaussian  Example \\[f(x,v_1,v_2)=\\frac{1}{2\\pi\\sigma_1\\sigma_2} \\exp \\Big( - \\frac{1}{2}\n\\big( \\frac{v_1^2}{\\sigma_1^2} + \\frac{v_2^2}{\\sigma_2^2} \\big) \n\\Big) ( 1 + \\alpha \\cos(kx)),\\] df = CosSumGaussian{1,2}([[k]],[α], [[σ₁,σ₂]], [[μ₁,μ₂]]) source"},{"id":25,"pagetitle":"Distributions","title":"GEMPIC.SumCosGaussian","ref":"/gempic/dev/distributions/#GEMPIC.SumCosGaussian","content":" GEMPIC.SumCosGaussian  —  Type SumCosGaussian( dims, n_cos, n_gaussians, k, α, σ, μ, δ ) Data type for parameters of initial distribution \\[(1+ \\sum_{i=1}^{n_{cos}} \\alpha_i \\cos(  k_i \\mathbf{x}))\n\\cdot\n\\sum_{j=1}^{n_{gaussians}} \n\\delta_j \\exp \n\\big( -\\frac{1}{2} \n\\frac{(\\mathbf{v}-\\mu_j)^2}{\\sigma_j^2} \\big)\\] Parameters k  : values of the wave numbers (Array of vectors for multiple cosines) α  : strength of perturbations σ  : variance of the Gaussian ( Array of vectors for multiple Gaussians) μ  : mean value of the Gaussian ( Array multiple Gaussians) normal  : Normalization constant of each Gaussian n_gaussians  : Number of Gaussians n_cos  : Number of cosines δ  : portion of each Gaussian  Example \\[f(x,v_1,v_2) = \\frac{1}{2\\pi\\sigma_1\\sigma_2} \n\\exp \\Big( - \\frac{1}{2} \\big( \\frac{v_1^2}{\\sigma_1^2}\n + \\frac{v_2^2}{\\sigma_2^2} \\big) \\Big) \n( 1 + \\alpha_1 \\cos(k_1 x) + \\alpha_2 \\cos(k_2 x) ),\\] df = SumCosGaussian{1,2}([[k₁],[k₂]], [α₁, α₂], [[σ₁,σ₂]], [[0.0,0.0]])\n source"},{"id":26,"pagetitle":"Distributions","title":"GEMPIC.eval_v_density","ref":"/gempic/dev/distributions/#GEMPIC.eval_v_density-Tuple{GEMPIC.AbstractCosGaussian, Union{Float64, Vector{Float64}}}","content":" GEMPIC.eval_v_density  —  Method eval_v_density( f, v ) evaluate the normal part of the distribution function source"},{"id":27,"pagetitle":"Distributions","title":"GEMPIC.eval_x_density","ref":"/gempic/dev/distributions/#GEMPIC.eval_x_density-Tuple{SumCosGaussian, Union{Float64, Vector{Float64}}}","content":" GEMPIC.eval_x_density  —  Method eval_x_density( f, x ) evaluate the cosine part of the distribution function source"},{"id":30,"pagetitle":"Hamiltonian splitting","title":"Hamiltonian splitting","ref":"/gempic/dev/hamiltonian_splitting/#Hamiltonian-splitting","content":" Hamiltonian splitting"},{"id":31,"pagetitle":"Hamiltonian splitting","title":"GEMPIC.HamiltonianSplitting","ref":"/gempic/dev/hamiltonian_splitting/#GEMPIC.HamiltonianSplitting","content":" GEMPIC.HamiltonianSplitting  —  Type HamiltonianSplitting( maxwell_solver,\n                      kernel_smoother_0, kernel_smoother_1,\n                      particle_group, e_dofs, b_dofs) Hamiltonian splitting type for Vlasov-Maxwell Integral over the spline function on each interval (order p+1) Integral over the spline function on each interval (order p) e_dofs  describing the two components of the electric field b_dofs  describing the magnetic field j_dofs  for kernel representation of current density.  source"},{"id":32,"pagetitle":"Hamiltonian splitting","title":"GEMPIC.lie_splitting!","ref":"/gempic/dev/hamiltonian_splitting/#GEMPIC.lie_splitting!-Tuple{HamiltonianSplitting, Float64, Int64}","content":" GEMPIC.lie_splitting!  —  Method lie_splitting( h, dt, number_steps) Lie splitting source"},{"id":33,"pagetitle":"Hamiltonian splitting","title":"GEMPIC.lie_splitting_back!","ref":"/gempic/dev/hamiltonian_splitting/#GEMPIC.lie_splitting_back!-Tuple{HamiltonianSplitting, Float64, Int64}","content":" GEMPIC.lie_splitting_back!  —  Method lie_splitting_back(h, dt, number_steps) Lie splitting (oposite ordering) source"},{"id":34,"pagetitle":"Hamiltonian splitting","title":"GEMPIC.strang_splitting!","ref":"/gempic/dev/hamiltonian_splitting/#GEMPIC.strang_splitting!-Tuple{HamiltonianSplitting, Float64, Int64}","content":" GEMPIC.strang_splitting!  —  Method strang_splitting( h, dt, number_steps) Strang splitting time splitting object  time step number of time steps source"},{"id":37,"pagetitle":"Hamiltonian splitting Boris","title":"Hamiltonian splitting Boris","ref":"/gempic/dev/hamiltonian_splitting_boris/#Hamiltonian-splitting-Boris","content":" Hamiltonian splitting Boris"},{"id":38,"pagetitle":"Hamiltonian splitting Boris","title":"GEMPIC.HamiltonianSplittingBoris","ref":"/gempic/dev/hamiltonian_splitting_boris/#GEMPIC.HamiltonianSplittingBoris","content":" GEMPIC.HamiltonianSplittingBoris  —  Type HamiltonianSplittingBoris( maxwell_solver,\n                           kernel_smoother_0, kernel_smoother_1,\n                           particle_group,\n                           e_dofs_1, e_dofs_2, b_dofs) Boris pusher in GEMPIC framework (spline finite elements) mid  describing the magnetic field at time  $t_{n+1/2}$  (used for push) j_dofs  for kernel representation of current density.  maxwell_solver     : Maxwell solver kernel_smoother_0  : Kernel smoother kernel_smoother_1  : Kernel smoother particle_group     : Particle group efield_dofs        : array for the coefficients of the efields  bfield_dofs        : array for the coefficients of the bfield x_min              : Lower bound of x domain Lx                 : Length of the domain in x direction. source"},{"id":39,"pagetitle":"Hamiltonian splitting Boris","title":"GEMPIC.push_v_bpart!","ref":"/gempic/dev/hamiltonian_splitting_boris/#GEMPIC.push_v_bpart!-Tuple{HamiltonianSplittingBoris, Float64}","content":" GEMPIC.push_v_bpart!  —  Method push_v_bpart!(splitting, dt) Pusher for vxB part source"},{"id":40,"pagetitle":"Hamiltonian splitting Boris","title":"GEMPIC.push_v_epart!","ref":"/gempic/dev/hamiltonian_splitting_boris/#GEMPIC.push_v_epart!-Tuple{Any, Any}","content":" GEMPIC.push_v_epart!  —  Method push_v_epart(splitting, dt) Pusher for  $E \\nabla_v$  part \\[V_{new} = V_{old} + dt ⋅ E\\] source"},{"id":41,"pagetitle":"Hamiltonian splitting Boris","title":"GEMPIC.push_x_accumulate_j!","ref":"/gempic/dev/hamiltonian_splitting_boris/#GEMPIC.push_x_accumulate_j!-Tuple{Any, Any}","content":" GEMPIC.push_x_accumulate_j!  —  Method push_x_accumulate_j!(splitting, dt) Pusher for x and accumulate current densities For each particle compute the index of the first DoF on the grid it  contributes to and its position (normalized to cell size one).  Then update particle position:   $X_{new} = X_{old} + dt ⋅ V$ Note j_dofs  does not hold the values for j itself but  for the integrated j. source"},{"id":42,"pagetitle":"Hamiltonian splitting Boris","title":"GEMPIC.staggering!","ref":"/gempic/dev/hamiltonian_splitting_boris/#GEMPIC.staggering!-Tuple{Any, Any}","content":" GEMPIC.staggering!  —  Method staggering(splitting, dt) Propagate  $E_0$  to  $E_{1/2}$  and  $x_0$  to  $x_{1/2}$  to initialize  the staggering splitting  : time splitting object  dt    : time step source"},{"id":43,"pagetitle":"Hamiltonian splitting Boris","title":"GEMPIC.strang_splitting!","ref":"/gempic/dev/hamiltonian_splitting_boris/#GEMPIC.strang_splitting!-Tuple{HamiltonianSplittingBoris, Float64, Int64}","content":" GEMPIC.strang_splitting!  —  Method strang_splitting(splitting, dt, number_steps) Second order Boris pusher using staggered grid splitting  : time splitting object  dt    : time step number_steps  : number of time steps source"},{"id":46,"pagetitle":"Splines","title":"Splines","ref":"/gempic/dev/low_level_bsplines/#Splines","content":" Splines"},{"id":47,"pagetitle":"Splines","title":"GEMPIC.eval_uniform_periodic_spline_curve","ref":"/gempic/dev/low_level_bsplines/#GEMPIC.eval_uniform_periodic_spline_curve-Tuple{Int64, Vector{Float64}}","content":" GEMPIC.eval_uniform_periodic_spline_curve  —  Method eval_uniform_periodic_spline_curve( degree, scoef ) Evaluate uniform periodic spline curve defined by coefficients scoef at  knots (which are the grid points)  source"},{"id":48,"pagetitle":"Splines","title":"GEMPIC.uniform_bsplines_eval_basis","ref":"/gempic/dev/low_level_bsplines/#GEMPIC.uniform_bsplines_eval_basis-Tuple{Int64, Float64}","content":" GEMPIC.uniform_bsplines_eval_basis  —  Method uniform_bsplines_eval_basis( spline_degree, normalized_offset, bspl ) UNIFORM B-SPLINE FUNCTIONS Evaluate all non vanishing uniform B-Splines in unit cell. Returns an array with the values of the b-splines of the  requested degree, evaluated at a given cell offset. The cell size is normalized between 0 and 1, thus the offset given must be a number between 0 and 1. Output:  \\[bspl(1:d+1)= B_d(-(d+1)/2+d+x),...,B_d(-(d+1)/2+x)\\] with  $d$ = spline_degree  and  $x$ = normalized_offset  where  $B_d=B_{d-1}*B_0$  and  $B_0=1_[-1/2,1/2]$  and  *  is convolution the following FORTRAN code can be used for comparison with   deboor do i=-d,d+1\n    t(i+d+1)=real(i,8)\nend do\ncall bsplvb(t,d+1,1,normalized_offset,d+1,out) We also have the property (from the symmetry of the B-spline) \\[out[1:d+1]= B_d(-(d+1)/2+xx),...,B_d(-(d+1)/2+d+xx),..., \\] where  $xx=1-$ normalized_offset source"},{"id":51,"pagetitle":"Maxwell solver","title":"Maxwell solver","ref":"/gempic/dev/maxwell_solver/#Maxwell-solver","content":" Maxwell solver"},{"id":52,"pagetitle":"Maxwell solver","title":"GEMPIC.Maxwell1DFEM","ref":"/gempic/dev/maxwell_solver/#GEMPIC.Maxwell1DFEM","content":" GEMPIC.Maxwell1DFEM  —  Type maxwell_solver = MaxwellFEM1D( mesh, degree ) 1D Maxwell spline finite element solver on a periodic grid Lx                    : length of Periodic domain delta_x               : cell size n_dofs                : number of cells (and grid points) s_deg_0               : spline degree 0-forms s_deg_1               : spline degree 1-forms mass_0                : coefficients of 0-form mass matrix mass_1                : coefficients of 1-form mass matrix eig_mass0             : eigenvalues of circulant 0-form mass matrix eig_mass1             : eigenvalues of circulant 1-form mass matrix eig_weak_ampere       : eigenvalues of circulant update matrix for Ampere eig_weak_poisson      : eigenvalues of circulant update matrix for Poisson plan_fw               : fft plan (forward) plan_bw               : fft plan (backward) source"},{"id":53,"pagetitle":"Maxwell solver","title":"GEMPIC.compute_b_from_e!","ref":"/gempic/dev/maxwell_solver/#GEMPIC.compute_b_from_e!-Tuple{Vector{Float64}, Maxwell1DFEM, Float64, Vector{Float64}}","content":" GEMPIC.compute_b_from_e!  —  Method compute_b_from_e!( field_out, maxwell_solver, delta_t, field_in) Compute Bz from Ey using strong 1D Faraday equation for spline coefficients \\[B_z^{new}(x_j) = B_z^{old}(x_j) - \\frac{\\Delta t}{\\Delta x} (E_y(x_j) - E_y(x_{j-1})\\] source"},{"id":54,"pagetitle":"Maxwell solver","title":"GEMPIC.compute_e_from_b!","ref":"/gempic/dev/maxwell_solver/#GEMPIC.compute_e_from_b!-Tuple{Vector{Float64}, Maxwell1DFEM, Float64, Vector{Float64}}","content":" GEMPIC.compute_e_from_b!  —  Method compute_e_from_b!(field_out, maxwell_solver, delta_t, field_in) compute Ey from Bz using weak Ampere formulation  source"},{"id":55,"pagetitle":"Maxwell solver","title":"GEMPIC.compute_e_from_j!","ref":"/gempic/dev/maxwell_solver/#GEMPIC.compute_e_from_j!-Tuple{Vector{Float64}, Maxwell1DFEM, Vector{Float64}, Int64}","content":" GEMPIC.compute_e_from_j!  —  Method compute_e_from_j!(e, maxwell_solver, current, component) Compute  $E_i$  from  $j_i$  integrated over the time interval using weak Ampere formulation source"},{"id":56,"pagetitle":"Maxwell solver","title":"GEMPIC.compute_rhs_from_function!","ref":"/gempic/dev/maxwell_solver/#GEMPIC.compute_rhs_from_function!-Tuple{Vector{Float64}, Maxwell1DFEM, Function, Int64}","content":" GEMPIC.compute_rhs_from_function!  —  Method compute rhs from function(self, func, degree, coefs dofs) Compute the FEM right-hand-side for a given function f and periodic splines of given degree. Its components are  $\\int f N_i dx$  where  $N_i$  is the B-spline starting at  $x_i$ .  source"},{"id":57,"pagetitle":"Maxwell solver","title":"GEMPIC.inner_product","ref":"/gempic/dev/maxwell_solver/#GEMPIC.inner_product-NTuple{4, Any}","content":" GEMPIC.inner_product  —  Method inner_product( maxwell_solver, coefs1_dofs, coefs2_dofs, degree ) maxwell_solver  : Maxwell solver object coefs1_dofs  : Coefficient for each DoF coefs2_dofs  : Coefficient for each DoF `degree : Specify the degree of the basis functions return squared L2 norm source"},{"id":58,"pagetitle":"Maxwell solver","title":"GEMPIC.l2norm_squared","ref":"/gempic/dev/maxwell_solver/#GEMPIC.l2norm_squared-Tuple{Any, Any, Any}","content":" GEMPIC.l2norm_squared  —  Method l2norm_squared(maxwell_solver, coefs_dofs, degree) Compute square of the L2norm  source"},{"id":59,"pagetitle":"Maxwell solver","title":"GEMPIC.l2norm_squared2","ref":"/gempic/dev/maxwell_solver/#GEMPIC.l2norm_squared2-Tuple{Any, Any, Any}","content":" GEMPIC.l2norm_squared2  —  Method l2norm_squared(maxwell_solver, coefs_dofs, degree) Compute square of the L2norm  source"},{"id":60,"pagetitle":"Maxwell solver","title":"GEMPIC.l2projection!","ref":"/gempic/dev/maxwell_solver/#GEMPIC.l2projection!-Tuple{Vector{Float64}, Maxwell1DFEM, Function, Int64}","content":" GEMPIC.l2projection!  —  Method l2projection!(coefs_dofs, maxwell, func, degree) Compute the L2 projection of a given function f on periodic splines  of given degree source"},{"id":63,"pagetitle":"Mesh","title":"Mesh","ref":"/gempic/dev/mesh/#Mesh","content":" Mesh"},{"id":64,"pagetitle":"Mesh","title":"GEMPIC.OneDGrid","ref":"/gempic/dev/mesh/#GEMPIC.OneDGrid","content":" GEMPIC.OneDGrid  —  Type TwoDGrid( xmin, xmax, nx, ymin, ymax, ny ) Simple structure to store mesh data from 2 dimensions source"},{"id":65,"pagetitle":"Mesh","title":"GEMPIC.TwoDGrid","ref":"/gempic/dev/mesh/#GEMPIC.TwoDGrid","content":" GEMPIC.TwoDGrid  —  Type TwoDGrid( dimx, nx, dimy, ny) Generate a cartesians mesh on rectangle  dimx x  dimy  with  nx  x  ny  points nx  : indices are in [1:nx] ny  : indices are in [1:ny] dimx = xmax - xmin dimy = ymax - ymin x, y  : node positions dx, dy  : step size source"},{"id":66,"pagetitle":"Mesh","title":"GEMPIC.get_cell_and_offset","ref":"/gempic/dev/mesh/#GEMPIC.get_cell_and_offset-Tuple{OneDGrid, Any}","content":" GEMPIC.get_cell_and_offset  —  Method get_cell_and_offset( mesh, x ) Get cell and offset We compute the cell indices where the particle is and its relative  normalized position inside the cell source"},{"id":67,"pagetitle":"Mesh","title":"GEMPIC.get_x","ref":"/gempic/dev/mesh/#GEMPIC.get_x-Tuple{OneDGrid, Any}","content":" GEMPIC.get_x  —  Method get_x( mesh, i ) Get position source"},{"id":70,"pagetitle":"Particle group","title":"Particle group","ref":"/gempic/dev/particle_group/#Particle-group","content":" Particle group"},{"id":71,"pagetitle":"Particle group","title":"GEMPIC.ParticleGroup","ref":"/gempic/dev/particle_group/#GEMPIC.ParticleGroup","content":" GEMPIC.ParticleGroup  —  Type ParticleGroup{D,V}( n_particles, charge, mass, q, weights) n_particles  : number of particles  charge       : charge of the particle species mass         : mass of the particle species n_weights    : number of differents weights source"},{"id":72,"pagetitle":"Particle group","title":"GEMPIC.get_charge","ref":"/gempic/dev/particle_group/#GEMPIC.get_charge-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64}} where {D, V}","content":" GEMPIC.get_charge  —  Method get_charge( p, i; i_wi=1) Get charge of ith particle of p (q * particle_weight) source"},{"id":73,"pagetitle":"Particle group","title":"GEMPIC.get_mass","ref":"/gempic/dev/particle_group/#GEMPIC.get_mass-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64}} where {D, V}","content":" GEMPIC.get_mass  —  Method get_mass( p, i; i_wi=1) Get mass of ith particle of p (m * particle_weight) source"},{"id":74,"pagetitle":"Particle group","title":"GEMPIC.get_v","ref":"/gempic/dev/particle_group/#GEMPIC.get_v-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64}} where {D, V}","content":" GEMPIC.get_v  —  Method get_v( p, i ) Get velocity of ith particle of p source"},{"id":75,"pagetitle":"Particle group","title":"GEMPIC.get_weights","ref":"/gempic/dev/particle_group/#GEMPIC.get_weights-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64}} where {D, V}","content":" GEMPIC.get_weights  —  Method get_weights( p, i) Get ith particle weights of group p source"},{"id":76,"pagetitle":"Particle group","title":"GEMPIC.get_x","ref":"/gempic/dev/particle_group/#GEMPIC.get_x-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64}} where {D, V}","content":" GEMPIC.get_x  —  Method get_x( p, i ) Get position of ith particle of p source"},{"id":77,"pagetitle":"Particle group","title":"GEMPIC.set_v!","ref":"/gempic/dev/particle_group/#GEMPIC.set_v!-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64, Float64}} where {D, V}","content":" GEMPIC.set_v!  —  Method set_v!( p, i, v) Set velocity of ith particle of p to v source"},{"id":78,"pagetitle":"Particle group","title":"GEMPIC.set_v!","ref":"/gempic/dev/particle_group/#GEMPIC.set_v!-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64, Vector{Float64}}} where {D, V}","content":" GEMPIC.set_v!  —  Method set_v!( p, i, v) Set velocity of ith particle of p to v source"},{"id":79,"pagetitle":"Particle group","title":"GEMPIC.set_weights!","ref":"/gempic/dev/particle_group/#GEMPIC.set_weights!-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64, Float64}} where {D, V}","content":" GEMPIC.set_weights!  —  Method set_weights!( p, i, w) Set weights of particle @ i source"},{"id":80,"pagetitle":"Particle group","title":"GEMPIC.set_weights!","ref":"/gempic/dev/particle_group/#GEMPIC.set_weights!-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64, Vector{Float64}}} where {D, V}","content":" GEMPIC.set_weights!  —  Method set_weights!( p, i, w) Set weights of ith particle of p to w source"},{"id":81,"pagetitle":"Particle group","title":"GEMPIC.set_x!","ref":"/gempic/dev/particle_group/#GEMPIC.set_x!-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64, Float64}} where {D, V}","content":" GEMPIC.set_x!  —  Method set_x!( p, i, x) Set position of ith particle of p to x Note if  x  is a scalar value, only the first x dimension will be set. source"},{"id":82,"pagetitle":"Particle group","title":"GEMPIC.set_x!","ref":"/gempic/dev/particle_group/#GEMPIC.set_x!-Union{Tuple{V}, Tuple{D}, Tuple{ParticleGroup{D, V}, Int64, Vector{Float64}}} where {D, V}","content":" GEMPIC.set_x!  —  Method set_x!( p, i, x ) Set position of ith particle of p to x  source"},{"id":85,"pagetitle":"Particle-Mesh coupling","title":"Particle-Mesh coupling","ref":"/gempic/dev/particle_mesh_coupling/#Particle-Mesh-coupling","content":" Particle-Mesh coupling"},{"id":86,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.ParticleMeshCoupling1D","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.ParticleMeshCoupling1D","content":" GEMPIC.ParticleMeshCoupling1D  —  Type ParticleMeshCoupling1D( mesh, no_particles, spline_degree, \n                      smoothing_type ) Kernel smoother with splines of arbitrary degree placed on a uniform mesh. Spline with index i starts at point i delta_x  : Value of grid spacing along both directions. n_grid  : Array containing number ofpoints along each direction no_particles  : Number of particles of underlying PIC method  spline_degree  : Degree of smoothing kernel spline n_span  : Number of intervals where spline non zero (spline_degree + 1) scaling  : Scaling factor depending on whether :galerkin or :collocation n_quad_points  : Number of quadrature points spline_val : scratch data for spline evaluation spline_val_more  : more scratch data for spline evaluation quad_x, quad_w  : quadrature weights and points Note Only 1D version is implemented for now source"},{"id":87,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_charge!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_charge!-Tuple{Vector{Float64}, ParticleMeshCoupling1D, Float64, Float64}","content":" GEMPIC.add_charge!  —  Method add_charge!( rho, p, position, marker_charge) Add charge of one particle p              : kernel smoother object position       : Position of the particle marker_charge  : Particle weights time charge rho_dofs       : Coefficient vector of the charge distribution source"},{"id":88,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_charge_pp!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_charge_pp!-Tuple{Vector{Float64}, ParticleMeshCoupling1D, Float64, Any}","content":" GEMPIC.add_charge_pp!  —  Method add_charge_pp!(rho_dofs, p, position, marker_charge) Add charge of one particle p              : kernel smoother object position       : Position of the particle marker_charge  : Particle weights time charge rho_dofs       : Coefficient vector of the charge distribution source"},{"id":89,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_current_update_v!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_current_update_v!-Tuple{AbstractArray, ParticleMeshCoupling1D, Float64, Float64, Float64, Float64, Vector{Float64}, Float64}","content":" GEMPIC.add_current_update_v!  —  Method add_current_update_v!( j_dofs, p, \n                       position_old, position_new, \n                       marker_charge, qoverm, \n                       bfield_dofs, vi) Add current for one particle and update v (according to  $H_{p1}$  part in Hamiltonian splitting) Read out particle position and velocity Compute index_old, the index of the last DoF on the grid the  particle contributes to, and  r_old , its position (normalized to cell size one). source"},{"id":90,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_current_update_v!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_current_update_v!-Tuple{AbstractArray, ParticleMeshCoupling1D, Vararg{Float64, 5}}","content":" GEMPIC.add_current_update_v!  —  Method add_current_update_v!( j_dofs, p, \n                       position_old, position_new, \n                       marker_charge, qoverm, vi) Add current for one particle and update v (according to  $H_{p1}$  part in Hamiltonian splitting) This is the 1d1v case, there is no magnetic field. Read out particle position and velocity Compute index_old, the index of the last DoF on the grid the  particle contributes to, and  r_old , its position (normalized to cell size one). source"},{"id":91,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_current_update_v_pp!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_current_update_v_pp!-Tuple{AbstractArray, ParticleMeshCoupling1D, Any, Any, Float64, Float64, Vector{Float64}, Vector{Float64}}","content":" GEMPIC.add_current_update_v_pp!  —  Method add_current_update_v_pp!( j_dofs, p, position_old, position_new, \n                          marker_charge, qoverm, bfield_dofs, vi) Add current for one particle and update v  (according to  H_p1  part in Hamiltonian splitting) source"},{"id":92,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.evaluate","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.evaluate-Tuple{ParticleMeshCoupling1D, Float64, Vector{Float64}}","content":" GEMPIC.evaluate  —  Method evaluate(p, position, field_dofs) Evaluate field at  position p  : Kernel smoother object  position  : Position of the particle field_dofs  : Coefficient vector for the field DoFs field_value  : Value(s) of the electric fields at given position source"},{"id":93,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.evaluate_pp","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.evaluate_pp-Tuple{ParticleMeshCoupling1D, Float64, Matrix{Float64}}","content":" GEMPIC.evaluate_pp  —  Method evaluate_pp(p, position, field_dofs_pp) Evaluate field at  position  using horner scheme p  : Kernel smoother object  position  : Position of the particle field_dofs_pp  : Degrees of freedom in kernel representation. field_value  : Value(s) of the electric fields at given position source"},{"id":94,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.update_jv!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.update_jv!-Tuple{AbstractArray, ParticleMeshCoupling1D, Float64, Float64, Int64, Float64, Float64, Float64, Float64, Vector{Float64}}","content":" GEMPIC.update_jv!  —  Method update_jv!(j_dofs, p, \n           lower, upper, index, marker_charge, \n           qoverm, sign, vi, bfield_dofs) Helper function for  add_current_update_v . source"},{"id":95,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.update_jv!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.update_jv!-Tuple{AbstractArray, ParticleMeshCoupling1D, Float64, Float64, Int64, Vararg{Float64, 4}}","content":" GEMPIC.update_jv!  —  Method update_jv!(j_dofs, p, \n           lower, upper, index, marker_charge, \n           qoverm, sign, vi) Helper function for  add_current_update_v  without the magnetic field (1d1v case) source"},{"id":96,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.update_jv_pp!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.update_jv_pp!-Tuple{AbstractArray, ParticleMeshCoupling1D, Float64, Float64, Int64, Float64, Float64, Float64, Vector{Float64}}","content":" GEMPIC.update_jv_pp!  —  Method update_jv_pp!( j_dofs, p, lower, upper, index, marker_charge, \n               qoverm, vi, bfield_dofs) Helper function for  add_current_update_v . source"},{"id":97,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.ParticleMeshCoupling2D","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.ParticleMeshCoupling2D","content":" GEMPIC.ParticleMeshCoupling2D  —  Type ParticleMeshCoupling2D( pg, grid, degree, smoothing_type) n_grid(2) : no. of spline coefficients domain(2,2) : lower and upper bounds of the domain no_particles : no. of particles degree : Degree of smoothing kernel spline smoothing_type : Define if Galerkin or collocation smoothing for right scaling in accumulation routines  source"},{"id":98,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_charge!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_charge!-Tuple{Any, ParticleMeshCoupling2D, Any, Any, Any}","content":" GEMPIC.add_charge!  —  Method add_charge!(ρ_dofs, pm, xp, yp, wp) Add charge of single particle position : Particle position wp : Particle weight times charge ρ_dofs : spline coefficient of accumulated density source"},{"id":99,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.add_charge_pp!","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.add_charge_pp!-Tuple{Any, ParticleMeshCoupling2D, Any, Any, Any}","content":" GEMPIC.add_charge_pp!  —  Method add_charge_pp!(ρ_dofs, pm, xp, yp, wp) Add charge of single particle Information about the 2d mesh delta_x(2)  : Value of grid spacing along both directions. domain(2,2) : Definition of the domain: domain(1,1) = x1 min, domain(2,1) = x2 min,  domain(1,2) = x1 max, domain(2,2) = x2 max Information about the particles no_particles : Number of particles of underlying PIC method (processor local) n_span : Number of intervals where spline non zero (degree + 1) scaling position : Particle position wp : Particle weight times charge ρ_dofs : spline coefficient of accumulated density source"},{"id":100,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.compute_shape_factor","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.compute_shape_factor-Tuple{ParticleMeshCoupling2D, Any, Any}","content":" GEMPIC.compute_shape_factor  —  Method compute_shape_factor(pm, xp, yp) Helper function computing shape factor pm : kernel smoother object xp, xp : poisition of the particle source"},{"id":101,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.evaluate","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.evaluate-NTuple{4, Any}","content":" GEMPIC.evaluate  —  Method evaluate(pm, xp, yp, field_dofs) position(pm.dim) : Position where to evaluate field dofs(pm.n dofs) : Degrees of freedom in kernel representation. field_value : Value of the field Evaluate field with given dofs at position source"},{"id":102,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.evaluate_multiple","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.evaluate_multiple-Tuple{Any, Any, Any}","content":" GEMPIC.evaluate_multiple  —  Method evaluate_multiple(pm, position, field_dofs) Evaluate multiple fields at position � position position(pm%dim) : Position where to evaluate components(:) : Components of the field that shall be evaluated field_dofs(:,:) : Degrees of freedom in kernel representation. field_value(:) : Value of the field source"},{"id":103,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.evaluate_pp","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.evaluate_pp-Tuple{ParticleMeshCoupling2D, Any, Any, Any}","content":" GEMPIC.evaluate_pp  —  Method evaluate_pp(pm, xp, yp, pp) Evaluate field at position using horner scheme pm : kernel smoother object     position : Position where to evaluate field dofs pp(:,:) : Degrees of freedom in kernel representation. field_value : Value of the field source"},{"id":104,"pagetitle":"Particle-Mesh coupling","title":"GEMPIC.index_1dto2d_column_major","ref":"/gempic/dev/particle_mesh_coupling/#GEMPIC.index_1dto2d_column_major-Tuple{Any, Any, Any}","content":" GEMPIC.index_1dto2d_column_major  —  Method index_1dto2d_column_major(pm, index1d_1, index_1d_2) Self function computes the index of a 1D array that stores 2D data in column major ordering.  It also takes periodic boundary conditions into account. index1d_1 !< indice along x (start counting with zero). index1d_2 !< indice along y (start counting with zero). index2d   !< Corresponding index in 1d array representing 2d data (start counting with one). source"},{"id":107,"pagetitle":"Particle sampling","title":"Particle sampling","ref":"/gempic/dev/particle_sampling/#Particle-sampling","content":" Particle sampling"},{"id":108,"pagetitle":"Particle sampling","title":"GEMPIC.ParticleSampler","ref":"/gempic/dev/particle_sampling/#GEMPIC.ParticleSampler","content":" GEMPIC.ParticleSampler  —  Type ParticleSampler{D,V}( sampling_type, symmetric, dims, n_particles) Particle initializer class with various functions to initialize a particle. sampling_type  :  :random  or  :sobol symmetric  :  true  or  false n_particles  : number of particles source"},{"id":109,"pagetitle":"Particle sampling","title":"GEMPIC.newton","ref":"/gempic/dev/particle_sampling/#GEMPIC.newton-Tuple{Any, Any, Any}","content":" GEMPIC.newton  —  Method  newton(r, α, k) Function to solve  $P(x) - r = 0$  where  $r \\in [0, 2π/k]$ where  $P$  is the cdf of  $f(x) = 1 + α \\cos(k x)$ source"},{"id":110,"pagetitle":"Particle sampling","title":"GEMPIC.sample!","ref":"/gempic/dev/particle_sampling/#GEMPIC.sample!-Tuple{ParticleGroup{1, 1}, Float64, Float64, Float64, OneDGrid}","content":" GEMPIC.sample!  —  Method sample!( pg::ParticleGroup{1,1}, α, k, σ, mesh::OneDGrid) Sampling from a probability distribution to initialize a Landau damping in 1D1V space. \\[f_0(x,v,t) = \\frac{n_0}{\\sqrt{2π} v_{th}} ( 1 + \\alpha cos(k_x x)) exp( - \\frac{v^2}{2 v_{th}^2})\\] source"},{"id":111,"pagetitle":"Particle sampling","title":"GEMPIC.sample!","ref":"/gempic/dev/particle_sampling/#GEMPIC.sample!-Tuple{ParticleGroup{1, 2}, Float64, Float64, Float64, OneDGrid}","content":" GEMPIC.sample!  —  Method sample!( pg::ParticleGroup{2,1}, α, k, σ, mesh::OneDGrid) Sampling from a probability distribution to initialize a Landau damping in 1D1V space. \\[f_0(x,v,t) = \\frac{n_0}{2π v_{th}^2} ( 1 + \\alpha cos(k_x x)) exp( - \\frac{v^2}{2 v_{th}^2})\\] source"},{"id":112,"pagetitle":"Particle sampling","title":"GEMPIC.sample!","ref":"/gempic/dev/particle_sampling/#GEMPIC.sample!-Tuple{ParticleGroup{1, 2}, ParticleSampler, GEMPIC.AbstractCosGaussian, GEMPIC.AbstractGrid}","content":" GEMPIC.sample!  —  Method sample!( pg, ps, df, mesh) Sample from a Particle sampler pg    : Particle group ps    : Particle sampler df    : Distribution function xmin  : lower bound of the domain dimx  : length of the domain. source"},{"id":113,"pagetitle":"Particle sampling","title":"GEMPIC.sample_all","ref":"/gempic/dev/particle_sampling/#GEMPIC.sample_all-Tuple{Any, ParticleGroup{1, 2}, GEMPIC.AbstractCosGaussian, Any}","content":" GEMPIC.sample_all  —  Method sample_all( ps, pg, df, mesh ) Helper function for pure sampling source"},{"id":114,"pagetitle":"Particle sampling","title":"GEMPIC.sample_sym","ref":"/gempic/dev/particle_sampling/#GEMPIC.sample_sym-NTuple{4, Any}","content":" GEMPIC.sample_sym  —  Method sample_sym( ps, pg, df, mesh ) Helper function for antithetic sampling in 1d2v source"},{"id":115,"pagetitle":"Particle sampling","title":"Special case of the Landau Damping","ref":"/gempic/dev/particle_sampling/#Special-case-of-the-Landau-Damping","content":" Special case of the Landau Damping"},{"id":116,"pagetitle":"Particle sampling","title":"GEMPIC.LandauDamping","ref":"/gempic/dev/particle_sampling/#GEMPIC.LandauDamping","content":" GEMPIC.LandauDamping  —  Type Landau( α, kx) Test structure to initialize a particles distribtion for Landau damping test case in 1D1V and 1D2V source"},{"id":117,"pagetitle":"Particle sampling","title":"GEMPIC.sample!","ref":"/gempic/dev/particle_sampling/#GEMPIC.sample!-Tuple{GEMPIC.LandauDamping, ParticleGroup{1, 2}}","content":" GEMPIC.sample!  —  Method sample!(d, pg) Sampling from a probability distribution to initialize a Landau damping in 1D2V space. \\[f_0(x,v,t) = \\frac{n_0}{2π v_{th}^2} ( 1 + \\alpha cos(k_x x))\n exp( - \\frac{v_x^2+v_y^2}{2 v_{th}^2})\\] The newton function solves the equation  $P(x)-r=0$  with Newton’s method \\[x^{n+1} = x^n – (P(x)-(2\\pi r / k)/f(x) \\] with  \\[P(x) = \\int_0^x (1 + \\alpha cos(k_x y)) dy = x + \\frac{\\alpha}{k_x} sin(k_x x)\\] source"},{"id":120,"pagetitle":"Periodic spline","title":"Periodic spline","ref":"/gempic/dev/splinepp/#Periodic-spline","content":" Periodic spline"},{"id":121,"pagetitle":"Periodic spline","title":"GEMPIC.SplinePP","ref":"/gempic/dev/splinepp/#GEMPIC.SplinePP","content":" GEMPIC.SplinePP  —  Type SplinePP( degree, ncells) degree  : degree of 1d spline poly_coeffs  :  poly_coeffs[i,j]  coefficient of  $x^{deg+1-j}$  for ith B-spline function  size= (degree+1, degree+1) poly_coeffs_fp  :  poly_coeffs[i,j]  coefficient of  $x^{deg+1-j}$  for ith B-spline function  size= (degree+1, degree+1) ncells  : number of gridcells scratch_b  : scratch data for  b_to_pp-converting scratch_p  : scratch data for  b_to_pp-converting source"},{"id":122,"pagetitle":"Periodic spline","title":"GEMPIC.b_to_pp","ref":"/gempic/dev/splinepp/#GEMPIC.b_to_pp-Tuple{GEMPIC.SplinePP, Int64, Vector{Float64}}","content":" GEMPIC.b_to_pp  —  Method b_to_pp( SplinePP, ncells, b_coeffs) Convert 1d spline in B form to spline in pp form with  periodic boundary conditions source"},{"id":123,"pagetitle":"Periodic spline","title":"GEMPIC.b_to_pp_1d_cell!","ref":"/gempic/dev/splinepp/#GEMPIC.b_to_pp_1d_cell!-Tuple{Any, Any, Any}","content":" GEMPIC.b_to_pp_1d_cell!  —  Method b_to_pp_1d_cell( self, b_coeffs, pp_coeffs ) Convert 1d spline in B form in a cell to spline in pp form with periodic boundary conditions spline : arbitrary degree 1d spline  b_coeffs(self%degree+1) : coefficients of spline in B-form pp_coeffs(self%degree+1) : coefficients of spline in pp-form source"},{"id":124,"pagetitle":"Periodic spline","title":"GEMPIC.b_to_pp_2d!","ref":"/gempic/dev/splinepp/#GEMPIC.b_to_pp_2d!-Tuple{Any, GEMPIC.SplinePP, GEMPIC.SplinePP, Any}","content":" GEMPIC.b_to_pp_2d!  —  Method b_to_pp_2d!( pp, spl1, spl2, b) Convert 2d spline in B form to spline in pp form    n_cells(2) : number of gridcells b_coeffs   : coefficients of spline in B-form pp_coeffs  : coefficients of spline in pp-form source"},{"id":125,"pagetitle":"Periodic spline","title":"GEMPIC.b_to_pp_2d_cell!","ref":"/gempic/dev/splinepp/#GEMPIC.b_to_pp_2d_cell!-Tuple{Any, GEMPIC.SplinePP, GEMPIC.SplinePP, Any, Any, Any}","content":" GEMPIC.b_to_pp_2d_cell!  —  Method b_to_pp_2d_cell(spline1, spline2, b_coeffs, pp_coeffs, i, j) Convert 2d spline in B form in a cell to spline in pp form with periodic boundary conditions  spline1 : arbitrary degree 1d spline spline2 : arbitrary degree 1d spline n_cells(2) : number of gridcells b coeffs(n cells(1)*n_cells(2)) : coefficients of spline in B-form pp coeffs((spline1.degree+1)*(spline2.degree+1),n cells(1)*n_cells(2)) : coefficients of spline in pp-form source"},{"id":126,"pagetitle":"Periodic spline","title":"GEMPIC.horner_1d","ref":"/gempic/dev/splinepp/#GEMPIC.horner_1d-Tuple{Int64, Any, Float64, Int64}","content":" GEMPIC.horner_1d  —  Method horner_1d(degree, pp_coeffs, x, index) Perform a 1d Horner schema on the  pp_coeffs  at index source"},{"id":127,"pagetitle":"Periodic spline","title":"GEMPIC.horner_2d","ref":"/gempic/dev/splinepp/#GEMPIC.horner_2d-NTuple{5, Any}","content":" GEMPIC.horner_2d  —  Method horner_2d(degrees, pp_coeffs, position, indices, ncells) Perform a 2d hornerschema on the pp_coeffs at the indices degree : degree of the spline pp_coeffs : coefficients of spline in pp-form position(2) : point at which we evaluate our spline indices(2) : indices of cell in which is x ncells(2) : number of gridcells res : value of the splinefunction at position source"},{"id":128,"pagetitle":"Periodic spline","title":"GEMPIC.horner_m_2d!","ref":"/gempic/dev/splinepp/#GEMPIC.horner_m_2d!-Tuple{Any, GEMPIC.SplinePP, GEMPIC.SplinePP, Any, Any, Any}","content":" GEMPIC.horner_m_2d!  —  Method horner_m_2d!(val, spl1, spl2, degree, x) Perform two times a 1d hornerschema on the poly_coeffs val : array of values degree : degree of the spline x : point at which we evaluate our spline source"},{"id":129,"pagetitle":"Periodic spline","title":"GEMPIC.horner_primitive_1d","ref":"/gempic/dev/splinepp/#GEMPIC.horner_primitive_1d-Tuple{Vector{Float64}, Any, Any, Any}","content":" GEMPIC.horner_primitive_1d  —  Method horner_primitive_1d(val, degree, pp_coeffs, x) Perform a 1d Horner schema on the  pp_coeffs  evaluate at x source"},{"id":132,"pagetitle":"Strong Landau Damping","title":"Strong Landau Damping","ref":"/gempic/dev/strong_landau_damping/#Strong-Landau-Damping","content":" Strong Landau Damping If we only use the subsystems  $H_p$  and  $H_E$ , we are solving Vlasov–Poisson system. In this test, initial condition is as follows: \\[f_0(x,v) = \\frac{1}{\\sqrt{2\\pi} \\sigma}e^{-\\frac{v^2}{2\\sigma^2}}(1+\\alpha \\cos(kx)), \\quad E_{10} (x) = \\frac{\\alpha}{k}\\sin(kx), \\ x \\in [0,2\\pi/k ),  \\ v \\in \\mathbb{R}^2.\\] using GEMPIC The physical parameters are chosen as  $\\sigma = 1$ ,  $k = 0.5$ ,  $\\alpha = 0.5$ , and the numerical parameters as  $\\Delta t = 0.05$ ,  $n_x = 32$  and  $2 \\times 10^5$  particles. We use second order Strang splitting method in time. σ, μ = 1.0, 0.0\nkx, α = 0.5, 0.5\nxmin, xmax = 0, 2π/kx\n∆t = 0.05\nnx = 32\nn_particles = 100000\nmesh = OneDGrid( xmin, xmax, nx)\nspline_degree = 3\n\ndf = CosSumGaussian{1,2}([[kx]], [α], [[σ,σ]], [[μ,μ]] )\n\nmass, charge = 1.0, 1.0\nparticle_group = ParticleGroup{1,2}(n_particles)\nsampler = ParticleSampler{1,2}( :sobol, true, n_particles)\n\nsample!(particle_group, sampler, df, mesh)\n\nxp = view(particle_group.array, 1, :)\nvp = view(particle_group.array, 2:3, :)\nwp = view(particle_group.array, 4, :);\n\np = plot(layout=(3,1))\nhistogram!(p[1,1], xp, weights=wp, normalize=true, bins = 100, lab = \"\")\nplot!(p[1,1], x-> (1+α*cos(kx*x))/(2π/kx), 0., 2π/kx, lab=\"\")\nhistogram!(p[2,1], vp[1,:], weights=wp, normalize=true, bins = 100, lab = \"\")\nplot!(p[2,1], v-> exp( - v^2 / 2) * 4 / π^2 , -6, 6, lab=\"\")\nhistogram!(p[3,1], vp[2,:], weights=wp, normalize=true, bins = 100, lab = \"\")\nplot!(p[3,1], v-> exp( - v^2 / 2) * 4 / π^2 , -6, 6, lab=\"\") Initialize the arrays for the spline coefficients of the fields kernel_smoother1 = ParticleMeshCoupling1D( mesh, n_particles, spline_degree-1, :galerkin)\nkernel_smoother0 = ParticleMeshCoupling1D( mesh, n_particles, spline_degree, :galerkin) ParticleMeshCoupling1D(1, 0.39269908169872414, 32, 32, 100000, 3, 4, 1.0, 2, [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [-0.5773502691896258, 0.5773502691896258], [1.0, 1.0], GEMPIC.SplinePP{4}(3, [-0.16666666666666666 0.5 -0.5 0.16666666666666666; 0.5 -1.0 0.5 0.0; -0.5 0.0 0.5 0.0; 0.16666666666666666 0.6666666666666666 0.16666666666666666 0.0], [-0.041666666666666664 0.125 -0.125 0.041666666666666664; 0.16666666666666666 -0.3333333333333333 0.16666666666666666 0.0; -0.25 0.0 0.25 0.0; 0.16666666666666666 0.6666666666666666 0.16666666666666666 0.0], 32), 0.0, 12.566370614359172)"},{"id":133,"pagetitle":"Strong Landau Damping","title":"Initialize field solver","ref":"/gempic/dev/strong_landau_damping/#Initialize-field-solver","content":" Initialize field solver p = plot(layout=(1,2))\nrho = zeros(Float64, nx)\nefield_poisson = zeros(Float64, nx)\nmaxwell_solver = Maxwell1DFEM(mesh, spline_degree)\nsolve_poisson!( efield_poisson, particle_group, kernel_smoother0, maxwell_solver, rho )\nxg = LinRange(xmin, xmax, nx)\nsval = eval_uniform_periodic_spline_curve(spline_degree-1, rho)\nplot!(p[1,1], xg, sval, title=:rho, label=nothing)\nsval = eval_uniform_periodic_spline_curve(spline_degree-1, efield_poisson)\nplot!(p[1,2], xg, sval, title=:ex, label=nothing )"},{"id":134,"pagetitle":"Strong Landau Damping","title":"Simulation function","ref":"/gempic/dev/strong_landau_damping/#Simulation-function","content":" Simulation function You will get better performance if your simulation is inside a function: function run( steps)\n\n    σ, μ = 1.0, 0.0\n    kx, α = 0.5, 0.5\n    xmin, xmax = 0, 2π/kx\n    dt = 0.05\n    nx = 32\n    n_particles = 100000\n    mesh = OneDGrid( xmin, xmax, nx)\n    spline_degree = 3\n\n    df = CosSumGaussian{1,2}([[kx]], [α], [[σ,σ]], [[μ,μ]] )\n\n    mass, charge = 1.0, 1.0\n    particle_group = ParticleGroup{1,2}(n_particles)\n    sampler = ParticleSampler{1,2}( :sobol, true, n_particles)\n\n    sample!(particle_group, sampler, df, mesh)\n\n    kernel_smoother1 = ParticleMeshCoupling1D( mesh, n_particles, spline_degree-1, :galerkin)\n    kernel_smoother0 = ParticleMeshCoupling1D( mesh, n_particles, spline_degree, :galerkin)\n\n    rho = zeros(Float64, nx)\n    efield_poisson = zeros(Float64, nx)\n\n    maxwell_solver = Maxwell1DFEM(mesh, spline_degree)\n\n    solve_poisson!( efield_poisson, particle_group, kernel_smoother0, maxwell_solver, rho )\n\n    efield_dofs = [efield_poisson, zeros(Float64, nx)]\n    bfield_dofs = zeros(Float64, nx)\n\n    propagator = HamiltonianSplitting{1,2}( maxwell_solver,\n                                       kernel_smoother0,\n                                       kernel_smoother1,\n                                       particle_group,\n                                       efield_dofs,\n                                       bfield_dofs)\n\n    efield_dofs_n = propagator.e_dofs\n\n    thdiag = TimeHistoryDiagnostics( particle_group, maxwell_solver,\n                            kernel_smoother0, kernel_smoother1 )\n\n    for j = 1:steps # loop over time\n\n        strang_splitting!(propagator, dt, 1)\n\n        solve_poisson!( efield_poisson, particle_group,\n                        kernel_smoother0, maxwell_solver, rho)\n\n        write_step!(thdiag, j * dt, spline_degree,\n                        efield_dofs,  bfield_dofs,\n                        efield_dofs_n, efield_poisson)\n    end\n\n    return thdiag.data\n\nend run (generic function with 1 method) @time results = run(1000);  70.055264 seconds (601.44 k allocations: 45.853 MiB, 0.03% gc time, 0.59% compilation time)"},{"id":135,"pagetitle":"Strong Landau Damping","title":"Time evolution of electric energy","ref":"/gempic/dev/strong_landau_damping/#Time-evolution-of-electric-energy","content":" Time evolution of electric energy plot(results[!,:Time], log.(results[!,:PotentialEnergyE1]))"},{"id":138,"pagetitle":"Home","title":"SemiLagrangian.jl Documentation","ref":"/semi-lagrangian/dev/#SemiLagrangian.jl-Documentation","content":" SemiLagrangian.jl Documentation Let us consider an abstract scalar advection equation of the form $ \\frac{∂f}{∂t}+ a(x, t) ⋅ ∇f = 0. $ The characteristic curves associated to this equation are the solutions of  the ordinary differential equations $ \\frac{dX}{dt} = a(X(t), t) $ We shall denote by  $X(t, x, s)$  the unique solution of this equation  associated to the initial condition  $X(s) = x$ . The classical semi-Lagrangian method is based on a backtracking of  characteristics. Two steps are needed to update the distribution function   $f^{n+1}$  at  $t^{n+1}$  from its value  $f^n$  at time  $t^n$  : For each grid point  $x_i$  compute  $X(t^n; x_i, t^{n+1})$  the value  of the characteristic at  $t^n$  which takes the value  $x_i$  at   $t^{n+1}$ . As the distribution solution of first equation verifies  $f^{n+1}(x_i) = f^n(X(t^n; x_i, t^{n+1})),$  we obtain the desired value of  $f^{n+1}(x_i)$  by computing   $f^n(X(t^n;x_i,t^{n+1})$  by interpolation as  $X(t^n; x_i, t^{n+1})$   is in general not a grid point. Eric Sonnendrücker - Numerical methods for the Vlasov equations"},{"id":139,"pagetitle":"Home","title":"SemiLagrangian.SemiLagrangian","ref":"/semi-lagrangian/dev/#SemiLagrangian.SemiLagrangian","content":" SemiLagrangian.SemiLagrangian  —  Module SemiLagrangian.jl Advection implementation in Julia using Semi-Lagrangian numerical method Note This package is difficult to use directly. There is still a lack of documentation  and some parts like splines need to be optimized. This package has been developed  to calculate the interpolations and advections used in the package   VlasovSolvers.jl . Dependencies Base Base.Threads Core DocStringExtensions FFTW LinearAlgebra Polynomials Requires source"},{"id":142,"pagetitle":"Advection","title":"Advection","ref":"/semi-lagrangian/dev/advection/#Advection","content":" Advection"},{"id":143,"pagetitle":"Advection","title":"SemiLagrangian.hamsplit_3_11","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.hamsplit_3_11-Union{Tuple{T}, Tuple{T, Any}} where T<:Number","content":" SemiLagrangian.hamsplit_3_11  —  Method hamsplit_3_11(dt)\nhamsplit_3_11(dt, fltrace)\n source"},{"id":144,"pagetitle":"Advection","title":"SemiLagrangian.magicsplit","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.magicsplit-Tuple{T} where T","content":" SemiLagrangian.magicsplit  —  Method magicsplit(dt)\n source"},{"id":145,"pagetitle":"Advection","title":"SemiLagrangian.nosplit","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.nosplit-Tuple{T} where T","content":" SemiLagrangian.nosplit  —  Method nosplit(dt)\n source"},{"id":146,"pagetitle":"Advection","title":"SemiLagrangian.order6split","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.order6split-Tuple{T} where T","content":" SemiLagrangian.order6split  —  Method order6split(dt)\n source"},{"id":147,"pagetitle":"Advection","title":"SemiLagrangian.standardsplit","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.standardsplit-Tuple{T} where T","content":" SemiLagrangian.standardsplit  —  Method standardsplit(dt)\n source"},{"id":148,"pagetitle":"Advection","title":"SemiLagrangian.strangsplit","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.strangsplit-Tuple{T} where T","content":" SemiLagrangian.strangsplit  —  Method strangsplit(dt)\n source"},{"id":149,"pagetitle":"Advection","title":"SemiLagrangian.table2split","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.table2split-Tuple{T} where T","content":" SemiLagrangian.table2split  —  Method table2split(dt)\n source"},{"id":150,"pagetitle":"Advection","title":"SemiLagrangian.triplejumpsplit","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.triplejumpsplit-Tuple{T} where T","content":" SemiLagrangian.triplejumpsplit  —  Method triplejumpsplit(dt)\n source"},{"id":151,"pagetitle":"Advection","title":"SemiLagrangian.Advection","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.Advection","content":" SemiLagrangian.Advection  —  Type struct Advection{T, N, I, timeopt, timealg, ordalg} Advection{T}\nAdvection(\n    t_mesh::NTuple{N,UniformMesh{T}},\n    t_interp::Vector{I}\n    dt_base::T;\n    tab_coef = [1 // 1],\n    tab_fct = missing,\n    timeopt::TimeOptimization = NoTimeOpt,\n) where {T, N, I <: AbstractInterpolation{T}} Immutable structure that contains constant parameters for multidimensional advection Type parameters T::DataType  : type of data N  : number of dimensions I  : commun type of interpolation timeopt::TimeOptimization  : time optimization Arguments t_mesh::NTuple{N, UniformMesh{T}}  : tuple of meshes (one for each dimension) t_interp::Vector{I}  : tuple of interpolations (one for each dimension) dt_base::T  : time delta for one advection series Keywords tab_coef=[1//2, 1//1, 1//2]  : coefficient table for one advection series, the   coefficients at odd indexes is for space advection series, the coefficients at even indexes is for velocity advection series tab_fct=[identity, identity, identity]  : function table for one advection series, with the same indexes than tab_coef Implementation sizeall  : tuple of the sizes of all dimensions (space before velocity) t_mesh_sp  : tuple of space meshes t_mesh_v  : tuple of velocity meshes t_interp_sp  : tuple of space interpolation types t_interp_v  : tuple of velocity interpolation types dt_base::T  : time unit of an advection series tab_coef  : coefficient table v_square  : precompute for ke nbsplit  : number of slices for split mpiid  : MPI id Throws ArgumentError  :  Nsp  must be less or equal to  Nv . source"},{"id":152,"pagetitle":"Advection","title":"SemiLagrangian.AdvectionData","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.AdvectionData","content":" SemiLagrangian.AdvectionData  —  Type mutable struct AdvectionData{T, N, timeopt, timealg} AdvectionData{T,N,timeopt}\nAdvectionData(\nadv::Advection{T,N,timeopt},\ndata::Array{T,N},\nparext) Mutable structure that contains variable parameters of advection series Type parameters T::DataType  : type of data N  : number of dimensions timeopt::TimeOptimization  : time optimization Arguments adv::Advection{T,N}  : link to the constant data of this advection data::Array{T,Nsum}  : Initial data of this advection parext  : external data of this advection to compute alpha of each interpolations Implementation adv::Advection{T,N,timeopt}  : link to the constant data of this advection state_coef::Int  : state that is the index of  tab_coef , it is from one to lenth(tab_coef) state_dim::Int  : the dimension index, from 1 to Nsp in space states, from one to Nv in velocity state data::Array{T,Nsum}  : it is the working buffer bufdata::Vector{T}  : vector of the same size of the working buffer fmrtabdata::NTuple{Nsum,Array{T,Nsum}}  : tuple of array with the same size than data but with permutated dimensions t_buf::NTuple{Nsum, Array{T,2}}  : tuple of buffer that is used to get the linear data for interpolation, one buffer per thread cache_alpha::Union{T,Nothing}  : cache for precal, the precal is compute only when the alpha or decint values change cache_decint::Int64  : for precal cache cache_precal::Vector{T}  : for precal cache parext::ExtDataAdv  : external data of this advection to compute alpha of each interpolations Methods to define initcoef!(parext::AbstractExtDataAdv, self::Advection1dData)  : this method called at the beginning of each advection to initialize parext data. The  self.parext  mutable structure is the only data that initcoef! can modify otherwise it leads to unpredictable behaviour. getalpha(parext::AbstractExtDataAdv, self::Advection1dData, ind)  : return the alpha number that is used for interpolation. getperm(parext::AbstractExtDataAdv, advd::Advection1dData)  : get the permutation of the dimension as a function of the current state, the dimension where advection occurs must be first, the dimensions used to compute alpha must be at the end. adv::Advection state_gen::Int64 time_cur::Any data::Array bufdata::Array fmrtabdata::Array{Array{T, N}, 1} where {T, N} t_buf::Array{Array{T}, 1} where T t_itr::Any tt_split::Any t_cache::Array{Array{SemiLagrangian.CachePrecal{T}, 1}, 1} where T parext::SemiLagrangian.AbstractExtDataAdv bufcur::Union{Missing, Array{OpTuple{N, T}, N}} where {T, N} t_bufc::Array{Array{OpTuple{N, T}, N}, 1} where {T, N} initdatas::Union{Missing, Array{Array{T, N}, 1}} where {T, N} source"},{"id":153,"pagetitle":"Advection","title":"SemiLagrangian.StateAdv","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.StateAdv","content":" SemiLagrangian.StateAdv  —  Type struct StateAdv{N} ind::Int64 perm::Vector{Int64} invp::Vector{Int64} ndims::Int64 stcoef::Int64 isconstdec::Bool source"},{"id":154,"pagetitle":"Advection","title":"SemiLagrangian.advection!","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.advection!-Union{Tuple{AdvectionData{T, N, timeopt, timealg}}, Tuple{timealg}, Tuple{timeopt}, Tuple{N}, Tuple{T}} where {T, N, timeopt, timealg}","content":" SemiLagrangian.advection!  —  Method advection!(self)\n Advection function of a multidimensional function  f  discretized on  mesh Argument self::AdvectionData  : mutable structure of variables data Return value true  : means that the advection series must continue false  : means that the advection series is ended. source"},{"id":155,"pagetitle":"Advection","title":"SemiLagrangian.copydata!","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.copydata!-Union{Tuple{timealg}, Tuple{timeopt}, Tuple{N}, Tuple{T}, Tuple{AdvectionData{T, N, timeopt, timealg}, Any}} where {T, N, timeopt, timealg}","content":" SemiLagrangian.copydata!  —  Method copydata!(advd, f)\n source"},{"id":156,"pagetitle":"Advection","title":"SemiLagrangian.decbegin!","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.decbegin!-Union{Tuple{I}, Tuple{Any, Any, Vector{I}}} where I<:AbstractInterpolation","content":" SemiLagrangian.decbegin!  —  Method decbegin!(t_trv, t_cal, t_interp)\n source"},{"id":157,"pagetitle":"Advection","title":"SemiLagrangian.getformdata","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.getformdata-Tuple{AdvectionData}","content":" SemiLagrangian.getformdata  —  Method getformdata(advd)\n source"},{"id":158,"pagetitle":"Advection","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.initcoef!-Union{Tuple{AdvectionData{T, N, timeopt, timealg}}, Tuple{timealg}, Tuple{timeopt}, Tuple{N}, Tuple{T}} where {T, N, timeopt, timealg}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(self)\n source"},{"id":159,"pagetitle":"Advection","title":"SemiLagrangian.nextstate!","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.nextstate!-Tuple{AdvectionData}","content":" SemiLagrangian.nextstate!  —  Method nextstate!(self)\n source"},{"id":160,"pagetitle":"Advection","title":"SemiLagrangian.retns","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.retns-Tuple{AdvectionData, SemiLagrangian.AbstractExtDataAdv}","content":" SemiLagrangian.retns  —  Method retns(self, extdata)\n Function called at the end of advection function to update internal state of AdvectionData structure Argument self::AdvectionData{T, N}  : object to update return value ret::Bool  :  true  if the series must continue                false  at the end of the series. source"},{"id":161,"pagetitle":"Advection","title":"SemiLagrangian.sizeall","ref":"/semi-lagrangian/dev/advection/#SemiLagrangian.sizeall-Tuple{Advection}","content":" SemiLagrangian.sizeall  —  Method sizeall(adv)\n Return a tuple of the sizes of each dimensions Argument adv::Advection  : Advection structure. source"},{"id":164,"pagetitle":"B-spline","title":"B-spline","ref":"/semi-lagrangian/dev/bspline/#B-spline","content":" B-spline"},{"id":165,"pagetitle":"B-spline","title":"SemiLagrangian.BSpline","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.BSpline","content":" SemiLagrangian.BSpline  —  Type abstract type BSpline{T, edge, order} <: AbstractInterpolation{T, edge, order} BSpline{T, edge, order} <: AbstractInterpolation{T, edge, order} Abstract supertype for all bspline interpolation type source"},{"id":166,"pagetitle":"B-spline","title":"SemiLagrangian.BSplineLU","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.BSplineLU","content":" SemiLagrangian.BSplineLU  —  Type struct BSplineLU{T, edge, order} <: SemiLagrangian.BSpline{T, edge, order} BSplineLU{T, edge, order} <: AbstractInterpolation{T, edge, order} Type containing spline coefficients for b-spline interpolation Type parameters T  : the type of data that is interpolate edge::TypeEdge=CircEdge  : true if function is circular order::Int  : order of lagrange interpolation Implementation : ls::LuSpline{T}  : the LU matrix tabfct::Vector{Polynomial{T}}  : function table for interpolation Arguments : n  : size of the matrix order  : the order of interpolation [T::DataType=Float64]  : The type values to interpolate  source"},{"id":167,"pagetitle":"B-spline","title":"SemiLagrangian.LuSpline","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.LuSpline","content":" SemiLagrangian.LuSpline  —  Type struct LuSpline{T} struct LuSpline{T}\nLuSpline(n, t::Vector{T}; iscirc=true, isLU=true) where{T} Structure of a LU decomposition of circular banded matrix, a LU decomposition can be stored in a Matrix which is equal to L + U - I. For a circular Banded matrix all non zero coefficients are in the band and in the last columns and lines Implementation band::Matrix{T} : matrix of size (kl+ku+1, n-kl) ku : size of the band upper the diagonal kl : size of the band lower the diagonal iscirc : true if and only if original matrix is circular isLU : true if LU decomposition has been perform lastcols : only in circular case, Matrix of size (n-ku, kl) that represents teh last columns of matrix lastrows : only in circular case, Matrix of size (n, ku) that represents the last rows of matrix Arguments 'n' : size of the matrix 't::Vector{T}` : vector of all values, the size is order+1, where order is the order of the spline. source"},{"id":168,"pagetitle":"B-spline","title":"SemiLagrangian.decLULu","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.decLULu-NTuple{4, Any}","content":" SemiLagrangian.decLULu  —  Method decLULu(iscirc, band, lastcols, lastrows)\n source"},{"id":169,"pagetitle":"B-spline","title":"SemiLagrangian.sol!","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.sol!-Union{Tuple{I}, Tuple{T}, Tuple{AbstractVector{I}, BSplineLU{T}, AbstractVector{I}}} where {T, I}","content":" SemiLagrangian.sol!  —  Method sol!(X, bsp, Y)\n source"},{"id":170,"pagetitle":"B-spline","title":"SemiLagrangian.sol!","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.sol!-Union{Tuple{I}, Tuple{T}, Tuple{AbstractVector{I}, SemiLagrangian.LuSpline{T}, AbstractVector{I}}} where {T, I}","content":" SemiLagrangian.sol!  —  Method sol!(X, spA, Y)\n source"},{"id":171,"pagetitle":"B-spline","title":"SemiLagrangian.sol","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.sol-Union{Tuple{I}, Tuple{T}, Tuple{BSplineLU{T}, AbstractVector{I}}} where {T<:Number, I}","content":" SemiLagrangian.sol  —  Method sol(bsp, b)\n source"},{"id":172,"pagetitle":"B-spline","title":"SemiLagrangian.sol","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.sol-Union{Tuple{T}, Tuple{SemiLagrangian.LuSpline{T}, AbstractVector}} where T","content":" SemiLagrangian.sol  —  Method sol(spA, b)\n source"},{"id":173,"pagetitle":"B-spline","title":"SemiLagrangian.BSplineFFT","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.BSplineFFT","content":" SemiLagrangian.BSplineFFT  —  Type struct BSplineFFT{T, order} <: SemiLagrangian.BSpline{T, SemiLagrangian.CircEdge, order} BSplineFFT{T, order} <: AbstractInterpolation{T, CircEdge, order}\nBSplineFFT( order::Int, n::Int, T::DataType=Float64) Type containing spline coefficients for b-spline interpolation based on fft, using the fact that b-spline matrix is a circulant matrix Type parameters T  : the type of data that is interpolate order::Int : order of lagrange interpolation Implementation : c_fft::Vector{Complex{T}}  : fft transform of coefficients parfft::PrepareFftBig  : fft precomputed data tabfct::Vector{Polynomial{T}}  : function table for interpolation Arguments : n  : size of the matrix order  : the order of interpolation [T::DataType=Float64]  : The type values to interpolate  source"},{"id":174,"pagetitle":"B-spline","title":"SemiLagrangian.sol!","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.sol!-Union{Tuple{T}, Tuple{AbstractVector{T}, BSplineFFT{T}, AbstractVector{T}}} where T","content":" SemiLagrangian.sol!  —  Method sol!(Y, bsp, b)\n source"},{"id":175,"pagetitle":"B-spline","title":"SemiLagrangian.sol","ref":"/semi-lagrangian/dev/bspline/#SemiLagrangian.sol-Union{Tuple{T}, Tuple{BSplineFFT{T}, AbstractVector{T}}} where T","content":" SemiLagrangian.sol  —  Method sol(bsp, b)\n source"},{"id":178,"pagetitle":"Contents","title":"Index","ref":"/semi-lagrangian/dev/contents/#Index","content":" Index SemiLagrangian.SemiLagrangian SemiLagrangian.AbstractInterpolation SemiLagrangian.Advection SemiLagrangian.AdvectionData SemiLagrangian.BSpline SemiLagrangian.BSplineFFT SemiLagrangian.BSplineLU SemiLagrangian.CachePrecal SemiLagrangian.GeoConst SemiLagrangian.GeoVar SemiLagrangian.Hermite SemiLagrangian.Lagrange SemiLagrangian.LuSpline SemiLagrangian.PoissonConst SemiLagrangian.PoissonVar SemiLagrangian.PrecalHermite SemiLagrangian.PrepareFftBig SemiLagrangian.RotationVar SemiLagrangian.StateAdv SemiLagrangian.TranslationVar SemiLagrangian.UniformMesh SemiLagrangian.ValInv Base.isless Base.length Base.step SemiLagrangian._get_fctv_k SemiLagrangian._getpolylagrange SemiLagrangian._reverse_num SemiLagrangian.advection! SemiLagrangian.autointerp! SemiLagrangian.compute_charge! SemiLagrangian.compute_charge! SemiLagrangian.compute_ee SemiLagrangian.compute_ee SemiLagrangian.compute_elfield SemiLagrangian.compute_elfield! SemiLagrangian.compute_elfield! SemiLagrangian.compute_ke SemiLagrangian.compute_ke SemiLagrangian.copydata! SemiLagrangian.decLULu SemiLagrangian.decbegin! SemiLagrangian.fftbig! SemiLagrangian.get_allprecal SemiLagrangian.get_order SemiLagrangian.getalpha SemiLagrangian.getalpha SemiLagrangian.getalpha SemiLagrangian.getalpha SemiLagrangian.getenergy SemiLagrangian.getenergyall SemiLagrangian.getformdata SemiLagrangian.getgeovar SemiLagrangian.getinverse SemiLagrangian.getpoissonvar SemiLagrangian.getprecal SemiLagrangian.getprecal SemiLagrangian.getprecal SemiLagrangian.getprecal SemiLagrangian.getprecal SemiLagrangian.getrotationvar SemiLagrangian.gettranslationvar SemiLagrangian.hamsplit_3_11 SemiLagrangian.initcoef! SemiLagrangian.initcoef! SemiLagrangian.initcoef! SemiLagrangian.initcoef! SemiLagrangian.initcoef! SemiLagrangian.initcoef! SemiLagrangian.initcoef! SemiLagrangian.initdata! SemiLagrangian.interpbufc! SemiLagrangian.interpolate! SemiLagrangian.interpolate! SemiLagrangian.interpolate! SemiLagrangian.interpolate! SemiLagrangian.interpolate! SemiLagrangian.interpolate! SemiLagrangian.interpolate! SemiLagrangian.interpolatemod! SemiLagrangian.isvelocity SemiLagrangian.magicsplit SemiLagrangian.meshtostd SemiLagrangian.nextstate! SemiLagrangian.nosplit SemiLagrangian.order6split SemiLagrangian.points SemiLagrangian.retns SemiLagrangian.sizeall SemiLagrangian.sol SemiLagrangian.sol SemiLagrangian.sol SemiLagrangian.sol SemiLagrangian.sol SemiLagrangian.sol! SemiLagrangian.sol! SemiLagrangian.sol! SemiLagrangian.standardsplit SemiLagrangian.start SemiLagrangian.stdtomesh SemiLagrangian.stop SemiLagrangian.strangsplit SemiLagrangian.table2split SemiLagrangian.traitmodbegin! SemiLagrangian.traitmodbegin! SemiLagrangian.traitmodend! SemiLagrangian.traitmodend! SemiLagrangian.triplejumpsplit SemiLagrangian.vec_k_fft SemiLagrangian.width"},{"id":181,"pagetitle":"ExtDataAdv","title":"ExtDataAdv","ref":"/semi-lagrangian/dev/extdataadv/#ExtDataAdv","content":" ExtDataAdv The  AbstractExtDataAdv  interface is an interface which allows to define the treatments which will make it possible to obtain the values to be applied to the advections."},{"id":182,"pagetitle":"ExtDataAdv","title":"Functions that needs to be implemented","ref":"/semi-lagrangian/dev/extdataadv/#Functions-that-needs-to-be-implemented","content":" Functions that needs to be implemented"},{"id":183,"pagetitle":"ExtDataAdv","title":"Methods to define","ref":"/semi-lagrangian/dev/extdataadv/#Methods-to-define","content":" Methods to define initcoef!(parext::AbstractExtDataAdv, self::AdvectionData)  : this method called at the beginning of each advection to initialize parext data. The  self.parext  mutable structure is the only data that initcoef! can modify otherwise it leads to unpredictable behaviour. getalpha(parext::AbstractExtDataAdv, self::AdvectionData, ind)  : return the alpha number that is used for interpolation. getperm(parext::AbstractExtDataAdv, advd::AdvectionData)  : get the permutation of the dimension as a function of the current state, the dimension where advection occurs must be first, the dimensions used to compute alpha must be at the end."},{"id":186,"pagetitle":"FFT","title":"FFT","ref":"/semi-lagrangian/dev/fft/#FFT","content":" FFT"},{"id":187,"pagetitle":"FFT","title":"SemiLagrangian.PrepareFftBig","ref":"/semi-lagrangian/dev/fft/#SemiLagrangian.PrepareFftBig","content":" SemiLagrangian.PrepareFftBig  —  Type struct PrepareFftBig{T, NUMDIMS, DIMS} PrepareFftBig( size_fft::Unsigned, [T=BigFloat]) Immutable structure to operate fft transform,  x is the type of non transformed data also called signal. Arguments : size_fft::Integer  : Number of values, must be a power of two [T=BigFloat | x::T ]  : type of the values Implementation size_fft : size of the signal tab_permut : permutation root_one : size order roots of one root one conj : conjugate of root_one struct parameters T : type of Float  NUMDIMS : Numbers of dimensions DIMS : tuple of dimensions source"},{"id":188,"pagetitle":"FFT","title":"SemiLagrangian._reverse_num","ref":"/semi-lagrangian/dev/fft/#SemiLagrangian._reverse_num-Tuple{Any, Any}","content":" SemiLagrangian._reverse_num  —  Method _reverse_num(num, pos)\n function that reverse the order of the pos lowest bits source"},{"id":189,"pagetitle":"FFT","title":"SemiLagrangian.fftbig!","ref":"/semi-lagrangian/dev/fft/#SemiLagrangian.fftbig!-Union{Tuple{DIMS}, Tuple{NUMDIMS}, Tuple{T}, Tuple{SemiLagrangian.PrepareFftBig{T, NUMDIMS, DIMS}, Any}} where {T, NUMDIMS, DIMS}","content":" SemiLagrangian.fftbig!  —  Method fftbig!(par, signal; flag_inv)\n source"},{"id":192,"pagetitle":"Hermite","title":"Hermite","ref":"/semi-lagrangian/dev/hermite/#Hermite","content":" Hermite"},{"id":193,"pagetitle":"Hermite","title":"SemiLagrangian.Hermite","ref":"/semi-lagrangian/dev/hermite/#SemiLagrangian.Hermite","content":" SemiLagrangian.Hermite  —  Type struct Hermite{T, edge, order} <: AbstractInterpolation{T, edge, order} tabfct::Array{Polynomials.Polynomial{T}, 1} where T source"},{"id":194,"pagetitle":"Hermite","title":"SemiLagrangian.PrecalHermite","ref":"/semi-lagrangian/dev/hermite/#SemiLagrangian.PrecalHermite","content":" SemiLagrangian.PrecalHermite  —  Type struct PrecalHermite{ord, d} L::Vector{Polynomials.Polynomial{Rational{BigInt}}} Lprim::Vector{Rational{BigInt}} K::Vector{Polynomials.Polynomial{Rational{BigInt}}} H::Vector{Polynomials.Polynomial{Rational{BigInt}}} bplus::Vector{Rational{BigInt}} bminus::Vector{Rational{BigInt}} rplus::Int64 splus::Int64 rminus::Int64 sminus::Int64 source"},{"id":197,"pagetitle":"Interpolations","title":"Interpolations","ref":"/semi-lagrangian/dev/interpolations/#Interpolations","content":" Interpolations"},{"id":198,"pagetitle":"Interpolations","title":"SemiLagrangian.AbstractInterpolation","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.AbstractInterpolation","content":" SemiLagrangian.AbstractInterpolation  —  Type Abstract supertype for all interpolation type Type parameters T  : type of number on witch interpolation works edge  : type of edge treatment order  : order of interpolation Implementation constraint tabfct::Vector  : this attribut must be on the implementation, it is a table of function of size order+1 source"},{"id":199,"pagetitle":"Interpolations","title":"SemiLagrangian.CachePrecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.CachePrecal","content":" SemiLagrangian.CachePrecal  —  Type mutable struct CachePrecal{T, N, I} source"},{"id":200,"pagetitle":"Interpolations","title":"SemiLagrangian.ValInv","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.ValInv","content":" SemiLagrangian.ValInv  —  Type struct ValInv{T} source"},{"id":201,"pagetitle":"Interpolations","title":"Base.isless","ref":"/semi-lagrangian/dev/interpolations/#Base.isless-Union{Tuple{T}, Tuple{SemiLagrangian.ValInv{T}, SemiLagrangian.ValInv{T}}} where T","content":" Base.isless  —  Method isless(a, b)\n source"},{"id":202,"pagetitle":"Interpolations","title":"SemiLagrangian.autointerp!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.autointerp!-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{Array{OpTuple{N, T}, N}, Array{OpTuple{N, T}, N}, Int64, AbstractVector{I}}} where {N, T, I<:AbstractInterpolation}","content":" SemiLagrangian.autointerp!  —  Method autointerp!(\n    to,\n    from,\n    nb,\n    interp_t;\n    mpid,\n    t_split,\n    cachethreads\n)\n source"},{"id":203,"pagetitle":"Interpolations","title":"SemiLagrangian.get_allprecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.get_allprecal-Union{Tuple{order}, Tuple{T}, Tuple{AbstractInterpolation{T, SemiLagrangian.InsideEdge, order}, Int64, T}} where {T, order}","content":" SemiLagrangian.get_allprecal  —  Method get_allprecal(interp, decint, decfloat)\n source"},{"id":204,"pagetitle":"Interpolations","title":"SemiLagrangian.get_order","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.get_order-Union{Tuple{AbstractInterpolation{T, edge, order}}, Tuple{order}, Tuple{edge}, Tuple{T}} where {T, edge, order}","content":" SemiLagrangian.get_order  —  Method get_order(_)\n Return the order of interpolation implementation        source"},{"id":205,"pagetitle":"Interpolations","title":"SemiLagrangian.getinverse","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.getinverse-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{Array{T, N}, N}}, Vector{I}}} where {T, N, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","content":" SemiLagrangian.getinverse  —  Method getinverse(dec, interp)\n source"},{"id":206,"pagetitle":"Interpolations","title":"SemiLagrangian.getprecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.getprecal-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, N}, Tuple{Vararg{T, N}}}} where {T, N}","content":" SemiLagrangian.getprecal  —  Method getprecal(self, alpha)\n source"},{"id":207,"pagetitle":"Interpolations","title":"SemiLagrangian.getprecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{N}, Tuple{SemiLagrangian.CachePrecal{T, N}, OpTuple{N, T}}} where {N, T<:Real}","content":" SemiLagrangian.getprecal  —  Method getprecal(self, alpha)\n source"},{"id":208,"pagetitle":"Interpolations","title":"SemiLagrangian.getprecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, 1}, Tuple{T}}} where T","content":" SemiLagrangian.getprecal  —  Method getprecal(self, alpha)\n source"},{"id":209,"pagetitle":"Interpolations","title":"SemiLagrangian.getprecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, 1}, T}} where T","content":" SemiLagrangian.getprecal  —  Method getprecal(self, alpha)\n source"},{"id":210,"pagetitle":"Interpolations","title":"SemiLagrangian.getprecal","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, 2}, Complex{T}}} where T<:Real","content":" SemiLagrangian.getprecal  —  Method getprecal(self, alpha)\n source"},{"id":211,"pagetitle":"Interpolations","title":"SemiLagrangian.interpbufc!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpbufc!-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{Array{Array{OpTuple{N, T}, N}, 1}, Array{OpTuple{N, T}, N}, AbstractVector{I}}, Tuple{Array{Array{OpTuple{N, T}, N}, 1}, Array{OpTuple{N, T}, N}, AbstractVector{I}, Int64}} where {N, T, I<:(AbstractInterpolation{T})}","content":" SemiLagrangian.interpbufc!  —  Method interpbufc!(t_buf, bufdec, interp_t)\ninterpbufc!(\n    t_buf,\n    bufdec,\n    interp_t,\n    nb;\n    mpid,\n    t_split,\n    cachethreads\n)\n source"},{"id":212,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{Vararg{Int64, N}}, Array{T, N}, Vector{I}}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{Vararg{Int64, N}}, Array{T, N}, Vector{I}, Any}} where {T, N, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(fp, fi, decint, precal, interp)\ninterpolate!(fp, fi, decint, precal, interp, tabmod)\n source"},{"id":213,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}, Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}, Union{AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}, AbstractVector{I}}} where {T, N, I<:(AbstractInterpolation{T})}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(\n    fp,\n    fi,\n    bufdec,\n    interp_t;\n    tabmod,\n    mpid,\n    t_split,\n    cachethreads\n)\n source"},{"id":214,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}}, Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}}, Function, AbstractVector{I}}} where {T, N, I<:(AbstractInterpolation{T})}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(fp, fi, dec, interp_t; tabmod, cache)\n source"},{"id":215,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, Vector{I}}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, Vector{I}, Any}} where {T, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(fp, fi, decint, precal, tinterp)\ninterpolate!(fp, fi, decint, precal, tinterp, tabmod)\n source"},{"id":216,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{order}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Array{Vector{T}, 1}, AbstractInterpolation{T, SemiLagrangian.InsideEdge, order}}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Array{Vector{T}, 1}, AbstractInterpolation{T, SemiLagrangian.InsideEdge, order}, Any}} where {T, order}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(fp, fi, decint, allprecal, interp)\ninterpolate!(fp, fi, decint, allprecal, interp, tabmod)\n apply an offset to the function fi interpolate by interp struct, the result is in fp vector, decint and precal are precompute with getprecal method, the TypeEdge is InsideEdge, it is a marginal case Arguments fp::AbstractVector  : output vector fi::AbstractVector  : input vector decint  : offset in units of dx allprecal::Vector{Vector{T}}  : vector of vector of length order+1 precompute with getprecal(interp, dec) (dec is the offset) interp::AbstractInterpolation{T, InsideEdge, order}  : interpolation implementation, note that TypeEdge is CircEdge tabmod=gettabmod(length(fi))  : precompute for \"begin at one\" modulo Returns : No return source"},{"id":217,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{order}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, AbstractInterpolation{T, SemiLagrangian.CircEdge, order}}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, AbstractInterpolation{T, SemiLagrangian.CircEdge, order}, Any}} where {T, order}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(fp, fi, decint, precal, interp)\ninterpolate!(fp, fi, decint, precal, interp, tabmod)\n apply an offset to the function fi interpolate by interp struct, the result is in fp vector, decint and precal are precompute with getprecal method, the TypeEdge is CircEdge Arguments fp::AbstractVector  : output vector fi::AbstractVector  : input vector decint  : offset in units of dx precal::Vector  : vector of length order+1 precompute with getprecal(interp, dec) (dec is the offset) interp::AbstractInterpolation{T, CircEdge, order}  : interpolation implementation, note that TypeEdge is CircEdge tabmod=gettabmod(length(fi))  : precompute for \"begin at one\" modulo Returns : No return source"},{"id":218,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolate!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolate!-Union{Tuple{order}, Tuple{edge}, Tuple{T}, Tuple{Any, Any, Any, AbstractInterpolation{T, edge, order}}} where {T, edge, order}","content":" SemiLagrangian.interpolate!  —  Method interpolate!(fp, fi, dec, interp)\n apply the offset dec to the function fi interpolate by interp struct, the result is in fp Vector Arguments fp  : output vector of length n fi  : input vector of length n dec  : offset in units of dx interp::AbstractInterpolation  : interpolation implementation Returns : No return source"},{"id":219,"pagetitle":"Interpolations","title":"SemiLagrangian.interpolatemod!","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.interpolatemod!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{Array{T, N}, Array{T, N}}, AbstractVector{I}, Union{UniformMesh{T}, T}}} where {T, N, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","content":" SemiLagrangian.interpolatemod!  —  Method interpolatemod!(fp, fi, bufc, interp_t, lgmesh)\n source"},{"id":220,"pagetitle":"Interpolations","title":"SemiLagrangian.sol","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.sol-Tuple{AbstractInterpolation, AbstractArray}","content":" SemiLagrangian.sol  —  Method sol(_, b)\n Interface method to transform the treated line, by default this method does nothing Arguments : _::AbstractInterpolation  : interpolation implementation line::AbstractVector  : line to transform Return : The transformed line source"},{"id":221,"pagetitle":"Interpolations","title":"SemiLagrangian.sol","ref":"/semi-lagrangian/dev/interpolations/#SemiLagrangian.sol-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{I}, Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}}} where {T<:Real, N, I<:(AbstractInterpolation{T})}","content":" SemiLagrangian.sol  —  Method sol(interp_t, b)\n source"},{"id":224,"pagetitle":"Lagrange interpolation","title":"Lagrange interpolation","ref":"/semi-lagrangian/dev/lagrange/#Lagrange-interpolation","content":" Lagrange interpolation To compute a Lagrange interpolation you have to instantiate a  Lagrange  type variable:"},{"id":225,"pagetitle":"Lagrange interpolation","title":"SemiLagrangian.Lagrange","ref":"/semi-lagrangian/dev/lagrange/#SemiLagrangian.Lagrange","content":" SemiLagrangian.Lagrange  —  Type struct Lagrange{T, edge, order} <: AbstractInterpolation{T, edge, order} Type containing Lagrange Polynomials coefficients for Lagrange interpolation Type parameters T  : the type of data that is interpolate edge::EdgeType  : type of edge traitment order::Int : order of lagrange interpolation Implementation : tabfct::Vector{Polynomial{T}}  : vector of all lagrange polynomial, per example the k-th Lagrange polynomial for the designed order is tabfct[k+1] Arguments : order::Int  : the order of interpolation [T::DataType=Float64]  : The type values to interpolate  Keywords arguments : edge::EdgeType=CircEdge  : type of edge traitment source"},{"id":226,"pagetitle":"Lagrange interpolation","title":"SemiLagrangian._getpolylagrange","ref":"/semi-lagrangian/dev/lagrange/#SemiLagrangian._getpolylagrange-Tuple{Int64, Int64, Int64}","content":" SemiLagrangian._getpolylagrange  —  Method _getpolylagrange(k, order, origin)\n Function that return the k-th Lagrange Polynomial of a certain order.  If coefficients are rational then the return is exact. The polynomial is equal to : $\\prod_{i=0,\\ i \\neq k}^{order} \\frac{x - i - origin}{k - i}$ Arguments k::Int64  : number of the Polynomial,  k  must be between  0  and  order  ( 0<= k <= order ). order::Int64  : order of the polynomial. origin::Int64  : origin of the first indice. Returns Polynomial{Rational{BigInt}}  : the k-th Lagrange polynomial of order  order Throws DommaineError  : when  0 <= k <= order  is  false source"},{"id":229,"pagetitle":"Meshes","title":"Meshes","ref":"/semi-lagrangian/dev/meshes/#Meshes","content":" Meshes"},{"id":230,"pagetitle":"Meshes","title":"SemiLagrangian.UniformMesh","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.UniformMesh","content":" SemiLagrangian.UniformMesh  —  Type struct UniformMesh{T} UniformMesh{T}\nUniformMesh(start::T, stop::T, length::Int) where {T} 1D uniform mesh data. Arguments start::T  : beginning of the mesh stop::T  : end of the mesh length::Int  : number of cells of the mesh Implementation step::T   : size step points::Vector{T} : Array with node positions width::T  : Distance between left and right edges. source"},{"id":231,"pagetitle":"Meshes","title":"Base.length","ref":"/semi-lagrangian/dev/meshes/#Base.length-Tuple{UniformMesh}","content":" Base.length  —  Method length(mesh)\n Base.length(mesh::UniformMesh) Get the length of the mesh Argument mesh::UniformMesh  : the mesh Return length  : the length of the mesh that is the number of points and cells source"},{"id":232,"pagetitle":"Meshes","title":"Base.step","ref":"/semi-lagrangian/dev/meshes/#Base.step-Tuple{UniformMesh}","content":" Base.step  —  Method step(mesh)\n Base.step(mesh::UniformMesh) Get the step of the mesh Argument mesh::UniformMesh  : the mesh Return step  : the step of the mesh that is the difference between two contiguous points source"},{"id":233,"pagetitle":"Meshes","title":"SemiLagrangian.meshtostd","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.meshtostd-Union{Tuple{T}, Tuple{UniformMesh{T}, Any}} where T","content":" SemiLagrangian.meshtostd  —  Method meshtostd(mesh, v)\n source"},{"id":234,"pagetitle":"Meshes","title":"SemiLagrangian.points","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.points-Tuple{UniformMesh}","content":" SemiLagrangian.points  —  Method points(mesh::UniformMesh) Get the points of the mesh Argument mesh::UniformMesh  : the mesh Return points  : the points of the mesh that is the vector of all points of the mesh except the last source"},{"id":235,"pagetitle":"Meshes","title":"SemiLagrangian.start","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.start-Tuple{UniformMesh}","content":" SemiLagrangian.start  —  Method start(mesh)\n source"},{"id":236,"pagetitle":"Meshes","title":"SemiLagrangian.stdtomesh","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.stdtomesh-Union{Tuple{T}, Tuple{UniformMesh{T}, Any}} where T","content":" SemiLagrangian.stdtomesh  —  Method stdtomesh(mesh, v)\n source"},{"id":237,"pagetitle":"Meshes","title":"SemiLagrangian.stop","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.stop-Tuple{UniformMesh}","content":" SemiLagrangian.stop  —  Method stop(mesh)\n source"},{"id":238,"pagetitle":"Meshes","title":"SemiLagrangian.traitmodbegin!","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.traitmodbegin!-Union{Tuple{N}, Tuple{T}, Tuple{UniformMesh{T}, Array{T, N}}} where {T, N}","content":" SemiLagrangian.traitmodbegin!  —  Method traitmodbegin!(mesh, f)\n source"},{"id":239,"pagetitle":"Meshes","title":"SemiLagrangian.traitmodbegin!","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.traitmodbegin!-Union{Tuple{T2}, Tuple{N}, Tuple{T2, Array{T2, N}}} where {N, T2<:Union{Number, OpTuple{N, <:Number}}}","content":" SemiLagrangian.traitmodbegin!  —  Method traitmodbegin!(lg, f)\n source"},{"id":240,"pagetitle":"Meshes","title":"SemiLagrangian.traitmodend!","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.traitmodend!-Union{Tuple{N}, Tuple{T}, Tuple{UniformMesh{T}, Array{T, N}}} where {T, N}","content":" SemiLagrangian.traitmodend!  —  Method traitmodend!(mesh, res)\n source"},{"id":241,"pagetitle":"Meshes","title":"SemiLagrangian.traitmodend!","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.traitmodend!-Union{Tuple{T2}, Tuple{N}, Tuple{T2, Array{T2, N}}} where {N, T2<:Union{Number, OpTuple{N, <:Number}}}","content":" SemiLagrangian.traitmodend!  —  Method traitmodend!(lg, f)\n source"},{"id":242,"pagetitle":"Meshes","title":"SemiLagrangian.vec_k_fft","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.vec_k_fft-Union{Tuple{UniformMesh{T}}, Tuple{T}} where T","content":" SemiLagrangian.vec_k_fft  —  Method vec_k_fft(mesh::UniformMesh{T}) where{T} Get the fft coefficients of the mesh Argument mesh::UniformMesh{T}  : the mesh Return fft coefficients source"},{"id":243,"pagetitle":"Meshes","title":"SemiLagrangian.width","ref":"/semi-lagrangian/dev/meshes/#SemiLagrangian.width-Tuple{UniformMesh}","content":" SemiLagrangian.width  —  Method width(mesh::UniformMesh) Get the width of the mesh Argument mesh::UniformMesh  : the mesh Return width  : the width that is step*length or distance between left and right edges. source"},{"id":246,"pagetitle":"Two dimensions","title":"Two-dimensional problems","ref":"/semi-lagrangian/dev/modele_2d/#Two-dimensional-problems","content":" Two-dimensional problems In this document, we detail some aspects of the  $2$ -dimensional semi-Lagrangian method and give some examples to validate the implementation."},{"id":247,"pagetitle":"Two dimensions","title":"General context","ref":"/semi-lagrangian/dev/modele_2d/#General-context","content":" General context We consider  $2D$  transport equation of the form  \\[\\tag{1}\n\\partial_t f + u_x \\partial_x f + u_y \\partial_y f = 0, f(t=0, x, y)= f_0(x, y), x, y\\in \\Omega\\subset \\mathbb{R}^2,\\] where the advection field  $(u_x, u_y)(t, x, y)$  satisfies the incompressibility condition  $\\partial_x u_x + \\partial_y u_y=0$  which implies (1) can be reformulated as \\[\\partial_t f + \\partial_x( u_x  f )+ \\partial_y(u_y  f) = 0, f(t=0, x, y)= f_0(x, y),\\] from which we deduce the mass conservation  $\\int\\!\\!\\int f(t, x, y) dxdy = \\int\\!\\!\\int f_0(x, y) dxdy$ . To solve numerically (1), we will use a  $2D$  semi-Lagrangian method which is based on the fact that the solution  $f$  is constant along the characteristics  $X(t)=(x(t), y(t))$  defined by \\[\\dot{X}(t) = U(t, X(t)), \\;\\; X(s) = X_g,\\] with  $U(t, X):=U(t, x, y)=(u_x(t, x, y), u_y(t, x, y))$ ,  $s$  is a time and  $X_g$  is a prescribed condition (which will be a grid point). Hence, we can write  $f(s, X(s))=f(t, X(t))$  for all  $t, s$ . Considering a discretization of the time  $t^n=n\\Delta t$  with  $n\\in \\mathbb{N}$  and  $\\Delta t>0$  the time step, we rewrite the latter equality with  $s=t^{n+1}$  and  $t=t^n$  to get  \\[f(t^{n+1}, X_g) = f(t^n, X(t^n)).\\] We want to compute the left hand side which corresponds to the numerical solution at time  $t^{n+1}$  and at the grid point  $X_g$ . To do so, we assume (by induction) that the solution is known at time  $t^n$  and at the grid points  $X_g$ , thus, we have to interpolate (in  $2D$ ) to compute  $f(t^n, X(t^n))$ . The semi-Lagrangian methods can be split into two steps compute  $X(t^n)$ compute  $f(t^n, X(t^n))$ : from the known values  $f(t^n, X_g)$ , interpolate at  $X(t^n)$ . These two steps are details in the next section."},{"id":248,"pagetitle":"Two dimensions","title":"Details on the  $2D$  semi-Lagrangian method","ref":"/semi-lagrangian/dev/modele_2d/#Details-on-the-2D-semi-Lagrangian-method","content":" Details on the  $2D$  semi-Lagrangian method The two steps of the semi-Lagrangian are detailed and some examples are given."},{"id":249,"pagetitle":"Two dimensions","title":"ODE solver","ref":"/semi-lagrangian/dev/modele_2d/#ODE-solver","content":" ODE solver First, we need to compute  $X(t^n)$  which the solution at time  $t^n$  of \\[\\tag{2}\n\\dot{X}(t) = U(t, X(t)), \\;\\; X(t^{n+1}) = X_g.\\] When  $U$  is simple enough,  $X(t^n)$  can be computed analytically but in general, we need a solver of this differential equation. The main difficulty comes from the fact that (2) has to be solved backward in time and when the time dependency of  $U$  is nonlinearly coupled to the solution  $f$  itself (see Examples 3 and 4 below), we do not know  $U(t, \\dot)$  for  $t>t^n$  (and time extrapolation has to be used  [filbet] )."},{"id":250,"pagetitle":"Two dimensions","title":"First order","ref":"/semi-lagrangian/dev/modele_2d/#First-order","content":" First order A simple scheme to compute  $X(t^n)$  is the Euler scheme applied to (2) \\[\\frac{X(t^{n+1}) - X(t^n)}{\\Delta t} = U(t^n, X(t^{n+1})),\\] and using the condition  $X(t^{n+1}) = X_g$ , we get the following first order approximation for  $X(t^n)$ \\[X(t^n) = X_g - \\Delta t U(t^n, X_g).\\]"},{"id":251,"pagetitle":"Two dimensions","title":"Second order","ref":"/semi-lagrangian/dev/modele_2d/#Second-order","content":" Second order A mid-point scheme (which is second order accurate) can be used to solve (2): \\[\\frac{X(t^{n+1}) - X(t^n)}{\\Delta t} = U\\Big(t^{n+1/2}, \\frac{X(t^{n+1}) + X(t^n)}{2}\\Big),\\] which gives an implicit expression for  $X(t^n)$ \\[\\begin{equation}\n\\label{ode_2nd_imp}\nX(t^n) = X(t^{n+1}) -\\Delta t \\, U\\Big(t^{n+1/2}, \\frac{X(t^{n+1}) + X(t^n)}{2}\\Big).\n\\end{equation}\\] As mentioned above, we first need to extrapolate  $U(t^{n+1/2}, \\cdot)$ . To do so, we use  $U(t^{n-1}, \\cdot)$  and  $U(t^{n}, \\cdot)$  and we construct a first order Lagrange polynomial  ${\\cal L}(t), t\\in[t^{n-1}, t^n]$ \\[{\\cal L}(t) = U(t^n, \\cdot) \\frac{t^{n-1}-t}{\\Delta t} + U(t^{n-1}, \\cdot) \\frac{t - t^{n}}{\\Delta t}.\\] We then approximate  $U(t^{n+1/2}, \\cdot)$  by  ${\\cal L}(t^{n+1/2})$ . We then have to solve \\eqref{ode 2nd imp} using a fixed point \\[X^{n, k+1} = X_g -\\Delta t \\, {\\cal L}\\Big(t^{n+1/2}, \\frac{X_g + X^{n,k}}{2}\\Big), \\;\\; \\mbox{ for } k\\geq 0, X^{n, 0}=X_g,\\] up to convergence."},{"id":252,"pagetitle":"Two dimensions","title":"Extension to higher order","ref":"/semi-lagrangian/dev/modele_2d/#Extension-to-higher-order","content":" Extension to higher order We can look at the schemes proposed in  [filbet]  but we can also use the package  DifferentialEquations.jl"},{"id":253,"pagetitle":"Two dimensions","title":"$2D$  Interpolation","ref":"/semi-lagrangian/dev/modele_2d/#2D-Interpolation","content":" $2D$  Interpolation Once  $X(t^n)$  has been computed using the techniques detailed before, one has to compute  $f(t^n, X(t^n))$ . Since the grid values  $f(t^n, X_g)$  are known, we can reconstruct a piecewise  $2D$  polynomial function  ${\\cal P}(x, y), x, y\\in \\Omega$  using Lagrange or splines such that  $f(t^n, X_g) = {\\cal P}(X_g)$ , and then we approximate  $f(t^n, X(t^n)) \\approx {\\cal P}(X(t^n)).$  We consider a cartesian grid of  $N_x\\times N_y$  points  $x_i = (i-1)\\Delta x$  and  $y_j =(j-1)\\Delta y$  for  $i=1, \\dots, N_x$  and  $j=1, \\dots, N_y$ . We assume periodicity in  $x$  and  $y$  which means  $f(x_{N_x+1}, y) = f(x_1, y)$  and  $f(x, y_{N_y+1}) = f(x, y_1)$ ."},{"id":254,"pagetitle":"Two dimensions","title":"Lagrange interpolation","ref":"/semi-lagrangian/dev/modele_2d/#Lagrange-interpolation","content":" Lagrange interpolation A tensor product can be done. If we denote  $L_{x,i}$  and  $L_{y,j}$  the Lagrange polynomial of degree  $2d+1$  in the  $x$  and  $y$  direction  $L_{x,i}(x) = \\Pi_{k=i-d, k\\neq i}^{i+d} \\frac{(x-x_k)}{(x_i-x_k)}$  and  $L_{y,j}(x) = \\Pi_{k=j-d, k\\neq j}^{j+d} \\frac{(y-y_k)}{(y_j-y_k)}$ . Then, we have \\[f(x,y) \\approx {\\cal P}(x,y) =\\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} f(x_i,y_j) L_{x,i}(x)L_{y,j}(y).\\]"},{"id":255,"pagetitle":"Two dimensions","title":"Splines interpolation","ref":"/semi-lagrangian/dev/modele_2d/#Splines-interpolation","content":" Splines interpolation For cubic splines, one can use splinePP  which I try to explain below. We introduce the tridiagonal matrix  $A\\in {\\cal M}_{Nx+1, N_x+1}$  with  $4$  on the diagonal and  $1$  on the two extradiagonals. We consider  $f(x_i, y_j)$  for  $i=1, \\dots, N_x$  and  $j=1, \\dots, N_y$  and we denote  $F\\in {\\cal M}_{N_x+1, N_y}$  the matrix such that  $F_{i,j} = f(x_i,y_j)$  for  $i=1, \\dots, N_x$  and  $j=1, \\dots, N_y$  and  $F_{N_x+1, j}= f(x_1, y_j)$  for periodicity. We compute the splines coefficients as solve  $A \\eta_j = 6 f(:,y_j), \\;\\; \\forall j=1, \\dots, N_y$  with  $\\eta_j\\in \\mathbb{R}^{N_x+1}$ gestion du bord (Pierre ?) pour obtenir  $\\eta(1:Nx+3, 1:N_y+1)$ solve  $A \\,{\\tt coef}_i \\, = 6 \\eta(i,:), \\;\\; \\forall i=1, \\cdots, N_x+3 $ with ${\\tt coef}_i\\in \\mathbb{R}^{N_y+1}$ gestion du bord (Pierre ?) pour obtenir coef $(1:Nx+3, 1:N_y+3)$ \\[f(x,y) \\approx {\\cal S}(x,y) = \\sum_i\\sum_j {\\tt coef}_{i,j} B_i(x) B_j(y)\\]"},{"id":256,"pagetitle":"Two dimensions","title":"Some examples","ref":"/semi-lagrangian/dev/modele_2d/#Some-examples","content":" Some examples In this part, some examples of increasing difficulty are proposed to validate our algorithms."},{"id":257,"pagetitle":"Two dimensions","title":"Example 1 : rotation","ref":"/semi-lagrangian/dev/modele_2d/#Example-1-:-rotation","content":" Example 1 : rotation \\[\\partial_t f + y \\partial_x f - x \\partial_y f = 0, f(t=0, x, y)= f_0(x, y).\\] We already discussed this test and we have to check it again. In this case, the characteristics can be solved exactly in time since  $X(t^n) = e^{-J \\Delta t}X_g$  with  $J$  the symplectic matrix. This test will enable us to validate the  $2D$  interpolation step. Here \\[J=\\Big(\n\\begin{matrix}\n0 & 1 \\\\\n-1 & 0\n\\end{matrix}\n\\Big) \n\\mbox{ and } \ne^{-J \\Delta t}=\\Big(\n\\begin{matrix}\n\\cos \\Delta t & -\\sin\\Delta t \\\\\n\\sin\\Delta t & \\cos\\Delta t\n\\end{matrix}\n\\Big).\\]"},{"id":258,"pagetitle":"Two dimensions","title":"Example 2 : swirling deformation flow","ref":"/semi-lagrangian/dev/modele_2d/#Example-2-:-swirling-deformation-flow","content":" Example 2 : swirling deformation flow \\[\\begin{aligned}\n\\partial_t f + \\Big( \\sin^2(\\pi x) \\sin(2\\pi y) g(t)\\Big) \\partial_x f - \\Big(\\sin^2(\\pi y)\\sin(2\\pi x) g(t)  \\Big) \\partial_y f = 0, \\\\\nf(t=0, x, y)= f_0(x, y)\n\\end{aligned}\\] with  $g(t)=\\cos(\\pi t/T)$ . The solution slows down and reverses direction in such a way that the initial condition should be recovered at time  $T$ :  $f(T, x, y)=f_0(x,y)$ . This gives a very useful test to validate our methods since we know the exact solution at time  $T$ . For the initial condition, we consider  \\[\\begin{equation}\nf_0(x, y) = \n\\left\\{ \n\\begin{array}{cc}\n1, & \\mbox{ if } (x-1)^2+(y-1)^2 <0.8\\\\\n0, & \\mbox{ otherwise}.\n\\end{array}\n\\right.\n\\end{equation}\\] We can choose  $T=1.5$  and the spatial domain is  $[0, 1]^2$ . Some results are given in  [leveque]  or  [qiu] ."},{"id":259,"pagetitle":"Two dimensions","title":"Example 3: Vlasov-Poisson","ref":"/semi-lagrangian/dev/modele_2d/#Example-3:-Vlasov-Poisson","content":" Example 3: Vlasov-Poisson \\[\\partial_t f + y \\partial_x f +E \\partial_y f = 0, f(t=0, x, y)= f_0(x, y), x\\in [0, 4\\pi], y\\in \\mathbb{R},\\] where the electric field  $E$  derives from a potential  $\\phi(t, x)\\in\\mathbb{R}$  which satisfies a Poisson equation \\[\\partial_x^2 \\phi = \\int_{\\mathbb{R}} f dy - 1.\\] The initial condition is \\[f_0(x, y)= \\frac{1}{\\sqrt{2}\\pi}e^{-y^2/2}(1 + 0.001\\cos(x/2)).\\] For this problem, we define the electric energy  ${\\cal E}_e = \\int E^2dx$  and the kinetic energy  ${\\cal E}_k := \\int\\!\\int y^2 f dx dy$  so that the total energy  ${\\cal E}_e+{\\cal E}_k$  is preserved with time. We can also consider the time evolution of  ${\\cal E}_e$  for which we know the behavior."},{"id":260,"pagetitle":"Two dimensions","title":"Example 4: Guiding-center","ref":"/semi-lagrangian/dev/modele_2d/#Example-4:-Guiding-center","content":" Example 4: Guiding-center \\[\\partial_t f + E_x \\partial_x f +E_y \\partial_y f = 0, f(t=0, x, y)= f_0(x, y)\\] where the electric field  $E=(E_x, E_y)(t, x, y)$  derives from a potential  $\\phi(t, x, y)\\in\\mathbb{R}$  which satisfies a Poisson equation  \\[\\Delta \\phi = f.\\] The spatial domain is  $[0, 4\\pi]\\times [0, 2\\pi]$  and the initial condition is \\[f_0(x, y)= \\sin(y) + 0.015\\cos(x/2).\\] For this problem, the electric energy  ${\\cal E}_e :=\\int\\!\\int (E_x^2+E_y^2)dxdy$  and the enstrophy  ${\\cal E}_f:=\\int\\!\\int f^2 dx dy$  are preserved with time. Some results are given in  [qiu]  or  [crouseilles] ."},{"id":261,"pagetitle":"Two dimensions","title":"References","ref":"/semi-lagrangian/dev/modele_2d/#References","content":" References filbet F. Filbet, C. Prouveur,  High order time discretization for backward semi-Lagrangian methods , Journal of Computational and Applied Mathematics, vol 303, (2016) pp. 171-188. leveque R. LeVeque,  High-resolution conservative algorithms for advection in incompressible flow , SIAM Journal on Numerical Analysis, (1996), pp.  627-665.   https://www.jstor.org/stable/2158391?seq=29#metadata_info_tab_contents qiu J. Qiu, C.-W. Shu,  Conservative high order semi-Lagrangian finite difference WENO methods for advection in incompressible flow , Journal of Computational Physics, Volume 230, Issue 4, 20 (2011), pp. 863-889. crouseilles N. Crouseilles, M. Mehrenberger, E. Sonnendrücker  Conservative semi-Lagrangian methods for the Vlasov equations , J. Comput. Phys., 229, pp 1927-1953, (2010)."},{"id":264,"pagetitle":"Poisson solver","title":"Poisson solver","ref":"/semi-lagrangian/dev/poisson/#Poisson-solver","content":" Poisson solver"},{"id":265,"pagetitle":"Poisson solver","title":"SemiLagrangian.PoissonConst","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.PoissonConst","content":" SemiLagrangian.PoissonConst  —  Type struct PoissonConst{T, N, Nsp, Nv, type, typeadd} PoissonConst{T, Nsp, Nv}\nPoissonConst(adv::Advection{T, Nsp, Nv, Nsum}; isfftbig=true) Constant data for the computation of poisson coefficients Arguments adv::Advection{T, Nsp, Nv, Nsum, timeopt}  : Advection constant data isfftbig=true : if true compute the fttbig structure Implementation adv  : Advection constant data `v_k' : vector of vector of fourier coefficents for integration for each space dimension fctv_k  : Array of space dimensions of the inverse of the norm of fourier coefficients pfftbig  : Fourier data for space dimensions source"},{"id":266,"pagetitle":"Poisson solver","title":"SemiLagrangian.PoissonVar","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.PoissonVar","content":" SemiLagrangian.PoissonVar  —  Type mutable struct PoissonVar{T, N, Nsp, Nv, type, typeadd} <: SemiLagrangian.AbstractExtDataAdv PoissonVar{T, N, Nsp, Nv} <: AbstractExtDataAdv{T}\nPoissonVar(pc::PoissonConst{T, N, Nsp, Nv}) mutable structure of variable data for the poisson computation Arguments pc::PoissonConst{T, N, Nsp, Nv}  : poisson constant data Implementation pc::PoissonConst{T, Nsp, Nv}  : poisson constant data rho::Array{T, Nsp}  : result of the compute_charge that is the sum along velocity dimensions t_elfield::NTuple{Nsp,Array{Complex{T}, Nsp}}  : electric fields initialized at each beginning of velocity advection subseries source"},{"id":267,"pagetitle":"Poisson solver","title":"SemiLagrangian._get_fctv_k","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian._get_fctv_k-Union{Tuple{Advection{T, N, timeopt}}, Tuple{timeopt}, Tuple{N}, Tuple{T}} where {T, N, timeopt}","content":" SemiLagrangian._get_fctv_k  —  Method _get_fctv_k(adv)\n source"},{"id":268,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_charge!","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_charge!-Union{Tuple{Nsum}, Tuple{Nv}, Tuple{Nsp}, Tuple{T}, Tuple{Array{T, Nsp}, Tuple{Vararg{UniformMesh{T}, Nv}}, Array{T, Nsum}}} where {T, Nsp, Nv, Nsum}","content":" SemiLagrangian.compute_charge!  —  Method compute_charge!(rho, t_mesh_v, f)\n compute_charge!(rho, mesh_v, f) Compute charge density from phase space distribution  f . ρ(x,t) = ∫ f(x,v,t) dv Arguments rho::Array{T,Nsp} : output result density array. t_mesh_v::NTuple{Nv,UniformMesh{T}} : velocity mesh. f::Array{T,Nsum} : distribution function array. source"},{"id":269,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_charge!","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_charge!-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv}, AdvectionData}} where {T, N, Nsp, Nv}","content":" SemiLagrangian.compute_charge!  —  Method compute_charge!(self, advd)\n compute_charge!( self::PoissonVar, advd::AdvectionData) Compute charge density ρ(x,t) = ∫ f(x,v,t) dv Argument self::AdvectionData  : mutable structure of variables data. source"},{"id":270,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_ee","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_ee-Tuple{AdvectionData}","content":" SemiLagrangian.compute_ee  —  Method compute_ee(self)\n compute_ee(self::AdvectionData) Compute electric energy || E(t,.) ||_L2 Argument self::AdvectionData : advection data structure. source"},{"id":271,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_ee","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_ee-Union{Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{UniformMesh{T}, N}}, Tuple{Vararg{Array{T, N}, N}}}} where {T, N}","content":" SemiLagrangian.compute_ee  —  Method compute_ee(t_mesh_sp, t_elf)\n compute_ee(t_mesh_sp, t_elf) Compute electric energy || E(t,.) ||_L2 Arguments t_mesh_sp::NTuple{N,UniformMesh{T}} : space mesh. t_elf::NTuple{N,Array{T,N}} : electric field. source"},{"id":272,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_elfield!","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_elfield!-Union{Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv}}, Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}} where {T, N, Nsp, Nv}","content":" SemiLagrangian.compute_elfield!  —  Method compute_elfield!(self)\n compute_elfield!( self:PoissonVar) computation of electric field     ∇.e = - ρ Argument self::PoissonVar  : mutable structure of variables data. source"},{"id":273,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_elfield!","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_elfield!-Union{Tuple{T}, Tuple{Vector{T}, UniformMesh{T}, Vector{T}}} where T","content":" SemiLagrangian.compute_elfield!  —  Method compute_elfield!(elf, mesh, rho)\n compute_elfield!(elf::Array{T,1}, mesh::UniformMesh{T}, rho::Array{T,1}) where{T} Computation of electric field of one dimension.     ∇.e = - ρ Argument elf::Array{T,1} : output Vector. mesh::UniformMesh{T}  : mesh of the vector rho::Array{T,1}  : rho computed before source"},{"id":274,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_elfield","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_elfield-Union{Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{UniformMesh{T}, N}}, Array{T, N}, Any}} where {T<:AbstractFloat, N}","content":" SemiLagrangian.compute_elfield  —  Method compute_elfield(t_mesh_x, rho, pfft)\n source"},{"id":275,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_ke","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_ke-Union{Tuple{AdvectionData{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","content":" SemiLagrangian.compute_ke  —  Method compute_ke(self)\n compute_ke(self::AdvectionData) Compute kinetic Energy. ∫∫ v^2 f(x,v,t) dv dx Arguments self::AdvectionData : mutable structure of variables data. source"},{"id":276,"pagetitle":"Poisson solver","title":"SemiLagrangian.compute_ke","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.compute_ke-Union{Tuple{Nsum}, Tuple{Nv}, Tuple{Nsp}, Tuple{T}, Tuple{Tuple{Vararg{UniformMesh{T}, Nsp}}, Tuple{Vararg{UniformMesh{T}, Nv}}, Array{T, Nsum}}} where {T, Nsp, Nv, Nsum}","content":" SemiLagrangian.compute_ke  —  Method compute_ke(t_mesh_sp, t_mesh_v, f)\n compute_ke(t_mesh_sp, t_mesh_v, f) Compute kinetic Energy from phase space distribution  f . ∫∫ v^2 f(x,v,t) dv dx Arguments t_mesh_sp::NTuple{Nsp, UniformMesh{T}} : space mesh. t_mesh_v::NTuple{Nv, UniformMesh{T}} : velocity mesh. f::Array{T,Nsum} : distribution function array. source"},{"id":277,"pagetitle":"Poisson solver","title":"SemiLagrangian.getalpha","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.getalpha-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv, StdPoisson}, AdvectionData{T}, Any}} where {T, N, Nsp, Nv}","content":" SemiLagrangian.getalpha  —  Method getalpha(pv, advd, ind)\n source"},{"id":278,"pagetitle":"Poisson solver","title":"SemiLagrangian.getenergy","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.getenergy-Tuple{AdvectionData}","content":" SemiLagrangian.getenergy  —  Method getenergy(advd)\n source"},{"id":279,"pagetitle":"Poisson solver","title":"SemiLagrangian.getenergyall","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.getenergyall-Tuple{AdvectionData}","content":" SemiLagrangian.getenergyall  —  Method getenergyall(advd)\n source"},{"id":280,"pagetitle":"Poisson solver","title":"SemiLagrangian.getpoissonvar","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.getpoissonvar-Tuple{Advection}","content":" SemiLagrangian.getpoissonvar  —  Method getpoissonvar(adv; type, typeadd)\n source"},{"id":281,"pagetitle":"Poisson solver","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.initcoef!-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv, StdPoisson}, AdvectionData{T, N}}} where {T, N, Nsp, Nv}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(pv, advd)\n source"},{"id":282,"pagetitle":"Poisson solver","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.initcoef!-Union{Tuple{timeopt}, Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv, StdPoisson2d}, AdvectionData{T, N, timeopt}}} where {T, N, Nsp, Nv, timeopt}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(pv, advd)\n source"},{"id":283,"pagetitle":"Poisson solver","title":"SemiLagrangian.isvelocity","ref":"/semi-lagrangian/dev/poisson/#SemiLagrangian.isvelocity-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv}, AdvectionData{T, N}}} where {T, N, Nsp, Nv}","content":" SemiLagrangian.isvelocity  —  Method isvelocity(pv, advd)\n initcoef!(pv::PoissonVar{T, N,Nsp, Nv}, self::AdvectionData{T, N}) Implementation of the interface function that is called at the begining of each advection     This is implementation for Vlasov-Poisson equation source"},{"id":286,"pagetitle":"Rotation","title":"Rotation","ref":"/semi-lagrangian/dev/rotation/#Rotation","content":" Rotation First simulation using semi-lagrangian method to get a rotation import SemiLagrangian: magicsplit\n\nusing SemiLagrangian\nusing LinearAlgebra\n\nfunction exact!(f, mesh1::UniformMesh{T}, mesh2::UniformMesh{T}, tf::T) where {T}\n    for (i, x) in enumerate(mesh1.points), (j, y) in enumerate(mesh2.points)\n        s, c = sincos(tf)\n        xn, yn = c * x - s * y, s * x + c * y\n        f[i,j] = exp(-13*((xn)^2+(yn+T(6//5))^2))\n    end\nend\n\nfunction run_rotation()\n\n    mesh_sp = UniformMesh( -5.0, 5.0, 256)\n    mesh_v = UniformMesh( -5.0, 5.0, 256)\n    nbdt=50\n    dt = 2pi/nbdt\n    interp_sp = Lagrange(11)\n    interp_v = Lagrange(11)\n\n    adv = Advection(\n               (mesh_sp, mesh_v),\n               [interp_sp, interp_v],\n               dt,\n               [([1, 2], 1, 1, true), ([2, 1], 1, 2, true)];\n               tab_coef = magicsplit(dt),\n           )\n\n    sz = sizeall(adv)\n    tabref = zeros(sz)\n    exact!(tabref, mesh_sp, mesh_v, 0.0)\n\n    pvar = getrotationvar(adv)\n\n    advdata = AdvectionData(adv, tabref, pvar)\n\n    diffmax = 0\n    data = getdata(advdata)\n    for ind=1:nbdt\n        while advection!(advdata) end\n        exact!(tabref, mesh_sp, mesh_v, dt*ind)\n        diff = norm(data .- tabref, Inf)\n        diffmax = max(diffmax, diff)\n        println(\"ind=$ind sz=$sz interp=$interp_sp, $interp_v nbdt=$nbdt diff,diffmax=$diff,$diffmax\")\n    end\n\nend\n\nrun_rotation() ind=1 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=2.720717429127717e-9,2.720717429127717e-9\nind=2 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=5.426907589978214e-9,5.426907589978214e-9\nind=3 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=8.540088303199411e-9,8.540088303199411e-9\nind=4 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.2389074988128357e-8,1.2389074988128357e-8\nind=5 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.6302517558131058e-8,1.6302517558131058e-8\nind=6 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=2.150038780346364e-8,2.150038780346364e-8\nind=7 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=2.4565168232904e-8,2.4565168232904e-8\nind=8 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=2.6644191963853814e-8,2.6644191963853814e-8\nind=9 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=2.9374689458627756e-8,2.9374689458627756e-8\nind=10 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=3.406096837910155e-8,3.406096837910155e-8\nind=11 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=3.8563625293086545e-8,3.8563625293086545e-8\nind=12 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=4.125212804684253e-8,4.125212804684253e-8\nind=13 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=4.393345309772201e-8,4.393345309772201e-8\nind=14 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=4.772145634213132e-8,4.772145634213132e-8\nind=15 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=5.181817808175282e-8,5.181817808175282e-8\nind=16 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=5.587387930106047e-8,5.587387930106047e-8\nind=17 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=5.911457423568578e-8,5.911457423568578e-8\nind=18 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=5.890404408681604e-8,5.911457423568578e-8\nind=19 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=6.54671566957532e-8,6.54671566957532e-8\nind=20 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=7.052268014007268e-8,7.052268014007268e-8\nind=21 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=7.351569064617536e-8,7.351569064617536e-8\nind=22 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=7.731054341153509e-8,7.731054341153509e-8\nind=23 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=7.824339876005837e-8,7.824339876005837e-8\nind=24 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=8.434378462318648e-8,8.434378462318648e-8\nind=25 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=8.46239429641571e-8,8.46239429641571e-8\nind=26 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=8.83282956776199e-8,8.83282956776199e-8\nind=27 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=8.652264549269262e-8,8.83282956776199e-8\nind=28 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=9.423600422220346e-8,9.423600422220346e-8\nind=29 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=9.587383120734927e-8,9.587383120734927e-8\nind=30 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.0096010194526883e-7,1.0096010194526883e-7\nind=31 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.0750887657895447e-7,1.0750887657895447e-7\nind=32 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.0704766661984166e-7,1.0750887657895447e-7\nind=33 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.1075712669228466e-7,1.1075712669228466e-7\nind=34 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.1380138220662417e-7,1.1380138220662417e-7\nind=35 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.1835150448558096e-7,1.1835150448558096e-7\nind=36 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.2540696514573568e-7,1.2540696514573568e-7\nind=37 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.268692502165436e-7,1.268692502165436e-7\nind=38 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.2899573120783714e-7,1.2899573120783714e-7\nind=39 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.3321142300348754e-7,1.3321142300348754e-7\nind=40 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.380369133441306e-7,1.380369133441306e-7\nind=41 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.409357565096414e-7,1.409357565096414e-7\nind=42 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.4518337054791886e-7,1.4518337054791886e-7\nind=43 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.4220855004687394e-7,1.4518337054791886e-7\nind=44 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.5261320240878007e-7,1.5261320240878007e-7\nind=45 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.556093395249647e-7,1.556093395249647e-7\nind=46 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.58368612557247e-7,1.58368612557247e-7\nind=47 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.6267826330462754e-7,1.6267826330462754e-7\nind=48 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.6098251220952875e-7,1.6267826330462754e-7\nind=49 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.711825026173841e-7,1.711825026173841e-7\nind=50 sz=(256, 256) interp=Lagrange{Float64, SemiLagrangian.CircEdge, 11}, Lagrange{Float64, SemiLagrangian.CircEdge, 11} nbdt=50 diff,diffmax=1.6940978286861252e-7,1.711825026173841e-7"},{"id":287,"pagetitle":"Rotation","title":"SemiLagrangian.RotationVar","ref":"/semi-lagrangian/dev/rotation/#SemiLagrangian.RotationVar","content":" SemiLagrangian.RotationVar  —  Type mutable struct RotationVar{T, N} <: SemiLagrangian.AbstractExtDataAdv source"},{"id":288,"pagetitle":"Rotation","title":"SemiLagrangian.getalpha","ref":"/semi-lagrangian/dev/rotation/#SemiLagrangian.getalpha-Tuple{SemiLagrangian.RotationVar, AdvectionData, Any}","content":" SemiLagrangian.getalpha  —  Method getalpha(pv, self, ind)\n getalpha(pv::RotationVar, self::AdvectionData, ind) Implementation of the interface function that is called before each interpolation in advection source"},{"id":289,"pagetitle":"Rotation","title":"SemiLagrangian.getrotationvar","ref":"/semi-lagrangian/dev/rotation/#SemiLagrangian.getrotationvar-Tuple{Advection}","content":" SemiLagrangian.getrotationvar  —  Method getrotationvar(adv)\n source"},{"id":290,"pagetitle":"Rotation","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/rotation/#SemiLagrangian.initcoef!-Union{Tuple{timeopt}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.RotationVar{T, N}, AdvectionData{T, N, timeopt, NoTimeAlg}}} where {T, N, timeopt}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(pv, self)\n initcoef!(pv::RotationVar{T, Nsp, Nv}, self::AdvectionData{T, Nsp, Nv, Nsum}) Implementation of the interface function that is called at the begining of each advection     This is implementation for Vlasov-Poisson equation source"},{"id":291,"pagetitle":"Rotation","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/rotation/#SemiLagrangian.initcoef!-Union{Tuple{timeopt}, Tuple{T}, Tuple{SemiLagrangian.RotationVar{T, 2}, Union{AdvectionData{T, 2, timeopt, ABTimeAlg_ip}, AdvectionData{T, 2, timeopt, ABTimeAlg_new}}}} where {T, timeopt}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(pv, self)\n source"},{"id":296,"pagetitle":"Surface Quasi-Geostrosphic","title":"Surface Quasi-Geostrosphic","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#Surface-Quasi-Geostrosphic","content":" Surface Quasi-Geostrosphic"},{"id":297,"pagetitle":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.GeoConst","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#SemiLagrangian.GeoConst","content":" SemiLagrangian.GeoConst  —  Type struct GeoConst{T, N} adv::Advection odg_b::Any coefrsqk::Tuple{Vararg{Array{Complex{T}, N}, N}} where {T, N} pfftbig::Union{Missing, SemiLagrangian.PrepareFftBig{T}} where T source"},{"id":298,"pagetitle":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.GeoVar","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#SemiLagrangian.GeoVar","content":" SemiLagrangian.GeoVar  —  Type struct GeoVar{T, N} <: SemiLagrangian.AbstractExtDataAdv gc::SemiLagrangian.GeoConst source"},{"id":299,"pagetitle":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.getalpha","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#SemiLagrangian.getalpha-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.GeoVar{T, N}, AdvectionData{T}, CartesianIndex, CartesianIndex}} where {T, N}","content":" SemiLagrangian.getalpha  —  Method getalpha(_, self, indext, indbuf)\n source"},{"id":300,"pagetitle":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.getgeovar","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#SemiLagrangian.getgeovar-Union{Tuple{Advection{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","content":" SemiLagrangian.getgeovar  —  Method getgeovar(adv; kwargs...)\n source"},{"id":301,"pagetitle":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#SemiLagrangian.initcoef!-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.GeoVar{T, N}, AdvectionData{T, N}}} where {T, N}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(geoc, advd)\n source"},{"id":302,"pagetitle":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.initdata!","ref":"/semi-lagrangian/dev/surfacequasigeostrophic/#SemiLagrangian.initdata!-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.GeoVar{T, N}, AdvectionData{T, N}}} where {T, N}","content":" SemiLagrangian.initdata!  —  Method initdata!(geoc, advd)\n source"},{"id":305,"pagetitle":"Translation","title":"Translation","ref":"/semi-lagrangian/dev/translation/#Translation","content":" Translation"},{"id":306,"pagetitle":"Translation","title":"SemiLagrangian.TranslationVar","ref":"/semi-lagrangian/dev/translation/#SemiLagrangian.TranslationVar","content":" SemiLagrangian.TranslationVar  —  Type mutable struct TranslationVar{T, N} <: SemiLagrangian.AbstractExtDataAdv source"},{"id":307,"pagetitle":"Translation","title":"SemiLagrangian.getalpha","ref":"/semi-lagrangian/dev/translation/#SemiLagrangian.getalpha-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.TranslationVar{T, N}, AdvectionData{T, N}, Any}} where {T, N}","content":" SemiLagrangian.getalpha  —  Method getalpha(pv, self, ind)\n getalpha(pv::TranslationVar, self::AdvectionData, i, ind) Implementation of the interface function that is called before each interpolation in advection source"},{"id":308,"pagetitle":"Translation","title":"SemiLagrangian.gettranslationvar","ref":"/semi-lagrangian/dev/translation/#SemiLagrangian.gettranslationvar-Union{Tuple{Tuple{Vararg{T, N}}}, Tuple{N}, Tuple{T}} where {T, N}","content":" SemiLagrangian.gettranslationvar  —  Method gettranslationvar(v)\n source"},{"id":309,"pagetitle":"Translation","title":"SemiLagrangian.initcoef!","ref":"/semi-lagrangian/dev/translation/#SemiLagrangian.initcoef!-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.TranslationVar{T, N}, AdvectionData{T, N}}} where {T, N}","content":" SemiLagrangian.initcoef!  —  Method initcoef!(pv, self)\n source"},{"id":312,"pagetitle":"Vlasov-Poisson","title":"Vlasov-Poisson","ref":"/semi-lagrangian/dev/vlasov-poisson/#Vlasov-Poisson","content":" Vlasov-Poisson using SemiLagrangian\nusing Plots\n\nfunction run_simulation(nbdt, sz, dt, interp, tab_coef)\n\n    epsilon = 0.001\n\n    xmin, xmax, nx = 0., 4π, sz[1]\n    vmin, vmax, nv = -6., 6., sz[2]\n\n    mesh_x = UniformMesh(xmin, xmax, nx)\n    mesh_v = UniformMesh(vmin, vmax, nv)\n\n    states = [([1, 2], 1, 1, true), ([2, 1], 1, 2, true)]\n\n    adv = Advection((mesh_x, mesh_v), [interp, interp], dt, states;\n        tab_coef, timeopt = NoTimeOpt)\n\n    kx = 0.5\n    fct_x(x) = epsilon * cos(kx * x) + 1\n    fct_v(v) = exp(-v^2 / 2) / sqrt(2π)\n\n    lgn_x = fct_x.(mesh_x.points)\n    lgn_v = fct_v.(mesh_v.points)\n\n    data = dotprod((lgn_x, lgn_v))\n\n    pvar = getpoissonvar(adv)\n\n    advd = AdvectionData(adv, data, pvar)\n\n    time = Float64[]\n    el = Float64[]\n    for i = 1:nbdt\n        while advection!(advd) end\n        push!(time, advd.time_cur)\n        push!(el, compute_ee(advd))\n    end\n    return time, el\nend\n\nnbdt = 1000\nsz = (64, 64)\ndt = 0.1\ninterp = Lagrange(9, Float64)\ntab_coef = strangsplit(dt)\ntime, el = run_simulation( nbdt, sz, dt, interp, tab_coef)\nplot(time, 0.5 .* log.(el.^2))"},{"id":315,"pagetitle":"Home","title":"VlasovSolvers.jl","ref":"/vlasov-solvers/dev/#VlasovSolvers.jl","content":" VlasovSolvers.jl First draft of a Vlasov solvers Julia suite. The Vlasov equation is of paramount importance in plasma physics. It is a nonlinear transport equation  satisfied by the distribution function  $f$  of the considered charged particles (ions or electrons typically).   The Vlasov equation is a kinetic equation which means the unknown  $f$  not only depends on time  $t$  and space  $x$   but also on the velocity repartition of the particles through the variable  $v$ . Hence, the distribution function   $f$  depends on  $t\\geq 0$ ,  $x\\in \\Omega\\subset \\mathbb{R}^d$  and  $v\\in \\mathbb{R}^d$  with  $d\\geq 1$  the dimension of the problem.  The main goal of this library is to propose some efficient numerical tools to solve numerically the Vlasov-Poisson equation  using the semi-Lagrangian method.  We consider a population of electrons whereas the ions are supposed stationary with a constant density equal to one.  The spatial domain  $\\Omega$  is a torus in dimension  $d$  so that  $x\\in \\Omega=[0, L]^d$  with periodic boundary conditions.   In this framework, the Vlasov-Poisson equation we intend to solve can be written as   \\[\\partial_t f + v\\cdot \\nabla_x f + E\\cdot \\nabla_v f =0, \\] where the electric field  $E=E(t, x)\\in \\mathbb{R}^d$  depends on the solution  $f$  through the Poisson equation  \\[\\nabla_x \\cdot E=  \\int f dv - 1. \\] The electric field is supposed to derive from an electric potential  $\\phi(t, x)\\in \\mathbb{R}$  so that   $E(t, x)=-\\nabla_x \\phi(t, x)$  and  $\\phi$  solves the following elliptic equation  \\[-\\Delta \\phi=  \\int f dv - 1. \\] In the following, some elements detailing the numerical method developed in the library are given  (splitting, semi-Lagrangian method, Poisson equation solver). "},{"id":316,"pagetitle":"Home","title":"Splitting","ref":"/vlasov-solvers/dev/#Splitting","content":" Splitting Splitting methods enable to reduce the resolution of complex systems into the successive   resolution of simple problems. The way complex systems are split strongly depends on the  considered problem. For the Vlasov-Poisson system, we appeal to its specific Hamiltonian structure (see Casas-Crouseilles-Faou-Mehrenberger),  which enables to split the Vlasov equation into the two following parts  \\[\\partial_t f + v\\cdot \\nabla_x f=0 \\;\\; \\mathrm{ and } \\;\\; \\partial_t f +\nE\\cdot \\nabla_v f=0, \\] so that the numerical solution can be approximated by the successive solution of each part. Indeed, if we denote  $\\varphi^x_t(f_0)$  the solution at time  $t$  of \\[\\partial_t f + v\\cdot \\nabla_x f=0, \\] and  $\\varphi^v_t(f_0)$  the solution at time  $t$  of \\[\\partial_t f + E\\cdot \\nabla_v f=0, \\] then the solution  $\\varphi_t(f_0)$  of the Vlasov equation can be approximated by \\[\\varphi_t(f_0) \\approx \\varphi^v_t \\circ \\varphi^x_t(f_0).  \\] A very interesting aspect of this splitting comes from the fact that each subpart  $\\varphi^x_t(f_0)$  and  $\\varphi^v_t(f_0)$   can be solved exactly in time. Indeed, the solution at time  $t$  of  $\\partial_t f + v\\cdot \\nabla_x f=0$   with a given initial condition  $f(0, x, v)=f_0(x, v)$  is  $f(t, x, v)=f_0(x-vt, v)$ .  For a given electric field  $E(t, x)$  (typically obtained from the solution of the Poisson equation), the   solution at time  $t$  of  \\[\\partial_t f + E\\cdot \\nabla_v f=0\\] with a given initial condition  $f(0, x, v)=f_0(x, v)$  is  \\[f(t, x, v)=f_0(x, v-E(0, x) t). \\] Indeed, it is worth mentioning that the electric field  $E$  does not depend on time during this step. Since  $E$  only depends on  $\\int f dv$ , the velocity integration of  \\[\\partial_t f + E\\cdot \\nabla_v f=0\\] leads to  \\[\\frac{d}{dt}\\int f dv = 0\\] so that  $\\frac{d}{dt} E(t, x) = 0$  and  $E(t, x)=E(0, x)$  along this step. This is the Lie-Trotter splitting which is a first order approximation of the solution  $f(t)$ . High order splittings can be derived by choosing a sequence of coefficients  $(a_i, b_i)$  so that \\[\\varphi_t(f_0) \\approx \\Pi_{i} \\;\\;  \\Big(\\varphi^v_{a_i t} \\circ \\varphi^x_{b_i t}\\Big)(f_0).  \\] The splitting enables us to reduce the original problem into several smaller problems which are easier to solve. Indeed, in the Vlasov case, we are led to solve one dimensional linear transport equations which we choose to solve using the semi-Lagrangian method.  The basics of the semi-Lagrangian method are recalled in the following.  We are faced with multidimensional linear transport equation which can be split again  into one dimensional linear transport equation. Indeed, for the part  \\[\\partial_t f + v\\cdot \\nabla_x f = 0,\\] we can split exactly this  $d$ -dimensional transport equation into  \\[\\partial_t + v_\\alpha \\partial_{x_\\alpha} f = 0, \\;\\; \\alpha=1, \\ldots, d,   \\] where  $x_\\alpha$  (resp.  $v_\\alpha$ ) denotes the  $\\alpha$ -th component of  $x$  (resp.  $v$ ).  Similarly, we can  split exactly the part  $\\partial_t f + E\\cdot \\nabla_v f = 0$   into  $d$  one dimensional linear transport equations  \\[\\partial_t + E_\\alpha \\partial_{v_\\alpha} f = 0, \\;\\; \\alpha=1, \\ldots, d,    \\] where  $E_\\alpha$  denotes the  $\\alpha$ -th compoent of the electric field  $E$ . "},{"id":317,"pagetitle":"Home","title":"Semi-Lagrangian method","ref":"/vlasov-solvers/dev/#Semi-Lagrangian-method","content":" Semi-Lagrangian method According to the previous section, we are led to solve the following linear transport equation  \\[\\partial_t f + a \\partial_x f=0, f(t=0, x) = f_0(x), x\\in [0, L], \\] with periodic boundary conditions. According to the above notations,   $x$  denotes here the spatial or velocity direction.  We know that the exact solution of  $\\partial_t f + a \\partial_x f=0$  can be written as \\[f(t, x) = f_0(x-at), \\] or if we consider the solution from time  $s$  to  $t$ `, we have \\[f(t, x) = f(s, x-a(t-s)).  \\] The property that  $f$  is constant along the characteristics paves the way of the semi-Lagrangian method. Indeed, let's consider a time discretization  $t_n = n\\Delta t, n\\in \\mathbb{N}$ ,  $\\Delta t>0$  and a space discretization  $x_i=i\\Delta x, i\\in N_x, \\Delta x>0, \\Delta x=L/N_x$  where  $N_x$  is the number of points.  Considering  $t=t_{n+1}, s=t_n$  and  $x=x_i$  in the former equation, we get  \\[f(t_{n+1}, x_i) = f(t_n, x_i-a \\Delta t).  \\] We assume that  $f(t_n, x_i)$  are all known, we have to compute  $f(t_n, x_i-a \\Delta t)$  and this is done by a standard interpolation method. For the Vlasov problem, high order interpolation are required (citer Francis, Sonnen, Michel...).  Within the framework of this package, we have chosen  piecewise polynomial interpolation of two kinds: Lagrange interpolation or B-splines interpolation (of odd degree).  Arbitrary high order of Lagrange and B-splines polynomials are  available and have been tested according to recent estimates (citer Michel-Latu-Sonnen).  For  $p$  order Lagrange interpolation, we have \\[f(t_n, x) = \\sum_{i=0}^k f(t_n, x_i) L_{i,p}(x), \\] where  \\[L_{i,p}(x) = \\Pi_{0\\leq k\\leq p, k\\neq i} \\frac{x-x_k}{x_i-x_k}, \\;\\;\n\\mathrm{ for }\\; 0\\leq i\\leq p.  \\] For the B-spline interpolation of order  $p$ , we have \\[f(t_n, x) = \\sum_{i=0}^{N_x-1} \\eta_i B_{i,p}(x) \\] where  \\[B_{i,0}(x) := \\left\\{\n\\begin{matrix}\n1 & \\mathrm{if}  \\quad \\tau_i \\leq x < \\tau_{i+1} \\\\\n0 & \\mathrm{otherwise} \n\\end{matrix}\n\\right.\\] \\[B_{i,p}(x) := \\frac{x - \\tau_i}{\\tau_{i+p} - \\tau_i} B_{i,p-1}(x) \n+ \\frac{\\tau_{i+p+1} - x}{\\tau_{i+p+1} - \\tau_{i+1}} B_{i+1,p-1}(x).\\] and the coefficients  $(\\eta_i)_{i=0, \\dots, N_x-1}$  are solution of a linear system to solve (cite De Boor, Michel, ...)."},{"id":318,"pagetitle":"Home","title":"Numerical method for Poisson equation","ref":"/vlasov-solvers/dev/#Numerical-method-for-Poisson-equation","content":" Numerical method for Poisson equation The Poisson equation with periodic boundary condition is solved using Fourier techniques. First, we consider the following DFT (Discrete Fourier Transform) of a  $L-$ periodic function  $g$  defined on a mesh of  $N_x$  points such that  $x_j=j \\Delta x, \\Delta x=L/N_x, 0\\leq j\\leq N_x-1$ \\[\\hat{g}_k := \\frac{1}{N_x}\\sum_{j=0}^{N_x-1} g(x_j) e^{-i \\frac{2\\pi}{L} k\nx_j}, \\;\\; k=0, \\dots, N_x-1. \\] Thus, from the Poisson equation,   \\[\\partial_x E = \\rho -1, \\] we consider the Fourier transform to get \\[i k \\hat{E}_k = \\hat{\\rho}_k \\;\\; \\mathrm{  if  } \\;\\;  k\\neq 0, \\;\\;\n\\hat{E}_0=0.  \\] Then, we can compute the Fourier coefficients  $\\hat{E}_k$  as \\[\\hat{E}_k = \\frac{1}{ik}\\hat{\\rho}_k,  \\] and an inverse Fourier transform is used to get  $E_i\\approx E(x_i)$ .  The extension of this algorithm to the multidimensional case requires to introduce the electric potential  $\\varphi$  such that  $E=-\\nabla_x \\phi$ . The scalar electric potential solves an elliptic Poisson equation \\[-\\Delta \\phi = \\rho -1\\] which is also solved using Fourier techniques. Now we get (now  $k$  is a vectorial wavenumber)  \\[|k|^2 \\hat{\\phi}_k = \\hat{\\rho}_k \\;\\; \\mathrm{  if  } \\;\\;  k\\neq 0, \\;\\;\n\\hat{\\phi}_0=0.  \\] so that  $\\hat{\\phi}_k = \\hat{\\rho}_k/|k|^2$  and the electric field can be computed using \\[\\hat{E}_k = -ik \\hat{\\phi}_k  \\;\\; \\mathrm{  if  } \\;\\;  k\\neq 0, \\;\\;\n\\hat{E}_0=0.  \\] and an inverse Fourier tranform. See book Sonnen for more details. "},{"id":319,"pagetitle":"Home","title":"Algorithm","ref":"/vlasov-solvers/dev/#Algorithm","content":" Algorithm Once the linear advection (or transport) equation are solved using the semi-Lagrangian method, the algorithm to solve the Vlasov-Poisson equation can now be written. To do so, we consider a uniform mesh of the phase space  $(x, v)$ .  For the spatial domain  $[0, L]$ , we introduce  $x_i=i\\Delta x, i=0, \\dots, N_x-1$ ,   $N_x$  being the number of points in  $x$  and  $\\Delta x=L/N_x$ .  For the velocity direction, we need to consider a truncated velocity domain  $[-v_{\\max}, v_{\\max}]$   and the mesh is defined by  $v_j = -v_{\\max} + j\\Delta v, j=0, \\dots, N_v-1, \\Delta v=2v_{\\max} / N_v$ ,  $N_v$  being the number of points in the velocity direction.  Then, the algorithm based on Lie-Trotter and semi-Lagrangian method is: Initialization. From the given initial condition  $f_0$ , we evaluate it on the phase space mesh to get  $f^0_{i,j}=f_0(x_i, v_j)$ . We then compute the initial electric field  $E_{0, i}\\approx E_0(x_i)$ .  From  $t_n$  to  $t_{n+1}$ . Knowing all the grid point values of  $f^n$  and  $E^n$ Compute  $f^\\star_{i,j}$  solving \\[\\partial_t f + v\\partial_x f=0, \\] using the semi-Lagrangian method  $f^\\star_{i, j} \\approx f^n(x_i-v_j\\Delta t, v_j)$ . Solve the electric field  $E^\\star_i$   from the Poisson equation \\[\\partial_x E^\\star = \\sum_{j=0}^{N_v-1} f^\\star_{i, j} \\Delta v -1.  \\] Compute  $f^{n+1}$  solving \\[\\partial_t f + E^\\star\\partial_v f = 0, \\] using the semi-Lagrangian method  $f^{n+1}_{i, j} \\approx f^n(x_i, v_j-E^\\star_i \\Delta t)$ .  The extension to the well-known Strang  splitting (which is second order accurate in time) can be written as follows.  Initialization. From the given initial condition  $f_0$ , we evaluate it on the phase space mesh to get  $f^0_{i,j}=f_0(x_i, v_j)$ . We then compute the initial electric field  $E_{0, i}\\approx E_0(x_i)$ .  From  $t_n$  to  $t_{n+1}$ . Knowing all the grid point values of  $f^n_{i,j}$  and  $E^n_i$ Compute  $f^\\star_{i,j}$  solving \\[\\partial_t f + v\\partial_x f=0, \\] using the semi-Lagrangian method  $f^\\star_{i, j} \\approx f^n(x_i-v_j\\Delta t/2, v_j)$ . Solve the electric field  $E^\\star_i$   from the Poisson equation \\[\\partial_x E^\\star = \\sum_{j=0}^{N_v-1} f^\\star_{i, j} \\Delta v -1.  \\] Compute  $f^{\\star\\star}$  solving \\[\\partial_t f + E^\\star\\partial_v f = 0, \\] using the semi-Lagrangian method  $f^{\\star\\star}_{i, j} \\approx f^n(x_i, v_j-E^\\star_i \\Delta t)$ .  Compute  $f^\\star_{i,j}$  solving \\[\\partial_t f + v\\partial_x f=0, \\] using the semi-Lagrangian method  $f^{n+1}{i, j} \\approx f^{\\star\\star}(x_i-v_j\\Delta t/2, v_j)$ ."},{"id":322,"pagetitle":"Bump On Tail","title":"Bump On Tail","ref":"/vlasov-solvers/dev/bump_on_tail/#Bump-On-Tail","content":" Bump On Tail using VlasovSolvers\nusing Plots\nusing LaTeXStrings\n\ndev = CPU()                  # device\nstepper = StrangSplitting()  # timestepper\ndt = 0.1                     # timestep\nnsteps = 1000                # total number of time-steps\n\nα   = 0.03\nkx  = 0.3\n\nn1, n2 = 32, 64\nx1min, x1max = 0.0, 2π / kx\nx2min, x2max = -9., 9.\n\nmesh1 = OneDGrid(dev, n1, x1min, x1max)\nmesh2 = OneDGrid(dev, n2, x2min, x2max)\n\nf = DistributionFunction( mesh1, mesh2 )\n\n\nfor (i,x) in enumerate(mesh1.points), (j,v) in enumerate(mesh2.points)\n    f.values[i,j]  = (1.0+α*cos(kx*x)) / (10*sqrt(2π)) * (9*exp(-0.5*v^2)+2*exp(-2*(v-4.5)^2))\nend\n\n\nnsteps = 500\nt   = range(0.0, stop=50.0, length=nsteps)\ndt  = t[2]\n\nprob = VlasovProblem(f, BSLSpline(5), dev)\n\nsol = solve(prob, stepper, dt, nsteps )\n\nplot(sol, label=L\"\\frac{1}{2} \\log(\\int e^2dx)\")"},{"id":325,"pagetitle":"Contents","title":"Contents","ref":"/vlasov-solvers/dev/contents/#Contents","content":" Contents Bump On Tail Contents Index VlasovSolvers.jl Splitting Semi-Lagrangian method Numerical method for Poisson equation Algorithm Vlasov Problem Rotation of a gaussian distribution Swirling flow Two-stream instability Vlasov–Ampere Algorithm Vlasov HMF Benchmarks Conclusion Vlasov-Poisson Input parameters Simulation with BSpline interpolation Simulation with Lagrange interpolation"},{"id":326,"pagetitle":"Contents","title":"Index","ref":"/vlasov-solvers/dev/contents/#Index","content":" Index VlasovSolvers.VlasovProblem VlasovSolvers.solve VlasovSolvers.solve"},{"id":329,"pagetitle":"Problem type","title":"Vlasov Problem","ref":"/vlasov-solvers/dev/problem/#Vlasov-Problem","content":" Vlasov Problem"},{"id":330,"pagetitle":"Problem type","title":"VlasovSolvers.VlasovProblem","ref":"/vlasov-solvers/dev/problem/#VlasovSolvers.VlasovProblem","content":" VlasovSolvers.VlasovProblem  —  Type struct VlasovProblem{Method<:VlasovSolvers.AbstractMethod} <: VlasovSolvers.AbstractProblem f::DistributionFunction method::VlasovSolvers.AbstractMethod dev::VlasovSolvers.AbstractDevice source"},{"id":331,"pagetitle":"Problem type","title":"VlasovSolvers.solve","ref":"/vlasov-solvers/dev/problem/#VlasovSolvers.solve-Tuple{VlasovProblem{Fourier}, StrangSplitting, Any, Any}","content":" VlasovSolvers.solve  —  Method solve(problem, stepper, dt, nsteps)\n source"},{"id":332,"pagetitle":"Problem type","title":"VlasovSolvers.solve","ref":"/vlasov-solvers/dev/problem/#VlasovSolvers.solve-Tuple{VlasovSolvers.AbstractProblem, StrangSplitting, Any, Any}","content":" VlasovSolvers.solve  —  Method solve(problem, stepper, dt, nsteps)\n source"},{"id":335,"pagetitle":"Rotation 2D","title":"Rotation of a gaussian distribution","ref":"/vlasov-solvers/dev/rotation2d/#Rotation-of-a-gaussian-distribution","content":" Rotation of a gaussian distribution \\[\\frac{df}{dt} +  (y \\frac{df}{dx} - x \\frac{df}{dy}) = 0\\] using Plots\nusing VlasovSolvers\nusing FFTW, LinearAlgebra \"\"\"\n    exact(tf, mesh)\n\nExact solution of the gaussian rotation\n\n\"\"\"\nfunction exact!(f, t, x, y)\n    for (i, xx) in enumerate(x), (j, yy) in enumerate(y)\n        xn = cos(t)*xx - sin(t)*yy\n        yn = sin(t)*xx + cos(t)*yy\n        f[i,j] = exp(-(xn-1)^2/0.1)*exp(-(yn-1)^2/0.1)\n    end\n    f\nend Main.exact! dev = CPU()\nn1, n2 = 256, 256\nmesh1 = OneDGrid(dev, n1, -pi, pi)\nmesh2 = OneDGrid(dev, n2, -pi, pi)\n\nf = zeros(Float64,(n1,n2))\n\nanim = @animate for t in LinRange(0,20π,200)\n    exact!(f, t, mesh1.points, mesh2.points)\n    contour(f, aspect_ratio=:equal, frame=:none, legend=:none)\nend [ Info: Saved animation to /home/runner/work/VlasovSolvers.jl/VlasovSolvers.jl/docs/build/assets/rotation.gif x = mesh1.points\ny = mesh2.points\n\nnsteps = 1000\ntf = 200 * pi\ndt = tf/nsteps\n\nkx = 2π/(mesh1.stop-mesh1.start)*[0:mesh1.len÷2-1;mesh1.len÷2-mesh1.len:-1]\nky = 2π/(mesh2.stop-mesh2.start)*[0:mesh2.len÷2-1;mesh2.len÷2-mesh2.len:-1]\n\nf  = zeros(Complex{Float64},(mesh1.len,mesh2.len))\nf̂  = similar(f)\nfᵗ = zeros(Complex{Float64},(mesh1.len,mesh2.len))\nf̂ᵗ = similar(fᵗ)\n\nexky = exp.( 1im*tan(dt/2) .* mesh1.points' .* ky ) |> collect\nekxy = exp.(-1im*sin(dt)   .* mesh2.points' .* kx ) |> collect\n\nFFTW.set_num_threads(4)\nPx = plan_fft(f,  1, flags=FFTW.PATIENT)\nPy = plan_fft(fᵗ, 1, flags=FFTW.PATIENT)\n\nexact!(f, 0.0, mesh1.points, mesh2.points)\n\nfor n = 1:nsteps\n    transpose!(fᵗ,f)\n    mul!(f̂ᵗ, Py, fᵗ)\n    f̂ᵗ .= f̂ᵗ .* exky\n    ldiv!(fᵗ, Py, f̂ᵗ)\n    transpose!(f,fᵗ)\n\n    mul!(f̂, Px, f)\n    f̂ .= f̂ .* ekxy\n    ldiv!(f, Px, f̂)\n\n    transpose!(fᵗ,f)\n    mul!(f̂ᵗ, Py, fᵗ)\n    f̂ᵗ .= f̂ᵗ .* exky\n    ldiv!(fᵗ, Py, f̂ᵗ)\n    transpose!(f,fᵗ)\nend\n\ntest = zeros(mesh1.len, mesh2.len)\nexact!(test, tf, mesh1.points, mesh2.points)\nprintln(maximum(abs.(real(f) .- test))) 9.744698628622961e-12"},{"id":340,"pagetitle":"Swirling flow","title":"Swirling flow","ref":"/vlasov-solvers/dev/swirling-flow/#Swirling-flow","content":" Swirling flow In this problem we use a time-dependent velocity field \\[\\begin{aligned}\n  u_x(x,y,t) &= \\sin^2(\\pi x) \\sin(2 \\pi y) g(t) \\\\\n  u_y(x,y,t) &= -\\sin^2(\\pi y) \\sin(2 \\pi x) g(t)\n\\end{aligned}\\] This represents a swirling flow that distorts the vorticity field, reaching a maximum distortion at :math: t=T/2 . At that point the flow reverses and the vorticity profile returns to its initial value. ref: Gkeyll Simulation Journal"},{"id":343,"pagetitle":"Two-stream instability","title":"Two-stream instability","ref":"/vlasov-solvers/dev/tsi/#Two-stream-instability","content":" Two-stream instability using Plots, Statistics, FFTW, LinearAlgebra\nusing VlasovSolvers dev = CPU()                  # device\nnx, nv = 320, 64             # grid resolution\nstepper = StrangSplitting()  # timestepper\ndt = 0.1                     # timestep\nnsteps = 1000                # total number of time-steps\n\nkx = 0.2\neps = 0.001\nv0 = 2.4\n\nxmin, xmax = 0, 2π/kx   # X Domain length\nvmin, vmax = -10, 10    # V Domain length\n\nxgrid = OneDGrid(dev, nx, xmin, xmax)\nvgrid = OneDGrid(dev, nv, vmin, vmax)\n\ndf = DistributionFunction( xgrid, vgrid )\n\nfor (i,x) in enumerate(xgrid.points), (j,v) in enumerate(vgrid.points)\n    df.values[i, j] = (1 + eps*cos(kx*x))*0.5/sqrt(2pi)*(\n                   exp(-.5*(v - v0)^2) + exp(-.5*(v + v0)^2))\nend\n\ncontourf(vgrid.points, xgrid.points, df.values) \"\"\"\n    compute_e(f)\n\ncompute Ex using that -ik*Ex = rho\n\"\"\"\nfunction compute_e( f )\n\n   dv = f.vgrid.step\n   rho = dv * sum(real(f.values), dims=2)\n   rho = vec(rho .- mean(rho))\n   nx = f.xgrid.len\n   xmin = f.xgrid.start\n   xmax = f.xgrid.stop\n   kx =  2π / (xmax - xmin)\n   modes = zeros(Float64, nx)\n   modes .= kx * vcat(0:div(nx,2)-1,-div(nx,2):-1)\n   modes[1] = 1.0\n   rhok = fft(rho) ./ modes\n   rhok .*= -1im\n   ifft!(rhok)\n   real(rhok)\n\nend\n\nimport VlasovSolvers: advection!\n\nf = copy(df.values)\nfᵗ = transpose(f) |> collect\n\nex = compute_e(df)\n\nadvection!(fᵗ, vgrid, ex, 0.5dt)\n\nv = collect(vgrid.points)\n\nanim = @animate for it in 1:nsteps\n\n    advection!(f, xgrid, v, dt)\n    df.values .= f\n    ex = compute_e( df )\n    transpose!(fᵗ, f)\n    advection!(fᵗ, vgrid, ex, dt)\n    transpose!(f, fᵗ)\n    contourf(vgrid.points, xgrid.points, f, clims=(-0.1,0.4))\n\nend every 10\n\ngif(anim, \"assets/tsi.gif\", fps = 15)"},{"id":346,"pagetitle":"Vlasov-Ampere","title":"Vlasov–Ampere","ref":"/vlasov-solvers/dev/vlasov-ampere/#Vlasov–Ampere","content":" Vlasov–Ampere \\[\\frac{\\partial f}{\\partial t} + \\upsilon \\frac{\\partial f}{\\partial x}\n- E(t,x) \\frac{\\partial f}{\\partial \\upsilon} = 0\\] \\[\\frac{\\partial E}{\\partial t} = - J = \\int f\\upsilon \\; d\\upsilon\\]"},{"id":347,"pagetitle":"Vlasov-Ampere","title":"Algorithm","ref":"/vlasov-solvers/dev/vlasov-ampere/#Algorithm","content":" Algorithm For each  $j$  compute discrete Fourier transform in  $x$  of  $f^n(x_i,\\upsilon_j)$  yielding  $f_k^n(\\upsilon_j)$ ,  For $ k \\neq 0 $ Compute  $f^{n+1}_k(\\upsilon_j) = e^{−2i\\pi k \\upsilon \\Delta t/L} f_n^k(\\upsilon_j),$ Compute  $\\rho_k^{n+1} = \\Delta \\upsilon \\sum_j􏰄 f^{n+1}_k(\\upsilon_j),$ Compute $E^{n+1}_k = \\rho^{n+1}_k L/(2i\\pi k \\epsilon_0),$ For  $k = 0$  do nothing:  $f_{n+1}(\\upsilon_j) = f^n_k(\\upsilon_j), E^{n+1}_k = E^n_k$ . Perform inverse discrete Fourier transform of  $E^{n+1}_k$  and for each  $j$  of  $f^{n+1}_k (\\upsilon_j)$ . using Plots\nusing VlasovSolvers\n\ndev = CPU()                  # device\nnx, nv = 256, 256            # grid resolution\nstepper = StrangSplitting()  # timestepper\ndt = 0.01                    # timestep\nnsteps = 10                  # total number of time-steps\n\nxmin, xmax = 0, 4π           # X Domain length (m)\nvmin, vmax = -6, 6           # V Domain length (m)\nα  = 0.001                   # Perturbation amplitude\nkx = 0.5                     # Wave number of perturbation\n\nxgrid = OneDGrid(dev, nx, xmin, xmax)\nvgrid = OneDGrid(dev, nv, vmin, vmax)\n\nf = DistributionFunction( xgrid, vgrid )\n\nlandau!(f, α, kx)\n\nprob = VlasovProblem(f, Fourier(xgrid, vgrid), dev)\n\nnsteps = 600\ndt = 0.1\n\nsol = solve(prob, stepper, dt, nsteps )\n\nplot(sol.times, -0.1533*sol.times .- 5.48)\nplot!(sol; label=\"ampere\" )"},{"id":350,"pagetitle":"Vlasov-HMF","title":"Vlasov HMF","ref":"/vlasov-solvers/dev/vlasov-hmf/#Vlasov-HMF","content":" Vlasov HMF In this example we will show how the VlasovSolvers package can be used to solve the Vlasov equation in the Hamiltonian Mean Field framework (usually called Vlasov-HMF). The Vlasov-HMF system is a simplification of the Vlasov-Poisson system, which is itself a simplification of the Vlasov-Maxwell equations. Recall the Vlasov-Poisson equations in the noncollisional case: \\[\\partial_t f(t,x,v) + v\\cdot \\partial_x f(t,x,v) + E(t,x)\\cdot \\partial_v f(t,x,v) = 0\\] The quantity  $E(t,x)$  is the electric field, defined in the Poisson framework by \\[-\\Delta \\Phi = 1 - \\rho,\\, E = -\\nabla \\Phi,\\, \\rho(t,x) = \\int f(t,x,v)dv\\] The Poisson equation  $-\\Delta \\Phi = 1 - \\rho$  on a periodic space-domain  $[0, L]$  is usually solved by means of a Fourier transform, assuming  $\\Phi$  has a zero average. In the discrete case this is performed by a DFT, involving  $N_x$  Fourier  modes in total (where  $N_x$  is the number of spatial nodes). In the HMF framework, we apply the same idea but restrict ourselves to the Fourier modes corresponding to the frequencies  $k=\\pm 1$  (the mode corresponding to  $k=0$  is zero  since  $\\Phi$  has a zero average). using LinearAlgebra, QuadGK, Roots, FFTW\nusing VlasovSolvers\nusing Plots function mag(β, mass)\n    F(m) = begin\n        g(x, n, m) = (1 / π) * (exp(β * m * cos(x)) * cos(n * x))\n        bessel0(x) = g(x, 0, m)\n        bessel1(x) = g(x, 1, m)\n        mass * quadgk(bessel1, 0, π)[1] / quadgk(bessel0, 0, π)[1] - m\n    end\n    find_zero(F, (0, mass))\nend mag (generic function with 1 method) function Norm(f::Array{Float64,2}, delta1, delta2)\n    delta1 * sum(delta2 * sum(real(f), dims=1))\nend Norm (generic function with 1 method) \"\"\"\n    hmf_poisson!(fᵗ    :: Array{Complex{Float64},2},\n                 mesh1 :: OneDGrid,\n                 mesh2 :: OneDGrid,\n                 ex    :: Array{Float64})\n\n    Compute the electric hamiltonian mean field from the\n    transposed distribution function\n\n\"\"\"\nfunction hmf_poisson!(fᵗ::Array{Complex{Float64},2},\n        mesh1::OneDGrid,\n        mesh2::OneDGrid,\n        ex::Array{Float64})\n\n    n1 = mesh1.len\n    rho = mesh2.step .* vec(sum(fᵗ, dims=1)) # ≈ ∫ f(t,x_i,v)dv, i=1, ..., N_x\n    kernel = zeros(Float64, n1)\n    k = -(mesh1.stop - mesh1.start) / (2π)\n    kernel[2]   =  k    # fourier mode  1\n    kernel[end] = -k    # fourier mode -1\n    ex .= real(ifft(fft(rho) .* 1im .* kernel))\nend Main.hmf_poisson! dev = CPU()\nnsteps = 1000\ndt = 0.1\n\nmass = 1.0\nT = 0.1\nmesh1 = OneDGrid(dev, 64, -π, π)\nmesh2 = OneDGrid(dev, 128, -10, 10)\n\nn1, delta1 = mesh1.len, mesh1.step\nn2, delta2 = mesh2.len, mesh2.step\nx, v = mesh1.points, mesh2.points'\nϵ = 0.1\n\nb = 1 / T\nm = mag(b, mass)\n\nw   = sqrt(m)\nf   = zeros(Complex{Float64}, (n1,n2))\nfᵗ  = zeros(Complex{Float64}, (n2,n1))\n\n@. f  = exp(-b * ((v^2 / 2) - m * cos(x)))\n\na   = mass / Norm(real(f), delta1, delta2)\n@. f =  a * exp(-b * ((v^2 / 2) - m * cos(x))) * (1 + ϵ * cos(x))\n\ntranspose!(fᵗ, f)\n@show size(f), size(fᵗ)\ncontour(mesh1.points, mesh2.points, real(fᵗ)) Compute the electrical energy in  $hmf_poisson!$  and display it. We also analytically compute E(0, x) to assess the correctness of the numerical computation. We have \\[E(t,x) = -\\partial_x\\Phi(t,x),\\] where \\[\\Phi(t,x) = \\frac{1}{\\pi}\\int_{[-\\pi, \\pi]\\times \\mathbb{R}} \\cos(x-y)f(t,y,v)dydv.\\] By trigonometrical rules, we obtain \\[\\Phi(t,x) = \\frac{\\cos(x)}{\\pi}\\int_{[-\\pi, \\pi]\\times \\mathbb{R}} \\cos(y)f(t,y,v)dydv,\\] where we used the oddness of the mapping  $y\\mapsto sin(y)f(t,y,v)$  to forget about the second integral that should appear. Using the formula for  $f$ \\[f(0, y, v) = a \\exp(-b(v^2/2 - m\\cos(y))) (1 + \\epsilon\\cos(y)),\\] we obtain after some manipulations  \\[\\Phi(0,x) = 2a \\sqrt{\\frac{2\\pi}{b}} \\cos(x) \\left( I_1(bm) + \\frac{\\epsilon}{2} (I_0(bm)+I_2(bm)) \\right).\\] Here  $t\\mapsto I_\\nu(t)$  denotes the modified Bessel function of the first kind, of order  $\\nu \\in \\mathbb{N}$ . The multiplicative  coefficient 2 comes from the definition of  $I_\\nu$ : \\[I_\\nu(t) = \\frac{1}{\\pi}\\int_{[0, \\pi]} e^{t\\cos(y)}\\cos(\\nu y)dy = \\frac{1}{2\\pi} \\int_{[-\\pi, \\pi]} e^{t\\cos(y)}\\cos(\\nu y)dy\\] For the parameters chosen, we obtain that  \\[\\Phi(0,x) = \\alpha \\cos(x),\\, E(0, x) = -\\partial_x \\Phi(0, x) = \\alpha \\sin(x)\\] where  $\\alpha = 0.32962331549891355$ . ex = zeros(Float64,n1)\nhmf_poisson!(fᵗ, mesh1, mesh2, ex)\ntest = copy(f)\nT = Float64[]\nplot(x, ex, label=\"E(t,x)\", minorgrid=true)\nα = 0.32962331549891355\nplot!(x, α*sin.(x), markershape=:circle, linewidth=0, label=\"αsin(x)\") maximum(ex) - α -0.313707821189724 Hence our numerical computation of  ex  through  hmf_poisson!  gives the expected result."},{"id":351,"pagetitle":"Vlasov-HMF","title":"Benchmarks","ref":"/vlasov-solvers/dev/vlasov-hmf/#Benchmarks","content":" Benchmarks We can sometimes find in the literature that the Vlasov-HMF model is a good simplified version of the Vlasov-Poisson equations, since it models the expected behavior quite remarkably. Another way of saying it is that after a short time only the Fourier modes  $k=\\pm 1$  remain, the others vanishing rapidly.  To  illustrate this numerically, we apply the above code – which solves the Vlasov-HMF equations – to the examples  used in the Vlasov-Poisson case. The theoretical analysis for the analytical results can be found in the book  Numerical Methods for the Vlasov-Maxwell Equations from E. Sonnendrücker. The results are to be compared with those obtained by solving the Vlasov-Poisson equations."},{"id":352,"pagetitle":"Vlasov-HMF","title":"Landau damping","ref":"/vlasov-solvers/dev/vlasov-hmf/#Landau-damping","content":" Landau damping Here we consider  $x\\in[0, 2\\pi/k_x]$ , with  $k_x$  some parameter. The initial condition reads \\[f_0(x,v) = (1+\\epsilon \\cos(k_x x)) \\frac{e^{-v^2/2}}{\\sqrt{2\\pi}}\\]"},{"id":353,"pagetitle":"Vlasov-HMF","title":"$k_x = 0.5$","ref":"/vlasov-solvers/dev/vlasov-hmf/#k_x-0.5","content":" $k_x = 0.5$ import VlasovSolvers: advection!\n\ndev = CPU()\nnsteps = 500\ndt = 0.1\n\nϵ = 0.01\nkx = 0.5\n# For this set of parameters the expected damping coefficient is -0.1533,\n# and the \"period of the damping\" is ≈2π/1.4156.\n\nmesh1 = OneDGrid(dev, 64, 0, 2π / kx)\nmesh2 = OneDGrid(dev, 128, -10, 10)\n\nn1, delta1 = mesh1.len, mesh1.step\nn2, delta2 = mesh2.len, mesh2.step\nx, v = mesh1.points, mesh2.points'\n\nflandau  = zeros(Complex{Float64}, (n1,n2))\nflandauᵗ = zeros(Complex{Float64}, (n2,n1))\n\n@. flandau  = exp(-v^2 / 2) * (1 + ϵ * cos(x*kx)) / sqrt(2π)\ntranspose!(flandauᵗ, flandau)\n\nElandau = Array{Float64}(undef, nsteps)\n\nex = zeros(Float64,n1)\nhmf_poisson!(flandauᵗ, mesh1, mesh2, ex)\nadvection!(flandauᵗ, mesh2, ex, 0.5dt)\n\n\nfor n in 1:nsteps\n    Elandau[n] = sqrt(sum(ex.^2) * mesh1.step)\n\n    advection!(flandau, mesh1, v, dt)\n    transpose!(flandauᵗ, flandau)\n    hmf_poisson!(flandauᵗ, mesh1, mesh2, ex)\n    advection!(flandauᵗ, mesh2, ex, dt)\n    transpose!(flandau, flandauᵗ)\nend t = range(0., stop=nsteps*dt, length=nsteps) |> collect\n\nperiod = 2π / 1.4156\nstart = 10.5\nnbperiods = [2, 4, 6, 8]\nvline([start], ls=:dash, label=\"Period reference\", c=\"black\")\nfor p=nbperiods\n  vline!([start + p.*period], ls=:dash, label=\"After $p periods\", c=\"grey\")\nend\n\nplot!(t, log.(Elandau), xlabel = \"t\", minorgrid=true, label=\"log(E(t))\")\nplot!(x-> - 0.1533x - 3.2, label=\"y = -0.1533x - 5.5\")\n# Check \"periods\" of energy : theoretically they are ≈2π/1.4156.\n# Each period in the energy is materialized by 2 bumps.\n\nplot!(t, log.(abs.(4ϵ.*0.3677.*exp.(-0.1533.*t).*cos.(1.4156.*t .- 0.536245)) * √(mesh1.stop/2.)), label=\"theoretical\", ls=:dash)\nplot!(legend=:topright)"},{"id":354,"pagetitle":"Vlasov-HMF","title":"$k_x = 0.4$","ref":"/vlasov-solvers/dev/vlasov-hmf/#k_x-0.4","content":" $k_x = 0.4$ import VlasovSolvers: advection!\n\ndev = CPU()\nnsteps = 500\ndt = 0.1\n\nϵ = 0.001\nkx = 0.4\n# For this set of parameters the expected damping coefficient is -0.0661,\n# and the \"period of the damping\" is ≈2π/1.2850.\n\nmesh1 = OneDGrid(dev, 64, 0, 2π / kx)\nmesh2 = OneDGrid(dev, 128, -10, 10)\n\nn1, delta1 = mesh1.len, mesh1.step\nn2, delta2 = mesh2.len, mesh2.step\nx, v = mesh1.points, mesh2.points'\n\nflandau  = zeros(Complex{Float64}, (n1,n2))\nflandauᵗ = zeros(Complex{Float64}, (n2,n1))\n\n@. flandau  = exp(-v^2 / 2) * (1 + ϵ * cos(x*kx)) / sqrt(2π)\ntranspose!(flandauᵗ, flandau)\n\nElandau = Array{Float64}(undef, nsteps)\n\nex = zeros(Float64,n1)\nhmf_poisson!(flandauᵗ, mesh1, mesh2, ex)\nadvection!(flandauᵗ, mesh2, ex, 0.5dt)\n\n\nfor n in 1:nsteps\n    Elandau[n] = sqrt(sum(ex.^2) * mesh1.step)\n\n    advection!(flandau, mesh1, v, dt)\n    transpose!(flandauᵗ, flandau)\n    hmf_poisson!(flandauᵗ, mesh1, mesh2, ex)\n    advection!(flandauᵗ, mesh2, ex, dt)\n    transpose!(flandau, flandauᵗ)\nend t = range(0., stop=nsteps*dt, length=nsteps) |> collect\n\nperiod = 2π / 1.2850\nstart = 8.7\nnbperiods = [2, 4, 6, 8]\nvline([start], ls=:dash, label=\"Period reference\", c=\"black\")\nfor p=nbperiods\n  vline!([start + p.*period], ls=:dash, label=\"After $p periods\", c=\"grey\")\nend\n\n\nplot!(t, log.(Elandau), xlabel = \"t\", minorgrid=true, label=\"log(E(t))\")\nplot!(x-> - 0.0661x - 5.2, label=\"y = -0.0661x - 5.2\")\n# Check \"periods\" of energy : theoretically they are ≈2π/1.4156.\n# Each period in the energy is materialized by 2 bumps.\n\nplot!(t, log.(4ϵ.*0.42466.*exp.(-0.0661.*t).*abs.(cos.(1.285.*t .- 0.33577)) .* √((mesh1.stop - mesh1.start)/2.)), label=\"theoretical\", ls=:dash)\nplot!(legend=:topright)"},{"id":355,"pagetitle":"Vlasov-HMF","title":"Two-stream Instability","ref":"/vlasov-solvers/dev/vlasov-hmf/#Two-stream-Instability","content":" Two-stream Instability Again, we consider  $x\\in [0, 2\\pi/k_x]$ . The initial condition reads  \\[f_0(x,v) = (1+\\epsilon\\cos(k_x x)) \\frac{e^{-(v+v_0)^2/2} + e^{-(v-v_0)^2/2}}{2\\sqrt{2\\pi}}\\]"},{"id":356,"pagetitle":"Vlasov-HMF","title":"$k_x=0.2, v_0=1.3$","ref":"/vlasov-solvers/dev/vlasov-hmf/#k_x0.2,-v_01.3","content":" $k_x=0.2, v_0=1.3$ import VlasovSolvers: advection!\n\ndev = CPU()\nnsteps = 1000\ndt = 0.1\n\nϵ = 0.001\nkx = 0.2\nv0 = 1.3\n# For this set of parameters the expected damping coefficient is -0.00104\n# and the \"period of the damping\" is ≈2π/1.1648.\n\nmesh1 = OneDGrid(dev, 64, 0, 2π / kx)\nmesh2 = OneDGrid(dev, 128, -10, 10)\n\nn1, delta1 = mesh1.len, mesh1.step\nn2, delta2 = mesh2.len, mesh2.step\nx, v = mesh1.points, mesh2.points'\n\nftsi  = zeros(Complex{Float64}, (n1,n2))\nftsiᵗ  = zeros(Complex{Float64}, (n2,n1))\n\n@.  ftsi =  (exp(- 0.5 * (v-v0)^2) + exp(-0.5 * (v+v0)^2)) * (1 + ϵ * cos(kx*x)) / (2*√(2π))\ntranspose!(ftsiᵗ, ftsi)\n\nEtsi = Array{Float64}(undef, nsteps)\n\nex = zeros(Float64,n1)\nhmf_poisson!(ftsiᵗ, mesh1, mesh2, ex)\nadvection!(ftsiᵗ, mesh2, ex, 0.5dt)\n\n\nfor n in 1:nsteps\n    Etsi[n] = sqrt(sum(ex.^2) * mesh1.step)\n\n    advection!(ftsi, mesh1, v, dt)\n    transpose!(ftsiᵗ, ftsi)\n    hmf_poisson!(ftsiᵗ, mesh1, mesh2, ex)\n    advection!(ftsiᵗ, mesh2, ex, dt)\n    transpose!(ftsi, ftsiᵗ)\nend t = range(0., stop=nsteps*dt, length=nsteps) |> collect\n\nplot(t, log.(Etsi), xlabel = \"t\", minorgrid=true, label=\"log(E(t))\")\nplot!(x-> -0.00104x - 4.15, label=\"y = -0.00104x - 4.15\")\n# Check \"periods\" of energy : theoretically they are ≈2π/1.1648.\n# Each period in the energy is materialized by 2 bumps.\nperiod = 2π / 1.1648\nstart = 9.5\nnbperiods = [5, 10, 15]\nvline!([start], ls=:dash, label=\"Period reference\", c=\"black\")\nfor p=nbperiods\n  vline!([start + p.*period], ls=:dash, label=\"After $p periods\", c=\"grey\")\nend\n\nplot!(legend=:bottomright)"},{"id":357,"pagetitle":"Vlasov-HMF","title":"$k_x = 0.2, v_0 = 3.0$","ref":"/vlasov-solvers/dev/vlasov-hmf/#k_x-0.2,-v_0-3.0","content":" $k_x = 0.2, v_0 = 3.0$ import VlasovSolvers: advection!\n\ndev = CPU()\nnsteps = 500\ndt = 0.1\n\nϵ = 0.001\nkx = 0.2\nv0 = 3.0\n# For this set of parameters the expected damping coefficient is +0.2845.\n\nmesh1 = OneDGrid(dev, 64, 0, 2π / kx)\nmesh2 = OneDGrid(dev, 128, -10, 10)\n\nn1, delta1 = mesh1.len, mesh1.step\nn2, delta2 = mesh2.len, mesh2.step\nx, v = mesh1.points, mesh2.points'\n\nftsi  = zeros(Complex{Float64}, (n1,n2))\nftsiᵗ  = zeros(Complex{Float64}, (n2,n1))\n\n@.  ftsi =  (exp(- 0.5 * (v-v0)^2) + exp(-0.5 * (v+v0)^2)) * (1 + ϵ * cos(kx*x)) / (2*√(2π))\ntranspose!(ftsiᵗ, ftsi)\n\nEtsi = Array{Float64}(undef, nsteps)\n\nex = zeros(Float64,n1)\nhmf_poisson!(ftsiᵗ, mesh1, mesh2, ex)\nadvection!(ftsiᵗ, mesh2, ex, 0.5dt)\n\n\nfor n in 1:nsteps\n    Etsi[n] = sqrt(sum(ex.^2) * mesh1.step)\n\n    advection!(ftsi, mesh1, v, dt)\n    transpose!(ftsiᵗ, ftsi)\n    hmf_poisson!(ftsiᵗ, mesh1, mesh2, ex)\n    advection!(ftsiᵗ, mesh2, ex, dt)\n    transpose!(ftsi, ftsiᵗ)\nend t = range(0., stop=nsteps*dt, length=nsteps) |> collect\n\nplot(t, log.(Etsi), xlabel = \"t\", minorgrid=true, label=\"log(E(t))\")\nplot!(x-> 0.2845x - 6.2, label=\"y = 0.2845x - 6.2\")"},{"id":358,"pagetitle":"Vlasov-HMF","title":"Conclusion","ref":"/vlasov-solvers/dev/vlasov-hmf/#Conclusion","content":" Conclusion We illustrated the fact that the Vlasov-HMF equations is a toy model that exhibits a behavior very close to the Vlasov-Poisson system. "},{"id":361,"pagetitle":"Vlasov-Poisson","title":"Vlasov-Poisson","ref":"/vlasov-solvers/dev/vlasov-poisson/#Vlasov-Poisson","content":" Vlasov-Poisson We consider the dimensionless Vlasov-Poisson equation for one species with a neutralizing background. \\[\\frac{\\partial f}{\\partial t}+ v\\cdot \\nabla_x f + E(t,x) \\cdot \\nabla_v f = 0,\\] \\[- \\Delta \\phi = 1 - \\rho, E = - \\nabla \\phi\\] \\[\\rho(t,x)  =  \\int f(t,x,v)dv.\\] Vlasov Equation - Wikipedia"},{"id":362,"pagetitle":"Vlasov-Poisson","title":"Input parameters","ref":"/vlasov-solvers/dev/vlasov-poisson/#Input-parameters","content":" Input parameters using VlasovSolvers, Plots\n\ndev = CPU()                  # device\nnx, nv = 64, 64              # grid resolution\nstepper = StrangSplitting()  # timestepper\ndt = 0.1                     # timestep\nnsteps = 1000                # total number of time-steps\n\nxmin, xmax = 0, 4π           # X Domain length (m)\nvmin, vmax = -6, 6           # V Domain length (m)\nα  = 0.001                   # Perturbation amplitude\nkx = 0.5                     # Wave number of perturbation 0.5"},{"id":363,"pagetitle":"Vlasov-Poisson","title":"Simulation with BSpline interpolation","ref":"/vlasov-solvers/dev/vlasov-poisson/#Simulation-with-BSpline-interpolation","content":" Simulation with BSpline interpolation xgrid = OneDGrid(dev, nx, xmin, xmax)\nvgrid = OneDGrid(dev, nv, vmin, vmax)\n\nf = DistributionFunction( xgrid, vgrid )\n\nlandau!(f, α, kx)\n\nprob = VlasovProblem(f, BSLSpline(5), dev)\n\nsol = solve(prob, stepper, dt, nsteps )\n\nt = sol.times\n\nplot(sol; label = \"E\")\nplot!(t, -0.1533*t.-5.50; label=\"-0.1533t.-5.5\")"},{"id":364,"pagetitle":"Vlasov-Poisson","title":"Simulation with Lagrange interpolation","ref":"/vlasov-solvers/dev/vlasov-poisson/#Simulation-with-Lagrange-interpolation","content":" Simulation with Lagrange interpolation landau!(f, α, kx)\n\nprob = VlasovProblem(f, BSLLagrange(9), dev)\n\nsol = solve(prob, stepper, dt, nsteps )\n\nt = sol.times\n\nplot(sol; label = \"E\")\nplot!(t, -0.1533*t.-5.50; label=\"-0.1533t.-5.5\")"},{"id":367,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"One Reduced Scalar Spin Vlasov-Maxwell","ref":"/scalar-spin/dev/#One-Reduced-Scalar-Spin-Vlasov-Maxwell","content":" One Reduced Scalar Spin Vlasov-Maxwell"},{"id":368,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Spin Vlasov-Maxwell equations","ref":"/scalar-spin/dev/#Spin-Vlasov-Maxwell-equations","content":" Spin Vlasov-Maxwell equations The dimensionless non-relativistic spin Vlasov-Maxwell system is"},{"id":369,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Vlasov equation","ref":"/scalar-spin/dev/#vlasov","content":" Vlasov equation \\[\\begin{equation}\n\\label{eq:Vlasovn}\n\\frac{\\partial f}{\\partial t}+{\\bf v}\\cdot\\frac{\\partial f}{\\partial{\\bf x}}+[\\left({\\bf E}+{\\bf v}\\times{\\bf B}\\right) - \\nabla({\\bf s} \\cdot {\\bf B})]\\cdot\\frac{\\partial f}{\\partial{\\bf v}} - ({\\bf s}\\times {\\bf B}) \\cdot \\frac{\\partial f}{\\partial {\\bf s}} = 0, \n\\end{equation}\\] \\[\\begin{gather}\n\\frac{\\partial{\\bf E}}{\\partial t}  =  \\nabla\\times{\\bf B}-{\\bf J}, \\label{eq:MaxwellEn} \\\\\n\\frac{\\partial{\\bf B}}{\\partial t}  =  - \\nabla\\times{\\bf E} \\label{eq:MaxwellBn}  \\\\\n\\nabla\\cdot{\\bf E}  = \\rho-1, \\label{eq:divEn} \\\\\n\\nabla\\cdot{\\bf B}  = 0 \\label{eq:divBn}\n\\end{gather}\\] with  \\[{\\bf J}({\\bf x}, t) =\\int_{\\mathbb{R}^3\\times \\mathbb{R}^3} {\\bf v}f({\\bf x}, {\\bf v},{\\bf s}, t) \\mathrm{d}{\\bf v}\\mathrm{d}{\\bf s} - \\nabla \\times {\\bf M}({\\bf x}, t),\\] \\[{\\bf M}({\\bf x}, t) = \\int_{\\mathbb{R}^3\\times \\mathbb{R}^3} {\\bf s}f({\\bf x}, {\\bf v},{\\bf s}, t) \\mathrm{d}{\\bf v}\\mathrm{d}{\\bf s},\\] \\[\\rho({\\bf x}, t)=\\int_{\\mathbb{R}^3} f({\\bf x}, {\\bf v},{\\bf s}, t) \\mathrm{d}{\\bf v}\\mathrm{d}{\\bf s},\\] $\\nabla$  here represents the gradient about  ${\\bf x}$ . Denote  $\\mathcal{M}$  the infinite dimensional manifold  $\\left\\{(f, {\\bf E},{\\bf B})|\\, \\nabla\\cdot{\\bf B}=0\\right\\}$ . Spin Vlasov-Maxwell system can be expressed with the Poisson bracket  [1]  in the purpose of   using the idea of geometric numerical integration [3] . For  two functionals  $\\mathcal{F}$  and  $\\mathcal{G}$  defined on  ${\\mathcal M}$ ,  we introduce  the  Poisson bracket presented in  [1] . \\[\\begin{align}\\label{eq:MMWB}\n\\begin{split}\n\\{\\mathcal{F},\\mathcal{G}\\} &= \\{\\mathcal{F}, \\mathcal{G}\\}_{VM} + \\{ \\mathcal{F}, \\mathcal{G}\\}_{s}\\\\\n&=\n\\int_{\\Omega} f\\left[\\frac{\\delta\\mathcal{F}}{\\delta f},\\frac{\\delta\\mathcal{G}}\n{\\delta f}\\right]_{\\mathbf{xv}}\\mathrm{d}\\mathbf{x}\\mathrm{d}\\mathbf{v}d\\mathbf{s}\n  +\\int_{\\Omega} \\left(\\frac{\\delta\\mathcal{F}}{\\delta\\mathbf{E}}\\cdot\\frac{\\partial f}{\\partial\\mathbf{v}}\\frac{\\delta\\mathcal{G}}{\\delta f}-\\frac{\\delta\\mathcal{G}}{\\delta\\mathbf{E}}\\cdot\\frac{\\partial f}{\\partial\\mathbf{v}}\\frac{\\delta\\mathcal{F}}{\\delta f}\\right)\\mathrm{d}\\mathbf{x}\\mathrm{d}\\mathbf{v}\\mathrm{d}\\mathbf{s}\\\\\n  &+\\int_{\\Omega_{\\bf x}}\\left(\\frac{\\delta\\mathcal{F}}{\\delta\\mathbf{E}}\\cdot\\left(\\triangledown\\times\\frac{\\delta\\mathcal{G}}{\\delta\\mathbf{B}}\\right)\n          -\\frac{\\delta\\mathcal{G}}{\\delta\\mathbf{E}}\\cdot\n \\left(\\triangledown\\times\\frac{\\delta\\mathcal{F}}{\\delta\\mathbf{B}}\\right)\\right)\\mathrm{d}\\mathbf{x}\\\\\n &+\\int_{\\Omega} f{\\bf B}\\cdot\\left(\\frac{\\partial}{\\partial\\mathbf{v}}\\frac{\\delta\\mathbf{\\mathrm{\\mathcal{F}}}}{\\delta f}\\times\\frac{\\partial}{\\partial\\mathbf{v}}\\frac{\\delta\\mathcal{G}}{\\delta f}\\right)\\mathrm{d}\\mathbf{x}\\mathrm{d}\\mathbf{v}\\mathrm{d}\\mathbf{s} + \\{ \\mathcal{F}, \\mathcal{G}\\}_{s},\n \\end{split}\n\\end{align}\\] \\[\\{ \\mathcal{F}, \\mathcal{G}\\}_{s} = \\int_{\\Omega} f{\\bf s} \\cdot (\\frac{\\partial }{\\partial {\\bf s}}\\frac{\\delta \\mathcal{F}}{\\delta f} \\times \\frac{\\partial }{\\partial {\\bf s}} \\frac{\\delta \\mathcal{G}}{\\delta f})\\mathrm{d}\\mathbf{x}\\mathrm{d}\\mathbf{v}\\mathrm{d}\\mathbf{s}.\\] Here,  $\\left[\\cdot,\\cdot\\right] _{\\mathbf{xv}}$  denotes the Lie bracket for  two functions of  $\\left({\\bf x},{\\bf v}\\right)$ . It has been proved in  [1]  that the bracket(\\ref{eq:MMWB}) is Poisson. With  the  Hamiltonian functional defined  by \\[\\begin{equation}\n\\mathcal{H}(f,\\mathbf{E},\\mathbf{B})=\\frac{1}{2}\\int_{\\Omega} \\mathbf{v}{}^{2}fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}+\\int_{\\Omega} {\\bf s}\\cdot {\\bf B} fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}+ \\frac{1}{2}\\int_{\\Omega_{\\bf x}}\n\\left( |\\mathbf{E}|^{2}+|\\mathbf{B}|^{2}\\right)d\\mathbf{x}\\label{eq:HamiltonVM}\n\\end{equation}\\] the spin Vlasov-Maxwell system of equations (\\ref{eq:Vlasovn}-\\ref{eq:MaxwellBn})  is equivalent to \\[\\begin{equation}\n \\frac{\\partial{\\mathcal Z}}{\\partial t}=\\{\\mathcal{Z},\\mathcal{H}\\},\\label{eq:PoissonVM}\n\\end{equation}\\] where  $\\mathcal{Z}\\in \\mathcal{M}$ ."},{"id":370,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Hamiltonian splitting method","ref":"/scalar-spin/dev/#Hamiltonian-splitting-method","content":" Hamiltonian splitting method As in paper  [4] , we here adopt Hamiltonian splitting method to the spin Vlasov-Maxwell equations. Hamiltonian is split into 8 parts as follows, \\[\\begin{align}\n\\mathcal{H}(f,\\mathbf{E},\\mathbf{B})&=\\frac{1}{2}\\int_{\\Omega} {v}_1^{2}fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}+\\frac{1}{2}\\int_{\\Omega} {v}_2^{2}fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}+\\frac{1}{2}\\int_{\\Omega} {v}_3^{2}fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}\\\\\n&+\\int_{\\Omega} {s_1}\\cdot {B_1} fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}+ \\int_{\\Omega} {s_2}\\cdot {B_2} fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}+\n\\int_{\\Omega} {s_3}\\cdot {B_3} fd\\mathbf{x}d\\mathbf{v}d\\mathbf{s}\\\\\n&+\\frac{1}{2}\\int_{\\Omega_{\\bf x}}\n |\\mathbf{E}|^{2}d\\mathbf{x} + \\frac{1}{2}\\int_{\\Omega_{\\bf x}}\n |\\mathbf{B}|^{2}d\\mathbf{x}\\\\\n &=: H_{1f}+H_{2f}+H_{3f} + H_{s1}+H_{s2}+H_{s3}+H_E+H_B.\n\\end{align}\\] The subsystem corresponding to  $H_{s1}$  is as follows. \\[\\begin{align}\n&\\frac{\\partial f}{\\partial t} -  \\nabla_x (s_1 B_1) \\cdot \\frac{\\partial f}{\\partial {\\bf v}}-s_3B_1 \\frac{\\partial f }{\\partial s_2} + s_2B_1\\frac{\\partial f}{\\partial s_3} = 0\\\\\n&\\frac{\\partial {\\bf E}}{\\partial t} = \\nabla_x \\times \\int {\\bf a} f d{\\bf v}d{\\bf s}\\\\\n&\\frac{\\partial {\\bf B}}{\\partial t} = 0,\n\\end{align}\\] where  ${\\bf a} = (s_1, 0 , 0)^{T}$ ."},{"id":371,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Reduced spin Vlasov-Maxwell equations","ref":"/scalar-spin/dev/#Reduced-spin-Vlasov-Maxwell-equations","content":" Reduced spin Vlasov-Maxwell equations Here we reduce the system (\\ref{eq:Vlasovn})-(\\ref{eq:divBn}) by the similar manner in  [5] .  The reduced spin Vlasov–Maxwell system is \\[\\begin{equation}\n\\begin{aligned}\n&\\frac{\\partial f}{\\partial t} + p \\frac{\\partial f}{\\partial x} + [ E_x - s_2 \\frac{\\partial^2 A_z}{\\partial x^2} + s_3 \\frac{\\partial^2 A_y}{\\partial x^2}  - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x} ]\\frac{\\partial f}{\\partial p}  + [s_3 \\frac{\\partial A_z}{\\partial x} + s_2 \\frac{\\partial A_y}{\\partial x}, -s_1 \\frac{\\partial A_y}{\\partial x}, -s_1 \\frac{\\partial A_z}{\\partial x} ] \\cdot \\frac{\\partial f}{\\partial {\\mathbf s}} = 0,\\\\\n&\\frac{\\partial E_x}{\\partial x} = -\\int p f  \\mathrm{d}\\mathrm{p}\\mathrm{d}\\mathrm{\\mathbf s},\\\\\n&\\frac{\\partial E_y}{\\partial t} = - \\frac{\\partial^2 A_y}{\\partial x^2} + A_y \\int  f  \\mathrm{d}\\mathrm{p}\\mathrm{d}\\mathrm{\\mathbf s} + \\int s_3 \\frac{\\partial f}{\\partial x}\\mathrm{d}\\mathrm{p}\\mathrm{d}\\mathrm{\\mathbf s},\\\\\n&\\frac{\\partial E_z}{\\partial t} = - \\frac{\\partial^2 A_z}{\\partial x^2} + A_z \\int  f  \\mathrm{d}\\mathrm{p}\\mathrm{d}\\mathrm{\\mathbf s} - \\int s_2 \\frac{\\partial f}{\\partial x}\\mathrm{d}\\mathrm{p}\\mathrm{d}\\mathrm{\\mathbf s},\\\\\n& \\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} = - {\\mathbf E}_\\perp,\\\\\n&\\frac{\\partial E_x}{\\partial t} = \\int f \\mathrm{d}\\mathrm{p}\\mathrm{d}\\mathrm{\\mathbf s} - 1.\n\\end{aligned}\n\\label{eq:reduced}\n\\end{equation}\\] Particle distribution function is   $f(x, p, {\\mathbf s}, t)$ ,  $x, p$  are scalars,  ${\\mathbf s} \\in \\mathbb{R}^3$ ,  ${\\mathbf E} = (E_x, {\\mathbf E}_\\perp) = (E_x, E_y, E_z)$ , and  ${\\mathbf A} = (A_x, {\\mathbf A}_\\perp) = (0, A_y, A_z)$ . This reduced spin Vlasov-Maxwell system can be expressed with one Poisson  bracket as follows. For any two functionals  $\\mathcal{F}$ , and  $\\mathcal{G}$  depend on  $f, {\\mathbf E}$ , and  ${\\mathbf A}_\\perp$ , we have \\[\\begin{equation}\n\\begin{aligned}\n\\{ \\mathcal{F}, \\mathcal{G}\\} &= \\int_{\\Omega} f\\left[\\frac{\\delta\\mathcal{F}}{\\delta f},\\frac{\\delta\\mathcal{G}}\n{\\delta f}\\right]_{{xp}}\\mathrm{d}{x}\\mathrm{d}{p}\\mathrm{d}\\mathbf{s}\n  +\\int_{\\Omega} \\left(\\frac{\\delta\\mathcal{F}}{\\delta {E_x}}\\frac{\\partial f}{\\partial {p}}\\frac{\\delta\\mathcal{G}}{\\delta f}-\\frac{\\delta\\mathcal{G}}{\\delta {E_x}}\\frac{\\partial f}{\\partial {p}}\\frac{\\delta\\mathcal{F}}{\\delta f}\\right)\\mathrm{d}{x}\\mathrm{d}{p}\\mathrm{d}\\mathbf{s}\\\\\n&+ \\int_{\\Omega} \\left( \\frac{\\delta \\mathcal{G}}{\\delta {\\mathbf A}_\\perp} \\cdot  \\frac{\\delta \\mathcal{F}}{\\delta {\\mathbf E}_\\perp} - \\frac{\\delta \\mathcal{F}}{\\delta {\\mathbf A}_\\perp} \\cdot  \\frac{\\delta \\mathcal{G}}{\\delta {\\mathbf E}_\\perp}\\right) \\mathrm{d}x + \\int_{\\Omega} f {\\mathbf s}\\cdot \\left( \\frac{\\partial}{\\partial {\\mathbf s}}\\frac{\\delta \\mathcal{F}}{\\delta {f}} \\times \\frac{\\partial}{\\partial {\\mathbf s}}\\frac{\\delta \\mathcal{G}}{\\delta {f}} \\right) \\mathrm{d}x\\mathrm{d}p\\mathrm{d}{\\mathbf s}.\n\\end{aligned}\n\\label{eq:poisson}\n\\end{equation}\\] With the Hamiltonian functional defined by  \\[\\begin{equation}\n\\begin{aligned}\n\\mathcal{H}(f, {\\mathbf E}, {\\mathbf A}_\\perp) &= \\frac{1}{2}\\int_{\\Omega} p^2 f \\mathrm{d}x\\mathrm{d}p\\mathrm{d}{\\mathbf s} + \\frac{1}{2}\\int_{\\Omega}|{\\mathbf A}_\\perp|^2 f \\mathrm{d}x\\mathrm{d}p\\mathrm{d}{\\mathbf s}\\\\\n& + \\frac{1}{2}\\int_{\\Omega_x} |{\\mathbf E}|^2 + |\\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}|^2 \\mathrm{d}x + \\int_{\\Omega} \\left( - s_2 \\frac{\\partial A_z}{\\partial x} + s_3 \\frac{\\partial A_y}{\\partial x} \\right) f \\mathrm{d}x\\mathrm{d}p\\mathrm{d}{\\mathbf s},\n\\end{aligned}\n\\end{equation} \\] the reduced spin Vlasov-Maxwell system of equations (\\ref{eq:reduced}) is equivalent to  $\\frac{\\partial \\mathcal{Z}}{\\partial t} = \\{ \\mathcal{Z}, \\mathcal{H} \\}.$"},{"id":372,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"GEMPIC framework applied to reduced spin Vlasov system.","ref":"/scalar-spin/dev/#GEMPIC-framework-applied-to-reduced-spin-Vlasov-system.","content":" GEMPIC framework applied to reduced spin Vlasov system. We consider the components of the electromagnetic fields separately and we have that  $E_x$  is a 1-form,  $E_y, E_z, A_y, A_z$  are 0-forms. There is a commuting diagram for involved function spaces in one spatial dimension with continuous spaces in the upper line and discrete subspaces in the lower line. The connection between the two sequences is made by the projectors  $\\Pi_0$  and  $\\Pi_1$ . The basis for each of the finite dimensional spaces  $V_0, V_1$ , with dim  $V_k = N_k$  is denoted by  $\\{ \\Lambda^0_I\\}_{I=1,\\cdots,N_0}$ , and  $\\{ \\Lambda^1_I\\}_{I=1,\\cdots,N_1}$ . The dual bases of  $V_0$  and  $V_1$  are  $\\{\\Sigma^0_I\\}_{I=1,\\cdots, N_0}$ , and  $\\{\\Sigma^1_I\\}_{I=1,\\cdots, N_1}$  respectively, i.e.,   $\\int_{\\Omega_x} \\Sigma^k_I \\Lambda^k_J \\mathrm{d}x = \\delta_{IJ}, k = 0, 1$ .  $\\frac{\\mathrm{d}}{\\mathrm{d} x}$  is a linear operator, i.e.,  \\[\\frac{\\mathrm{d}}{\\mathrm{d} x}: V_0 \\rightarrow V_1.\\] Operator  $\\frac{\\mathrm{d}}{\\mathrm{d} x}$  can be expressed by a matrix  $\\mathbb{C}$ : \\[\\frac{\\mathrm{d}}{\\mathrm{d} x} \\left(\\Lambda^0_1, \\cdots, \\Lambda^0_{N_0} \\right)  = \\left(\\Lambda^1_1, \\cdots, \\Lambda^1_{N_1} \\right) \\mathbb{C}_{N_1 N_0}.\\]"},{"id":373,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"B-splines","ref":"/scalar-spin/dev/#B-splines","content":" B-splines Assume  $\\Omega_x = [0, L]$ , and there is one equidistant grid on  $\\Omega_x$ , \\[x_j = (j-1)\\Delta x, \\Delta x = L/M, j = 1, \\cdots, M.\\] We can choose the following  $\\{\\Lambda^0_I\\}_{I=1,\\cdots,N_0}$ , and  $\\{\\Lambda^1_I\\}_{I=1,\\cdots, N_1}$  as the basis functions for  $V_0$ , and  $V_1$  respectively. \\[\\begin{align}\n\\Lambda^0_j = N_j^3(x) = \\frac{1}{6} \\left\\{ \n\\begin{aligned}\n&\\left(2 - \\frac{|x - x_{j+2}|}{\\Delta x} \\right)^3, \\quad 1 \\le \\frac{|x-x_{j+2}|}{\\Delta x} \\le 2,\\\\\n&4 - 6 \\left(\\frac{|x-x_{j+2}|}{\\Delta x}\\right)^2 + 3 \\left( \\frac{|x-x_{j+2}|}{\\Delta x}\\right)^3, \\quad 0 \\le \\frac{|x-x_{j+2}|}{\\Delta x} \\le 1,\\\\\n&0, \\quad \\text{otherwise.}\n\\end{aligned}\n\\right.\n\\end{align}\\] \\[\\begin{align}\n\\Lambda^1_j = N_j^2(x) = \\frac{1}{2} \\left\\{ \n\\begin{aligned}\n&\\left(\\frac{x - x_j}{\\Delta x} \\right)^2, \\quad 0 \\le \\frac{x-x_j}{\\Delta x} \\le 1,\\\\\n& - 2 \\left(\\frac{x-x_j}{\\Delta x}\\right)^2 + 6 \\left( \\frac{x-x_j}{\\Delta x}\\right) - 3, \\quad 1 \\le \\frac{x-x_j}{\\Delta x} \\le 2,\\\\\n& (3 - \\frac{x-x_j}{\\Delta x})^2, \\quad 2 \\le \\frac{x-x_j}{\\Delta x} \\le 3,\\\\\n&0, \\quad \\text{otherwise.}\n\\end{aligned}\n\\right.\n\\end{align}\\] There is one relation between  $\\Lambda^k, k = 0, 1$ , \\[\\frac{\\mathrm{d}}{\\mathrm{d}x} N^3_j(x) = \\frac{1}{\\Delta x}\\left(N^2_j(x) - N^2_{j+1}(x)  \\right),\\] which gives  \\[\\begin{equation}\n\\mathbb{C} = \\frac{1}{\\Delta x}\n\\begin{aligned}\n\\left(\n\\begin{matrix}\n     1  & 0  & 0 & 0& \\cdots & 0 & -1\\\\\n     -1 & 1 & 0 & 0& \\cdots & 0 & 0\\\\\n     0  & -1 & 1 & 0& \\cdots& 0 & 0\\\\\n     0  & 0  & \\ddots &\\ddots &\\ddots & \\vdots & \\vdots\\\\\n      \\vdots & \\vdots & \\ddots & \\ddots & \\ddots &\\ddots & \\vdots\\\\\n     \\vdots & \\vdots & \\vdots & \\ddots & \\ddots& \\ddots &0\\\\\n     0 & 0 & 0 & \\cdots & 0& -1 & 1\n\\end{matrix}\n\\right)\n\\end{aligned}\n\\end{equation}\\]"},{"id":374,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Notations","ref":"/scalar-spin/dev/#Notations","content":" Notations Before deriving the discretization of functional derivatives, we introduce several notations which will make the formulas simpler. \\[\\begin{align}\n\\begin{aligned}\n& \\mathbb{R}^k({\\mathbf{X}})_{N_p N_k} = \n\\left(\n\\begin{matrix}\n     \\Lambda^k_1(x_1)  & \\cdots  & \\Lambda^k_{N_k}(x_1) \\\\\n     \\Lambda^k_1(x_2)  & \\cdots  & \\Lambda^k_{N_k}(x_2) \\\\\n      \\vdots  & \\vdots  & \\vdots \\\\\n       \\Lambda^k_1(x_{N_p})  & \\cdots  & \\Lambda^k_{N_k}(x_{N_p})\n      \\end{matrix}\n\\right), k = 0, 1.\\\\\n&\\mathbb{M}^k({\\mathbf{X}})_{N_k N_k} = \n\\left(\n\\begin{matrix}\n     \\int \\Lambda^k_1(x)\\Lambda^k_1(x)\\mathrm{d}x  & \\cdots  & \\int \\Lambda^k_1(x)\\Lambda^k_{N_k}(x)\\mathrm{d}x \\\\\n     \\int \\Lambda^k_2(x)\\Lambda^k_1(x)\\mathrm{d}x  & \\cdots  & \\int \\Lambda^k_2(x)\\Lambda^k_{N_k}(x)\\mathrm{d}x \\\\\n      \\vdots  & \\vdots  & \\vdots \\\\\n      \\int \\Lambda^k_{N_k}(x)\\Lambda^k_{1}(x)\\mathrm{d}x  & \\cdots  & \\int \\Lambda^k_{N_k}(x)\\Lambda^k_{N_k}(x)\\mathrm{d}x\n      \\end{matrix}\n\\right), k = 0, 1.\\\\\n&\\mathbb{N}^k({x_a})_{N_k N_k} = \n\\left(\n\\begin{matrix}\n      \\Lambda^k_1(x_a)\\Lambda^k_1(x_a)  & \\cdots  & \\Lambda^k_1(x_a)\\Lambda^k_{N_k}(x_a) \\\\\n      \\Lambda^k_2(x_a)\\Lambda^k_1(x_a)  & \\cdots  &  \\Lambda^k_2(x_a)\\Lambda^k_{N_k}(x_a) \\\\\n      \\vdots  & \\vdots  & \\vdots \\\\\n       \\Lambda^k_{N_k}(x_a)\\Lambda^k_{1}(x_a)  & \\cdots  &  \\Lambda^k_{N_k}(x_a)\\Lambda^k_{N_k}(x_a)\n      \\end{matrix}\n\\right), k = 0, 1.\\\\\n&\\mathbb{M}_{p, N_p N_p} = \n\\text{diag}(\\omega_1, \\cdots, \\omega_{N_p}), \\mathbb{S}_{3N_p 3N_p} = \\text{diag}(\\mathbb{S}_1, \\cdots, \\mathbb{S}_{N_p}),\\\\\n&\\mathbb{S}_a = \\frac{1}{\\omega_a}\n\\left(\n\\begin{matrix}\n     0 & s_{a,3}  & -s_{a,2} \\\\\n      -s_{a,3}  & 0  & s_{a,1} \\\\\n      s_{a,2}  & -s_{a,1}  & 0 \n      \\end{matrix}\n\\right), \\\\\n&{\\Lambda^k{(x_a)}} = (\\Lambda^k_1(x_a), \\cdots, \\Lambda^k_{N_k}(x_a))^{\\mathrm{T}}, k = 1, 2.\\\\\n&{\\mathbf{X}} = (x_1, \\cdots, x_{N_p})^{\\mathrm{T}},\\\\\n&{\\mathbf{P}} = (p_1, \\cdots, p_{N_p})^{\\mathrm{T}},\\\\\n&{\\mathbf{S}} = (s_{1,1}, s_{1,2}, s_{1,3} \\cdots, s_{a,1}, s_{a,2}, s_{a,3}, \\cdots, s_{N_p,1}, s_{N_p,2}, s_{N_p,3})^{\\mathrm{T}},\\\\\n&{\\mathbf{S}}_1 = (s_{1,1}, \\cdots, s_{a,1}, \\cdots, s_{N_p,1})^{\\mathrm{T}},\\\\\n&{\\mathbf{S}}_2 = (s_{1,2}, \\cdots, s_{a,2}, \\cdots, s_{N_p,2})^{\\mathrm{T}},\\\\\n&{\\mathbf{S}}_3 = (s_{1,3}, \\cdots, s_{a,3}, \\cdots, s_{N_p,3})^{\\mathrm{T}},\\\\\n&{\\mathbf{e}}_x = (e_{x,1}, \\cdots, e_{x,N_1})^{\\mathrm{T}},\\\\\n&{\\mathbf{e}}_y = (e_{y,1}, \\cdots, e_{y,N_0})^{\\mathrm{T}},\\\\\n&{\\mathbf{e}}_z = (e_{z,1}, \\cdots, e_{z,N_0})^{\\mathrm{T}},\\\\\n&{\\mathbf{a}}_y = (a_{y,1}, \\cdots, a_{y,N_0})^{\\mathrm{T}},\\\\\n&{\\mathbf{a}}_z = (a_{z,1}, \\cdots, a_{z,N_0})^{\\mathrm{T}}.\n\\end{aligned}\n\\end{align}\\]"},{"id":375,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Discretization of the functional derivatives","ref":"/scalar-spin/dev/#Discretization-of-the-functional-derivatives","content":" Discretization of the functional derivatives As  $E_{x, h} = \\sum_{I=1}^{N_1}e_{x,I}\\Lambda_{I}^1(x)$ , any functional  $\\mathcal{F}[E_{x,h}]$  can be considered as a function  $F({\\mathbf e}_x)$  of the finite element coefficients,  \\[\\mathcal{F}[E_{x,h}] = F({\\mathbf{e}}_x).\\] From  [2] , we know that  \\[\\begin{equation}\n\\frac{\\delta \\mathcal{F}[E_{x,h}]}{\\delta E_x} = \\sum_{I=1}^{N_1} \\frac{\\partial F ({\\mathbf e}_x)}{\\partial e_{x,I}}\\Sigma_I^1(x) = \\sum_{I,J=1}^{N_1}\\frac{\\partial F ({\\mathbf e}_x)}{\\partial e_{x,I}} (\\mathbb{M}_1)^{-1}_{IJ}\\Lambda_J^1(x).\n\\end{equation}\\] Similarly, we have \\[\\begin{equation}\n\\begin{aligned}\n\\frac{\\delta \\mathcal{F}[E_{y,h}]}{\\delta E_y} = \\sum_{I=1}^{N_0} \\frac{\\partial F ({\\mathbf e}_y)}{\\partial e_{y,I}}\\Sigma_I^0(x) = \\sum_{I,J=1}^{N_0}\\frac{\\partial F ({\\mathbf e}_y)}{\\partial e_{y,I}} (\\mathbb{M}_0)^{-1}_{IJ}\\Lambda_J^0(x),\\\\\n\\frac{\\delta \\mathcal{F}[E_{z,h}]}{\\delta E_z} = \\sum_{I=1}^{N_0} \\frac{\\partial F ({\\mathbf e}_z)}{\\partial e_{z,I}}\\Sigma_I^0(x) = \\sum_{I,J=1}^{N_0}\\frac{\\partial F ({\\mathbf e}_z)}{\\partial e_{z,I}} (\\mathbb{M}_0)^{-1}_{IJ}\\Lambda_J^0(x),\\\\\\frac{\\delta \\mathcal{F}[A_{y,h}]}{\\delta A_y} = \\sum_{I=1}^{N_0} \\frac{\\partial F ({\\mathbf a}_y)}{\\partial a_{y,I}}\\Sigma_I^0(x) = \\sum_{I,J=1}^{N_0}\\frac{\\partial F ({\\mathbf a}_y)}{\\partial a_{y,I}} (\\mathbb{M}_0)^{-1}_{IJ}\\Lambda_J^0(x),\\\\\n\\frac{\\delta \\mathcal{F}[A_{z,h}]}{\\delta A_z} = \\sum_{I=1}^{N_0} \\frac{\\partial F ({\\mathbf a}_z)}{\\partial a_{z,I}}\\Sigma_I^0(x) = \\sum_{I,J=1}^{N_0}\\frac{\\partial F ({\\mathbf a}_z)}{\\partial a_{z,I}} (\\mathbb{M}_0)^{-1}_{IJ}\\Lambda_J^0(x).\n\\end{aligned}\n\\end{equation}\\] We assume a particle-like distribution function for  $N_p$  particles labelled by  a,  \\[f_h(x,p,{\\mathbf s}, t) = \\sum_{a=1}^{N_p}\\omega_a \\delta(x-x_a(t))\\delta(p-p_a(t))\\delta({\\mathbf s}-{\\mathbf s}_a(t)).\\] One functional of the distribution function,  $\\mathcal{F}[f]$  can be considered as a function of the particle phase space trajectories,  $F({\\mathbf{X}}, {\\mathbf{P}}, {\\mathbf{S}})$ . From  [2] , we know that  \\[\\frac{\\partial F}{\\partial x_a} = \\omega_a \\frac{\\partial}{\\partial x}\\frac{\\delta \\mathcal{F}}{\\delta f}|_(x_a, p_a, {\\mathbf s}_a), \\frac{\\partial F}{\\partial p_a} = \\omega_a \\frac{\\partial}{\\partial p}\\frac{\\delta \\mathcal{F}}{\\delta f}|_(x_a, p_a, {\\mathbf s}_a), \\frac{\\partial F}{\\partial {\\mathbf s}_a} = \\omega_a \\frac{\\partial}{\\partial {\\mathbf s}_a}\\frac{\\delta \\mathcal{F}}{\\delta f}|_(x_a, p_a, {\\mathbf s}_a).\\]"},{"id":376,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"Discrete Poisson bracket","ref":"/scalar-spin/dev/#Discrete-Poisson-bracket","content":" Discrete Poisson bracket Substituting the variational derivatives in last subsection into (\\ref{eq:poisson}) gives the following discrete Poisson bracket, \\[\\begin{equation}\\label{eq:dis}\n\\{ F, G \\} = \\left( \\nabla_{\\mathbf u}F\\right)^{\\mathrm{T}} \\mathbb{J}({\\mathbf u})\\nabla_{\\mathbf u}G,\n\\end{equation}\\] where  ${\\mathbf u} = ({\\mathbf X}, {\\mathbf P}, {\\mathbf S}, {\\mathbf e}_x, {\\mathbf e}_y, {\\mathbf e}_z, {\\mathbf a}_y, {\\mathbf a}_z)^{\\mathrm{T}}$ . The matrix  $\\mathbb{J}$  is \\[\\begin{align}\\label{eq:dispoisson}\n\\begin{aligned}\n& \\mathbb{J}({\\mathbf{u}}) = \n\\left(\n\\begin{matrix}\n    {\\mathbf{0}} & {\\mathbb{M}}_p^{-1}  &{\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}}& {\\mathbf{0}}  & {\\mathbf{0}}\\\\\n     -{\\mathbb{M}}_p^{-1}  &{\\mathbf{0}}   & {\\mathbf{0}} & \\mathbb{R}^1({\\mathbf {X}})\\mathbb{M}_1^{-1} & {\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}}\\\\\n      {\\mathbf{0}}  & {\\mathbf{0}}  & \\mathbb{S} & {\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}} & {\\mathbf{0}} \\\\\n       {\\mathbf{0}}  & -{\\mathbb{M}}_1^{-1}\\mathbb{R}^1({\\mathbf{X}})^{\\mathrm{T}}  & {\\mathbf{0}} & {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}\\\\\n       {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}& {\\mathbf{0}}&{\\mathbb{M}}_0^{-1}&{\\mathbf{0}}\\\\\n       {\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}& {\\mathbb{M}}_0^{-1}\\\\\n       {\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&-{\\mathbb{M}}_0^{-1}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}\\\\\n       {\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&{\\mathbf{0}}&-{\\mathbb{M}}_0^{-1}&{\\mathbf{0}}&{\\mathbf{0}}\n      \\end{matrix}\n\\right).\n\\end{aligned}\n\\end{align}\\] The above bracket (\\ref{eq:dis})-(\\ref{eq:dispoisson}) is a Poisson bracket. From the definition of Poisson bracket, we only need to verify the following identity, \\[\\begin{equation}\\label{eq:jacobi}\n\\sum_{l}\\left( \\frac{\\partial \\mathbb{J}_{ij}({\\mathbf u})}{\\partial u_{l}}\\mathbb{J}_{lk} +  \\frac{\\partial \\mathbb{J}_{jk}({\\mathbf u})}{\\partial u_{l}}\\mathbb{J}_{li} +  \\frac{\\partial \\mathbb{J}_{ki}({\\mathbf u})}{\\partial u_{l}}\\mathbb{J}_{lj}\\right) = 0, \\text{for all}\\ ,  i, j, k. \n\\end{equation}\\] As the Poisson matrix  $\\mathbb{J}$  depends only on  ${\\mathbf X}$ , we only need to sum  $l$  over  $1 \\le l \\le N_p$ . It is easy to check that we only need to consider the cases that two of  $i,j,k \\in \\mathbb{Z}$  lie in  $[N_p+1, 2N_p]$ , and the other one lies in  $[5N_p+1,  5N_p+N_1]$ . We take the case that   $N_p+1 \\le i,j \\le 2N_p$  and  $5N_p+1 \\le k \\le 5N_p+N_1$  for example. In this case, Eq.(\\ref{eq:jacobi}) becomes  \\[\\sum_{l=1}^{N_p}\\left(  \\frac{\\partial \\mathbb{J}_{jk}({\\mathbf u})}{\\partial u_{l}}\\mathbb{J}_{li} +  \\frac{\\partial \\mathbb{J}_{ki}({\\mathbf u})}{\\partial u_{l}}\\mathbb{J}_{lj}\\right) = 0.\\] As  $\\mathbb{J}_{jk}$  in the above depends only on  $x_{j-N_p}$ ,  $\\mathbb{J}_{ki}$  depends only on  $x_{i-N_p}$ , the left hand side of the above identity becomes  \\[\\begin{equation}\\label{eq:final}\n \\frac{\\partial \\mathbb{J}_{jk}({\\mathbf u})}{\\partial u_{j-N_p}}\\mathbb{J}_{(j-N_p)i} +  \\frac{\\partial \\mathbb{J}_{ki}({\\mathbf u})}{\\partial u_{i-N_p}}\\mathbb{J}_{(i-N_p)j}.\n\\end{equation}\\] When  $i\\neq j$ ,  $\\mathbb{J}_{(j-N_p)i}  = 0$ , and  $\\mathbb{J}_{(i-N_p)j} = 0$ , then Eq.(\\ref{eq:final}) is zero. When  $i = j$ , we have  $\\mathbb{J}_{(j-N_p)i}  =  \\mathbb{J}_{(i-N_p)j}$ , and  $\\frac{\\partial \\mathbb{J}_{jk}({\\mathbf u})}{\\partial u_{j-N_p}} = -\\frac{\\partial \\mathbb{J}_{ki}({\\mathbf u})}{\\partial u_{i-N_p}}$ , then Eq.(\\ref{eq:final}) is also zero. Then the proof is finished. Discrete Hamiltonian is  \\[\\begin{equation}\n\\begin{aligned}\nH({\\mathbf u}) &= \\frac{1}{2}\\int p^2 \\sum_{a=1}^{N_p} \\omega_a \\delta(x-x_a) \\delta(p-p_a) \\delta({\\mathbf s}-{\\mathbf s}_a) \\mathrm{d}x\\mathrm{d}p\\mathrm{d}{\\mathbf s}\\\\\n&+\\frac{1}{2}\\int \\sum_{a=1}^{N_p}\\left( |\\sum_{I=1}^{N_p}a_{y,I}\\Lambda^0_{I}(x)|^2  + |\\sum_{I=1}^{N_p}a_{z,I}\\Lambda^0_{I}(x)|^2 \\right)\\omega_a \\delta(x-x_a)\\delta(p-p_a)\\delta({\\mathbf s}-{\\mathbf s}_a) \\mathrm{d}x \\mathrm{d}p \\mathrm{d}{\\mathbf s}\\\\\n&+ \\frac{1}{2}\\int |\\sum_{I=1}^{N_1}e_{x,I}\\Lambda^1_{I}(x)|^2  \\mathrm{d}x+\\frac{1}{2}\\int \\left(|\\sum_{I=1}^{N_0}e_{y,I}\\Lambda^0_{I}(x)|^2+ |\\sum_{I=1}^{N_0}e_{z,I}\\Lambda^0_{I}(x)|^2\\right)  \\mathrm{d}x\\\\\n&+\\frac{1}{2}\\int | \\frac{\\mathrm{d}}{\\mathrm{d}x}  \\sum_{a=1}^{N_0} a_{y,I}\\Lambda^0_{I}(x)|^2 \\mathrm{d}x+\\frac{1}{2}\\int | \\frac{\\mathrm{d}}{\\mathrm{d}x}  \\sum_{a=1}^{N_0} a_{z,I}\\Lambda^0_{I}(x)|^2 \\mathrm{d}x\\\\\n&+\\int \\sum_{a=1}^{N_p}\\left(s_2 \\frac{\\mathrm{d}}{\\mathrm{d}x} \\sum_{I=1}^{N_0}a_{z,I}\\Lambda^0_I(x)  - s_3  \\frac{\\mathrm{d}}{\\mathrm{d}x}  \\sum_{I=1}^{N_0}a_{y,I}\\Lambda^0_I(x)\\right)\\omega_a \\delta(x-x_a)\\delta(p-p_a) \\delta({\\mathbf s}-{\\mathbf s}_a)\\mathrm{d}x\\mathrm{d}p\\mathrm{d}{\\mathbf s},\n\\end{aligned}\n\\end{equation}\\] which in matrix form becomes \\[\\begin{equation}\n\\begin{aligned}\nH&= \\frac{1}{2}{\\mathbf P}^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf P} + \\frac{1}{2}\\sum_{a=1}^{N_p}\\omega_a{\\mathbf a}_y^{\\mathrm{T}}\\mathbb{N}^0(x_a){\\mathbf a}_y + \\frac{1}{2}\\sum_{a=1}^{N_p}\\omega_a{\\mathbf a}_z^{\\mathrm{T}}\\mathbb{N}^0(x_a){\\mathbf a}_z \\\\\n& + \\frac{1}{2}{\\mathbf e}_x^{\\mathrm{T}}\\mathbb{M}_1{\\mathbf e}_x +\\frac{1}{2}{\\mathbf e}_y^{\\mathrm{T}}\\mathbb{M}_0{\\mathbf e}_y +  \\frac{1}{2}{\\mathbf e}_z^{\\mathrm{T}}\\mathbb{M}_0{\\mathbf e}_z +  \\frac{1}{2}{\\mathbf a}_y^{\\mathrm{T}} \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_y+  \\frac{1}{2}{\\mathbf a}_z^{\\mathrm{T}} \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_z\\\\\n&+ {\\mathbf a}_z^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}\\mathbb{R}^1({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf S}_2 - {\\mathbf a}_y^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}\\mathbb{R}^1({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf S}_3.\n\\end{aligned}\n\\end{equation}\\] If you want to read more about Vlasov–Maxwell equations for laser-plasma interaction, see  [6] ."},{"id":377,"pagetitle":"One Reduced Scalar Spin Vlasov-Maxwell","title":"References","ref":"/scalar-spin/dev/#References","content":" References 1 Marklund M , Morrison P J. (2011) \"Gauge-free Hamiltonian structure of the spin Maxwell-Vlasov equations,\"  Physics Letters A , 375(24):2362-2365. 2 Kraus M , Kormann K , Morrison P , et al. (2017) \"GEMPIC: geometric electromagnetic particle-in-cell methods,\"  Journal of Plasma Physics , 83(04):905830401. 3 E. Hairer, C. Lubich, and G.Wanner. (2002) \"Geometric Numerical Integration: Structure-Preserving Algorithms for Ordinary Differential Equations\" ( Springer , New York). 4 Crouseilles N , Einkemmer L , Faou E. (2015) \"Hamiltonian splitting for the Vlasov-Maxwell equations\".  Journal of Computational Physics , 283:224-240. 5 Huot F, Ghizzo A, Bertrand P, et al. (2003) \"Instability of the time splitting scheme for the one-dimensional and relativistic Vlasov–Maxwell system,\"  Journal of Computational Physics , 185(2): 512-531. 6 Li Y, Sun Y, Crouseilles N. (2019) \"Numerical simulations of one laser-plasma model based on Poisson structure,\"  Journal of Computational Physics , 109172."},{"id":380,"pagetitle":"Contents","title":"Contents","ref":"/scalar-spin/dev/contents/#Contents","content":" Contents Contents Index Diagnostics Distributions Paper example Hamiltonian splitting Subsystem corresponding to  $H_p$ Subsystem corresponding to  $H_A$ Subsystem corresponding to  $H_s$ Subsystem corresponding to  $H_E$ One Reduced Scalar Spin Vlasov-Maxwell Spin Vlasov-Maxwell equations Hamiltonian splitting method Reduced spin Vlasov-Maxwell equations GEMPIC framework applied to reduced spin Vlasov system. Discrete Poisson bracket References Particle group Particle-Mesh coupling Particle sampling Quickstart Import packages Physics parameters Initialize mesh Initialize particles Initialize Maxwell solver"},{"id":381,"pagetitle":"Contents","title":"Index","ref":"/scalar-spin/dev/contents/#Index","content":" Index SpinGEMPIC.CosGaussianParams SpinGEMPIC.CosSumGaussian SpinGEMPIC.HamiltonianSplitting SpinGEMPIC.ParticleGroup SpinGEMPIC.ParticleMeshCoupling SpinGEMPIC.TimeHistoryDiagnostics SpinGEMPIC.add_charge! SpinGEMPIC.add_current_update_v! SpinGEMPIC.eval_v_density SpinGEMPIC.eval_x_density SpinGEMPIC.evaluate SpinGEMPIC.get_charge SpinGEMPIC.get_mass SpinGEMPIC.get_s1 SpinGEMPIC.get_s2 SpinGEMPIC.get_s3 SpinGEMPIC.get_v SpinGEMPIC.get_weights SpinGEMPIC.get_x SpinGEMPIC.operatorHA SpinGEMPIC.operatorHE SpinGEMPIC.operatorHp SpinGEMPIC.operatorHs SpinGEMPIC.pic_diagnostics_transfer SpinGEMPIC.sample! SpinGEMPIC.sample_quietstart! SpinGEMPIC.sample_weighted! SpinGEMPIC.set_common_weight SpinGEMPIC.set_s1 SpinGEMPIC.set_s2 SpinGEMPIC.set_s3 SpinGEMPIC.set_v SpinGEMPIC.set_weights SpinGEMPIC.set_x SpinGEMPIC.solve_poisson! SpinGEMPIC.strang_splitting! SpinGEMPIC.update_jv!"},{"id":384,"pagetitle":"Diagnostics","title":"Diagnostics","ref":"/scalar-spin/dev/diagnostics/#Diagnostics","content":" Diagnostics"},{"id":385,"pagetitle":"Diagnostics","title":"SpinGEMPIC.TimeHistoryDiagnostics","ref":"/scalar-spin/dev/diagnostics/#SpinGEMPIC.TimeHistoryDiagnostics","content":" SpinGEMPIC.TimeHistoryDiagnostics  —  Type TimeHistoryDiagnostics( maxwell_solver, kernel_smoother_0, kernel_smoother_1 ) Context to save and plot diagnostics maxwell_solver  : Maxwell solver kernel_smoother_0  : Mesh coupling operator kernel_smoother_1  : Mesh coupling operator data  : DataFrame containing time history values Outputs KineticEnergy:  $\\frac{1}{2} \\sum \\omega_i v_i^2$ Kineticspi: Zeeman energy Momentums: compute integrals of f  Momentum1 :  $\\sum x_i  \\omega_i$ Momentum2 :  $\\sum x_i  \\omega_i  s1$ Momentum3 :  $\\sum x_i  \\omega_i  s2$ Momentum4 :  $\\sum x_i  \\omega_i  s3$ Momentum5 :  $\\sum \\omega_i  s1$ Momentum6 :  $\\sum \\omega_i  s2$ Momentum7 :  $\\sum \\omega_i  s3$ Momentum8 :  $A_y \\sum div(\\rho)  \\omega_i s2 + A_z div(\\rho) \\omega_i s3$ Momentum9 :   $- A_y div(\\rho) \\omega_i s1$ Momentum10 :  $- A_z div(\\rho) \\omega_i s1$ PotentialEnergyE1 :  $\\frac{1}{2} E_x^2$ PotentialEnergyE2 :  $\\frac{1}{2} E_y^2$ PotentialEnergyE3 :  $\\frac{1}{2} E_z^2$ PotentialEnergyB2 :  $\\frac{1}{2} B_y^2$ PotentialEnergyB3 :  $\\frac{1}{2} B_z^2$ Transfer :  $\\sum (v_i \\cdot e_{x,i}) w_i$ ErrorPoisson : difference between  $E_x$  computed with Maxwell Solver et  $E_x$  computed from charge source"},{"id":386,"pagetitle":"Diagnostics","title":"SpinGEMPIC.pic_diagnostics_transfer","ref":"/scalar-spin/dev/diagnostics/#SpinGEMPIC.pic_diagnostics_transfer-NTuple{4, Any}","content":" SpinGEMPIC.pic_diagnostics_transfer  —  Method pic_diagnostics_transfer( particle_group, kernel_smoother_0, \n                        kernel_smoother_1, efield_dofs, transfer) Compute  $\\sum_{particles} w_p ( v_1,p e_1(x_p) + v_2,p e_2(x_p))$ particle_group kernel_smoother_0   : Kernel smoother (order p+1) kernel_smoother_1   : Kernel smoother (order p)    efield_dofs  : coefficients of efield source"},{"id":387,"pagetitle":"Diagnostics","title":"SpinGEMPIC.solve_poisson!","ref":"/scalar-spin/dev/diagnostics/#SpinGEMPIC.solve_poisson!-Tuple{Vector{Float64}, ParticleGroup, ParticleMeshCoupling, GEMPIC.Maxwell1DFEM, Vector{Float64}}","content":" SpinGEMPIC.solve_poisson!  —  Method solve poisson!( efield, particle group, kernel smoother, maxwell solver, rho ) Accumulate rho and solve Poisson particle_group  : Particles maxwell_solver  : Maxwell solver (FEM 1D) kernel_smoother_0  : Particle-Mesh method rho  : preallocated array for Charge density efield_dofs  : spline coefficients of electric field (1D) source"},{"id":390,"pagetitle":"Distributions","title":"Distributions","ref":"/scalar-spin/dev/distributions/#Distributions","content":" Distributions"},{"id":391,"pagetitle":"Distributions","title":"SpinGEMPIC.CosGaussianParams","ref":"/scalar-spin/dev/distributions/#SpinGEMPIC.CosGaussianParams","content":" SpinGEMPIC.CosGaussianParams  —  Type CosGaussianParams( dims, k, α, σ, μ, δ ) Parameters of a distribution with is a product of a Cosine  distribution along x and a Normal distribution along v. n_gaussians  : Number of Gaussians n_cos        : Number of cosines normal       : Normalization constant of each Gaussian source"},{"id":392,"pagetitle":"Distributions","title":"SpinGEMPIC.CosSumGaussian","ref":"/scalar-spin/dev/distributions/#SpinGEMPIC.CosSumGaussian","content":" SpinGEMPIC.CosSumGaussian  —  Type CosSumGaussian{D,V}( n_cos, n_gaussians, k, α, σ, μ, δ ) Data type for parameters of initial distribution \\[(1+ \\cos( \\sum^{n_{cos}}_{i=1} k_i x)) \n\\cdot \n\\sum_{j=1}^{n_{gaussians}} \n\\delta_j \n\\exp \\big( -\\frac{1}{2} \n\\frac{(v-\\mu_j)^2}{\\sigma_j^2} \\big)\\] Parameters k  : values of the wave numbers (one array for each cosines) α  : strength of perturbations σ  : variance of the Gaussian (one velocity vector for each gaussian). μ  : mean value of the Gaussian (one velocity vector for each gaussian). δ  : portion of each Gaussian  Example \\[f(x,v_1,v_2)=\\frac{1}{2\\pi\\sigma_1\\sigma_2} \\exp \\Big( - \\frac{1}{2}\n\\big( \\frac{v_1^2}{\\sigma_1^2} + \\frac{v_2^2}{\\sigma_2^2} \\big) \n\\Big) ( 1 + \\alpha \\cos(kx)),\\] df = CosSumGaussian{1,1,3}([[k]],[α], [[σ₁,σ₂]], [[μ₁,μ₂]]) source"},{"id":393,"pagetitle":"Distributions","title":"SpinGEMPIC.eval_v_density","ref":"/scalar-spin/dev/distributions/#SpinGEMPIC.eval_v_density-Tuple{SpinGEMPIC.AbstractCosGaussian, Union{Float64, Vector{Float64}}}","content":" SpinGEMPIC.eval_v_density  —  Method eval_v_density( f, v ) evaluate the normal part of the distribution function source"},{"id":394,"pagetitle":"Distributions","title":"SpinGEMPIC.eval_x_density","ref":"/scalar-spin/dev/distributions/#SpinGEMPIC.eval_x_density-Tuple{CosSumGaussian, Union{Float64, Vector{Float64}}}","content":" SpinGEMPIC.eval_x_density  —  Method eval_x_density( f, x ) evaluate the cosine part of the distribution function source"},{"id":397,"pagetitle":"Paper example","title":"Paper example","ref":"/scalar-spin/dev/example/#Paper-example","content":" Paper example Test corresponding to Fig. 4 of the  paper using Plots\nusing Random\nusing SpinGEMPIC\n\nimport GEMPIC: OneDGrid, Maxwell1DFEM\nimport GEMPIC: l2projection!\n\nfunction run_simulation( steps, Δt)\n\n    σ, μ = 0.17, 0.0\n    kx, α = 1.22, 0.02\n\n    xmin, xmax = 0, 4pi/kx\n    domain = [xmin, xmax, xmax - xmin]\n    nx = 128\n    n_particles = 20000\n    mesh = OneDGrid( xmin, xmax, nx)\n    spline_degree = 3\n\n    df = CosGaussian(kx, α, σ, μ )\n\n    rng = MersenneTwister(123)\n    mass, charge = 1.0, 1.0\n\n    particle_group = ParticleGroup( n_particles, mass, charge, 1)\n    sample!(rng, particle_group, df, mesh, method = :quietstart)\n\n    kernel_smoother2 = ParticleMeshCoupling( mesh, n_particles, spline_degree-2)\n    kernel_smoother1 = ParticleMeshCoupling( mesh, n_particles, spline_degree-1)\n    kernel_smoother0 = ParticleMeshCoupling( mesh, n_particles, spline_degree)\n\n    maxwell_solver = Maxwell1DFEM(mesh, spline_degree)\n\n    rho = zeros(nx)\n    efield_poisson = zeros(nx)\n\n    solve_poisson!( efield_poisson, particle_group, kernel_smoother0, maxwell_solver, rho )\n\n    k0 = 2*kx\n    E0 = 0.325\n    ww = 2.63\n    Ey(x) = E0*cos(k0*x)\n    Ez(x) = E0*sin(k0*x)\n    Ay(x) = -E0/ww*sin(k0*x)\n    Az(x) = E0/ww*cos(k0*x)\n\n    efield_dofs = [ zeros(nx), zeros(nx), zeros(nx)]\n    efield_dofs[1] .= efield_poisson\n    afield_dofs = [zeros(nx), zeros(nx)]\n\n    l2projection!( efield_dofs[2], maxwell_solver, Ey, spline_degree)\n    l2projection!( efield_dofs[3], maxwell_solver, Ez, spline_degree)\n    l2projection!( afield_dofs[1], maxwell_solver, Ay, spline_degree)\n    l2projection!( afield_dofs[2], maxwell_solver, Az, spline_degree)\n\n    propagator = HamiltonianSplitting( maxwell_solver,\n                                       kernel_smoother0,\n                                       kernel_smoother1,\n                                       kernel_smoother2,\n                                       efield_dofs,\n                                       afield_dofs,\n                                       domain);\n\n    thdiag = TimeHistoryDiagnostics( maxwell_solver,\n                            kernel_smoother0, kernel_smoother1 )\n\n    write_step!(thdiag, 0.0, spline_degree,\n                        efield_dofs,  afield_dofs,\n                        efield_poisson,\n                        propagator, particle_group)\n\n    for j = 1:steps # loop over time\n\n        strang_splitting!(propagator, particle_group, Δt, 1)\n\n        write_step!(thdiag, j * Δt, spline_degree,\n                        efield_dofs,  afield_dofs,\n                        efield_poisson,\n                        propagator, particle_group)\n\n    end\n\n    return thdiag\n\nend\n\nsteps, Δt = 200, 0.05\n\nthdiag = run_simulation(steps, Δt)\n\ntime = thdiag.data[!, :Time]\nenergy = thdiag.data[!, :PotentialEnergyE1]\nplot( time, 0.5*log.(energy.^2), xlabel = \"time\", ylabel = \"Ex energy\", label = \"\")"},{"id":400,"pagetitle":"Hamiltonian splitting","title":"Hamiltonian splitting","ref":"/scalar-spin/dev/hamiltonian_splitting/#Hamiltonian-splitting","content":" Hamiltonian splitting"},{"id":401,"pagetitle":"Hamiltonian splitting","title":"SpinGEMPIC.HamiltonianSplitting","ref":"/scalar-spin/dev/hamiltonian_splitting/#SpinGEMPIC.HamiltonianSplitting","content":" SpinGEMPIC.HamiltonianSplitting  —  Type HamiltonianSplitting( maxwell_solver,\n                      kernel_smoother_0, kernel_smoother_1,\n                      kernel_smoother_2,\n                      particle_group, e_dofs, a_dofs, domain) Hamiltonian splitting type for Vlasov-Maxwell Integral over the spline function on each interval (order p+1) Integral over the spline function on each interval (order p) e_dofs  describing the two components of the electric field b_dofs  describing the magnetic field j_dofs  for kernel representation of current density.  source"},{"id":402,"pagetitle":"Hamiltonian splitting","title":"SpinGEMPIC.strang_splitting!","ref":"/scalar-spin/dev/hamiltonian_splitting/#SpinGEMPIC.strang_splitting!-Tuple{HamiltonianSplitting, ParticleGroup, Float64, Int64}","content":" SpinGEMPIC.strang_splitting!  —  Method strang_splitting( h, pg, dt, number_steps) Strang splitting time splitting object  time step number of time steps source"},{"id":403,"pagetitle":"Hamiltonian splitting","title":"Subsystem corresponding to  $H_p$","ref":"/scalar-spin/dev/hamiltonian_splitting/#Subsystem-corresponding-to-H_p","content":" Subsystem corresponding to  $H_p$ \\[H_p = \\frac{1}{2}{\\mathbf P}^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf P}\\]"},{"id":404,"pagetitle":"Hamiltonian splitting","title":"SpinGEMPIC.operatorHp","ref":"/scalar-spin/dev/hamiltonian_splitting/#SpinGEMPIC.operatorHp","content":" SpinGEMPIC.operatorHp  —  Function operatorHp(h, particle_group, dt) \\[\\begin{aligned}\n\\dot{x} & =p \\\\\n\\dot{E}_x & = - \\int (p f ) dp ds\n\\end{aligned}\\] source \\[\\begin{equation}\n\\begin{aligned}\n&\\dot{\\mathbf X} = {\\mathbf P},\\\\\n&\\dot{\\mathbf P} = {\\mathbf 0},\\\\\n&\\dot{\\mathbf S} = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_x = -\\mathbb{M}_1^{-1}\\mathbb{R}^1({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf P}\\\\\n&\\dot{\\mathbf e}_y = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_z = {\\mathbf 0},\\\\\n&\\dot{\\mathbf a}_y = {\\mathbf 0},\\\\\n&\\dot{\\mathbf a}_z = {\\mathbf 0}.\n\\end{aligned}\n\\end{equation}\\] For this subsystem, we only need to compute  ${\\mathbf X}, {\\mathbf{e}}_x$ . \\[\\begin{equation}\n\\begin{aligned}\n&{\\mathbf X}(t) = {\\mathbf X}(0) + t {\\mathbf P}(0),\\\\\n&\\mathbb{M}_1{\\mathbf{e}}_x(t) = \\mathbb{M}_1{\\mathbf{e}}_x(0) - \\int_0^t \\mathbb{R}^1({\\mathbf X}(\\tau))^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf P}\\mathrm{d}\\tau.\n\\end{aligned}\n\\end{equation}\\]"},{"id":405,"pagetitle":"Hamiltonian splitting","title":"Subsystem corresponding to  $H_A$","ref":"/scalar-spin/dev/hamiltonian_splitting/#Subsystem-corresponding-to-H_A","content":" Subsystem corresponding to  $H_A$"},{"id":406,"pagetitle":"Hamiltonian splitting","title":"SpinGEMPIC.operatorHA","ref":"/scalar-spin/dev/hamiltonian_splitting/#SpinGEMPIC.operatorHA","content":" SpinGEMPIC.operatorHA  —  Function operatorHA(h, particle_group, dt) \\[\\begin{aligned}\n\\dot{p} = (A_y, A_z) \\cdot \\partial_x (A_y, A_z)   \\\\\n\\dot{Ey} = -\\partial_x^2 A_y + A_y \\rho \\\\\n\\dot{Ez} = -\\partial_x^2 A_z + A_z \\rho \\\\\n\\end{aligned}\\] source \\[H_A = \\frac{1}{2}\\sum_{a=1}^{N_p}\\omega_a{\\mathbf a_y}^{\\mathrm{T}}\\mathbb{N}^0(x_a){\\mathbf a}_y + \\sum_{a=1}^{N_p}\\omega_a{\\mathbf a_z}^{\\mathrm{T}}\\mathbb{N}^0(x_a){\\mathbf a}_z + \\frac{1}{2}{\\mathbf a_y}^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}{\\mathbb{M}}_1\\mathbb{C}{\\mathbf a}_y\n+ \\frac{1}{2}{\\mathbf a_z}^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}{\\mathbb{M}}_1\\mathbb{C}{\\mathbf a}_z.\\] \\[\\begin{equation}\n\\begin{aligned}\n&\\dot{\\mathbf X} = {\\mathbf 0},\\\\\n&\\dot{\\mathbf P}  = \\mathbb{M}_p^{-1}\\frac{\\partial H_A}{\\partial {\\mathbf X}},\\\\\n&\\dot{\\mathbf S} = {\\mathbf  0},\\\\\n&\\dot{\\mathbf e}_x = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_y = \\mathbb{M}_0^{-1}\\left(\\sum_{a=1}^{N_p}\\omega_a\\mathbb{N}^0(x_a){\\mathbf a}_y + \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_y  \\right),\\\\\n&\\dot{\\mathbf e}_z = \\mathbb{M}_0^{-1}\\left(\\sum_{a=1}^{N_p}\\omega_a\\mathbb{N}^0(x_a){\\mathbf a}_z + \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_z  \\right),\\\\\n&\\dot{\\mathbf a}_y=  {\\mathbf 0},\\\\\n&\\dot{\\mathbf a}_z=  {\\mathbf 0}.\n\\end{aligned}\n\\end{equation}\\] In this subsystem,  ${\\mathbf X}, {\\mathbf S}, {\\mathbf e}_x, {\\mathbf a}_y, {\\mathbf a}_z$  stay unchanged along the time. As for  ${\\mathbf P}$ , we have  \\[\\begin{equation}\n\\begin{aligned}\n{p_a}(t) &= {p_a}(0) + t \\frac{1}{\\omega_a}\\left( \\frac{1}{2}\\omega_a {\\mathbf a}_y^{\\mathrm{T}}\\frac{\\partial }{\\partial x_a}\\mathbb{N}^0(x_a){\\mathbf a}_y  + \\frac{1}{2}\\omega_a {\\mathbf a}_z^{\\mathrm{T}}\\frac{\\partial }{\\partial x_a}\\mathbb{N}^0(x_a){\\mathbf a}_z\\right),\\\\\n&= p_a(0) + t \\left( \\frac{1}{2} {\\mathbf a}_y^{\\mathrm{T}}\\frac{\\partial }{\\partial x_a}\\mathbb{N}^0(x_a){\\mathbf a}_y  + \\frac{1}{2} {\\mathbf a}_z^{\\mathrm{T}}\\frac{\\partial }{\\partial x_a}\\mathbb{N}^0(x_a){\\mathbf a}_z\\right),\\\\\n& = p_a(0) + \\frac{t}{2}   {\\mathbf a}_y^{\\mathrm{T}}(\\frac{\\partial}{\\partial x_a}\\Lambda^0(x_a) \\Lambda^0(x_a)^{\\mathrm{T}}  + \\Lambda^0(x_a) \\frac{\\partial}{\\partial x_a}\\Lambda^0(x_a)^{\\mathrm{T}}  ){\\mathbf a}_y,\\\\\n&+ \\frac{t}{2} {\\mathbf a}_z^{\\mathrm{T}}(\\frac{\\partial}{\\partial x_a}\\Lambda^0(x_a) \\Lambda^0(x_a)^{\\mathrm{T}}  + \\Lambda^0(x_a) \\frac{\\partial}{\\partial x_a}\\Lambda^0(x_a)^{\\mathrm{T}}  ){\\mathbf a}_z.\n\\end{aligned}\n\\end{equation}\\] \\[\\begin{equation}\n\\begin{aligned}\n\\mathbb{M}_0{\\mathbf e}_y(t) &= \\mathbb{M}_0{\\mathbf e}_y(0)  + t\\left(\\sum_{a=1}^{N_p}\\omega_a\\mathbb{N}^0(x_a){\\mathbf a}_y + \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_y  \\right),\\\\\n& = \\mathbb{M}_0{\\mathbf e}_y(0)  + t\\left(\\sum_{a=1}^{N_p}\\omega_a\\Lambda^0(x_a)\\Lambda^0(x_a)^{\\mathrm{T}}{\\mathbf a}_y + \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_y  \\right).\n\\end{aligned}\n\\end{equation}\\] \\[\\begin{equation}\n\\begin{aligned}\n\\mathbb{M}_0{\\mathbf e}_z(t) &= \\mathbb{M}_0{\\mathbf e}_z(0)  + t\\left(\\sum_{a=1}^{N_p}\\omega_a\\mathbb{N}^0(x_a){\\mathbf a}_z + \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_z  \\right),\\\\\n& = \\mathbb{M}_0{\\mathbf e}_z(0)  + t\\left(\\sum_{a=1}^{N_p}\\omega_a\\Lambda^0(x_a)\\Lambda^0(x_a)^{\\mathrm{T}}{\\mathbf a}_z + \\mathbb{C}^{\\mathrm{T}}\\mathbb{M}_1\\mathbb{C}{\\mathbf a}_z  \\right).\n\\end{aligned}\n\\end{equation}\\] Note that in the above, we use the identity  \\[\\mathbb{N}^0(x_a) = \\Lambda^0(x_a) \\Lambda^0(x_a)^{\\mathrm{T}},\\] and  \\[\\frac{\\mathrm{d}}{\\mathrm{d}x}\\mathbb{N}^0(x_a)  =  \\frac{\\partial}{\\partial x_a}\\Lambda^0(x_a) \\Lambda^0(x_a)^{\\mathrm{T}}  + \\Lambda^0(x_a) \\frac{\\partial}{\\partial x_a}\\Lambda^0(x_a)^{\\mathrm{T}},\\] which reduces the computational cost."},{"id":407,"pagetitle":"Hamiltonian splitting","title":"Subsystem corresponding to  $H_s$","ref":"/scalar-spin/dev/hamiltonian_splitting/#Subsystem-corresponding-to-H_s","content":" Subsystem corresponding to  $H_s$"},{"id":408,"pagetitle":"Hamiltonian splitting","title":"SpinGEMPIC.operatorHs","ref":"/scalar-spin/dev/hamiltonian_splitting/#SpinGEMPIC.operatorHs","content":" SpinGEMPIC.operatorHs  —  Function operatorHs(h, particle_group, dt) Push H_s: Equations to be solved \\[\\begin{aligned}\n\\dot{s} &= s x B = (s_y \\partial_x A_y +s_z \\partial_x Az, -s_x \\partial_x A_y, -s_x \\partial_x A_z)  \\\\\n\\dot{p} &= s \\cdot \\partial_x B = -s_y \\partial^2_{x} A_z + s_z \\partial^2_{x} A_y \\\\\n\\dot{E}_y &=   HH \\int (s_z \\partial_x f) dp ds \\\\\n\\dot{E}_z &= - HH \\int (s_y \\partial_x f) dp ds \n\\end{aligned}\\] source \\[H_s = {\\mathbf a}_z^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}{\\mathbb{R}}^1({\\mathbf{X}})^{\\mathrm{T}}\\mathbb{M}_p {\\mathbf S}_2 -{\\mathbf a}_y^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}{\\mathbb{R}}^1({\\mathbf{X}})^{\\mathrm{T}}\\mathbb{M}_p {\\mathbf S}_3\\] is \\[\\begin{equation}\n\\begin{aligned}\n&\\dot{\\mathbf{X}} = {\\mathbf 0},\\\\\n&\\dot{\\mathbf P} = -\\mathbb{M}_p^{-1}\\frac{\\partial H_{s}}{\\partial {\\mathbf X}},\\\\\n&\\dot{\\mathbf S} = \\mathbb{S}\\frac{\\partial H_{s}}{\\partial {\\mathbf S}},\\\\\n&\\dot{\\mathbf e}_x = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_y = - \\mathbb{M}_0^{-1}\\mathbb{C}^{\\mathrm{T}}\\mathbb{R}^{1}({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf{S}}_3,\\\\\n&\\dot{\\mathbf e}_z = \\mathbb{M}_0^{-1}\\mathbb{C}^{\\mathrm{T}}\\mathbb{R}^{1}({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p{\\mathbf{S}}_2,\\\\\n&\\dot{a}_y = {\\mathbf 0},\\\\\n&\\dot{a}_z = {\\mathbf 0}.\n\\end{aligned}\n\\end{equation}\\] For this subsystem, we firstly solve  $\\dot{\\mathbf S} = \\mathbb{S}\\frac{\\partial H_{s}}{\\partial {\\mathbf S}}$ . For each particle, we have \\[\\begin{align}\n\\begin{aligned}\n\\dot{s}_a = \n& \\left(\n\\begin{matrix}\n    \\dot{s}_{a,1}  \\\\\n    \\dot{s}_{a,2}  \\\\\n      \\dot{s}_{a,3}  \n      \\end{matrix}\n\\right) = \n\\left(\n\\begin{matrix}\n    0 & Y& Z \\\\\n    -Y  & 0  & 0 \\\\\n      -Z & 0 &0 \n      \\end{matrix}\n\\right)\n \\left(\n\\begin{matrix}\n    {s}_{a,1}  \\\\\n    {s}_{a,2}  \\\\\n     {s}_{a,3}  \n      \\end{matrix}\n\\right) = \\hat{v} {\\mathbf s}_a,\n\\end{aligned}\n\\end{align}\\] where  $Y = {\\mathbf a}_y^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}R^1(x_a)$ ,  $Z = {\\mathbf a}_z^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}R^1(x_a)$ ,  $R^1(x_a) = (\\Lambda^1_1(x_a), \\cdots, \\Lambda^1_{N_1}(x_a))^{\\mathrm{T}}$ . Set a vector  ${\\mathbf v}  = (0, Z, -Y) \\in \\mathbb{R}^3$ . Then  \\[{\\mathbf s}_a(t) = \\exp(t\\hat{v}){\\mathbf s}_a(0) = \\left(I + \\frac{\\sin(t|{\\mathbf v}|)}{|\\mathbf {v}|}\\hat{v} + \\frac{1}{2}\\left( \\frac{\\sin(\\frac{t}{2}|{\\mathbf v}|)}{\\frac{|{\\mathbf v}|}{2}} \\right)^2 \\hat{v}^2\\right) {\\mathbf s}_a(0),\\] and \\[\\begin{equation}\n\\begin{aligned}\n\\int_0^t {\\mathbf s}_a(\\tau){\\mathrm{d}}\\tau= \\int_0^t \\exp(\\tau \\hat{v}){\\mathbf s}_a(0){\\mathrm{d}}\\tau = \\left(tI - \\frac{\\cos(t|{\\mathbf v}|)}{|{\\mathbf v}|^2} \\hat{v} + \\frac{1}{|{\\mathbf v}|^2} \\hat{v}  + \\frac{2}{|{\\mathbf v}|^2} \\left(\\frac{t}{2}-\\frac{\\sin(t|{\\mathbf v}|)}{2|{\\mathbf v}|}\\right)\\hat{v}^2\\right) {\\mathbf s}_a(0).\n\\end{aligned}\n\\end{equation}\\] Then we have  \\[\\begin{equation}\n\\begin{aligned}\n\\mathbb{M}_0 {\\mathbf e}_y(t) &= \\mathbb{M}_0 {\\mathbf e}_y(0) - \\mathbb{C}^{\\mathrm{T}}\\mathbb{R}^1({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p \\int_0^{t}{\\mathbf s}_{3}(\\tau)d\\tau,\\\\\n\\mathbb{M}_0 {\\mathbf e}_z(t) &= \\mathbb{M}_0 {\\mathbf e}_z(0) + \\mathbb{C}^{\\mathrm{T}}\\mathbb{R}^1({\\mathbf X})^{\\mathrm{T}}\\mathbb{M}_p \\int_0^{t}{\\mathbf s}_{2}(\\tau)d\\tau,\n\\end{aligned}\n\\end{equation}\\] and \\[\\begin{equation}\n\\begin{aligned}\np_a(t) = p_a(0) - {\\mathbf a}_z^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}\\frac{\\partial R^1(x_a)}{\\partial x_a}\\int_0^t s_{a,2}(\\tau)\\mathrm{d}\\tau +  {\\mathbf a}_y^{\\mathrm{T}}\\mathbb{C}^{\\mathrm{T}}\\frac{\\partial R^1(x_a)}{\\partial x_a}\\int_0^t s_{a,3}(\\tau)\\mathrm{d}\\tau\n\\end{aligned}\n\\end{equation}\\]"},{"id":409,"pagetitle":"Hamiltonian splitting","title":"Subsystem corresponding to  $H_E$","ref":"/scalar-spin/dev/hamiltonian_splitting/#Subsystem-corresponding-to-H_E","content":" Subsystem corresponding to  $H_E$"},{"id":410,"pagetitle":"Hamiltonian splitting","title":"SpinGEMPIC.operatorHE","ref":"/scalar-spin/dev/hamiltonian_splitting/#SpinGEMPIC.operatorHE","content":" SpinGEMPIC.operatorHE  —  Function operatorHE(h, particle_group, dt) \\[\\begin{aligned}\n\\dot{v}   & =  E_x \\\\\n\\dot{A}_y & = -E_y \\\\\n\\dot{A}_z & = -E_z\n\\end{aligned}\\] source \\[H_E = \\frac{1}{2}{\\mathbf e}_x^{\\mathrm{T}}\\mathbb{M}_1{\\mathbf e}_x + \\frac{1}{2}{\\mathbf e}_y^{\\mathrm{T}}\\mathbb{M}_0{\\mathbf e}_y + \\frac{1}{2}{\\mathbf e}_z^{\\mathrm{T}}\\mathbb{M}_0{\\mathbf e}_z\\] is, \\[\\begin{equation}\n\\begin{aligned}\n&\\dot{{\\mathbf X}} = {\\mathbf 0},\\\\\n&\\dot{\\mathbf P} = \\mathbb{R}^1({\\mathbf X}){\\mathbf e}_x,\\\\\n&\\dot{\\mathbf S} = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_x = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_y = {\\mathbf 0},\\\\\n&\\dot{\\mathbf e}_z = {\\mathbf 0},\\\\\n&\\dot{\\mathbf a}_y = -{\\mathbf e}_y,\\\\\n&\\dot{\\mathbf a}_z = -{\\mathbf e}_z.\\\\\n\\end{aligned}\n\\end{equation}\\] We only need to solve the equation about  ${\\mathbf P}$ , \\[\\begin{equation}\n{\\mathbf P}(t) = {\\mathbf P}(0) + t \\mathbb{R}^1({\\mathbf X}){\\mathbf e}_x. \n\\end{equation}\\]"},{"id":413,"pagetitle":"Particle group","title":"Particle group","ref":"/scalar-spin/dev/particle_group/#Particle-group","content":" Particle group"},{"id":414,"pagetitle":"Particle group","title":"SpinGEMPIC.ParticleGroup","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.ParticleGroup","content":" SpinGEMPIC.ParticleGroup  —  Type ParticleGroup( n_particles, charge, mass, n_weights) n_particles  : number of particles  charge       : charge of the particle species mass         : mass of the particle species n_weights    : number of differents weights source"},{"id":415,"pagetitle":"Particle group","title":"SpinGEMPIC.get_charge","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_charge-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_charge  —  Method get_charge( p, i; i_wi=1) Get charge of ith particle of p (q * particle_weight) source"},{"id":416,"pagetitle":"Particle group","title":"SpinGEMPIC.get_mass","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_mass-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_mass  —  Method get_mass( p, i; i_wi=1) Get mass of ith particle of p (m * particle_weight) source"},{"id":417,"pagetitle":"Particle group","title":"SpinGEMPIC.get_s1","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_s1-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_s1  —  Method get_s1( p, i ) Get s1 of ith particle of p source"},{"id":418,"pagetitle":"Particle group","title":"SpinGEMPIC.get_s2","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_s2-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_s2  —  Method get_s2( p, i ) Get s2 of ith particle of p source"},{"id":419,"pagetitle":"Particle group","title":"SpinGEMPIC.get_s3","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_s3-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_s3  —  Method get_s3( p, i ) Get velocity of ith particle of p source"},{"id":420,"pagetitle":"Particle group","title":"SpinGEMPIC.get_v","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_v-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_v  —  Method get_v( p, i ) Get velocity of ith particle of p source"},{"id":421,"pagetitle":"Particle group","title":"SpinGEMPIC.get_weights","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_weights-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_weights  —  Method get_weights( p, i) Get ith particle weights of group p source"},{"id":422,"pagetitle":"Particle group","title":"SpinGEMPIC.get_x","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.get_x-Tuple{ParticleGroup, Int64}","content":" SpinGEMPIC.get_x  —  Method get_x( p, i ) Get position of ith particle of p source"},{"id":423,"pagetitle":"Particle group","title":"SpinGEMPIC.set_common_weight","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_common_weight-Tuple{SpinGEMPIC.AbstractParticleGroup, Float64}","content":" SpinGEMPIC.set_common_weight  —  Method set_common_weight( p, x ) Set the common weight source"},{"id":424,"pagetitle":"Particle group","title":"SpinGEMPIC.set_s1","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_s1-Tuple{ParticleGroup, Int64, Float64}","content":" SpinGEMPIC.set_s1  —  Method set_s1( p, i, v) Set velocity of ith particle of p to v source"},{"id":425,"pagetitle":"Particle group","title":"SpinGEMPIC.set_s2","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_s2-Tuple{ParticleGroup, Int64, Float64}","content":" SpinGEMPIC.set_s2  —  Method set_s2( p, i, v) Set velocity of ith particle of p to v source"},{"id":426,"pagetitle":"Particle group","title":"SpinGEMPIC.set_s3","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_s3-Tuple{ParticleGroup, Int64, Float64}","content":" SpinGEMPIC.set_s3  —  Method set_s3( p, i, v) Set velocity of ith particle of p to v source"},{"id":427,"pagetitle":"Particle group","title":"SpinGEMPIC.set_v","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_v-Tuple{ParticleGroup, Int64, Float64}","content":" SpinGEMPIC.set_v  —  Method set_v( p, i, v) Set velocity of ith particle of p to v source"},{"id":428,"pagetitle":"Particle group","title":"SpinGEMPIC.set_weights","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_weights-Tuple{ParticleGroup, Int64, Float64}","content":" SpinGEMPIC.set_weights  —  Method set_weights( p, i, w) Set weights of particle @ i source"},{"id":429,"pagetitle":"Particle group","title":"SpinGEMPIC.set_x","ref":"/scalar-spin/dev/particle_group/#SpinGEMPIC.set_x-Tuple{ParticleGroup, Int64, Float64}","content":" SpinGEMPIC.set_x  —  Method set_x( p, i, x ) Set position of ith particle of p to x  source"},{"id":432,"pagetitle":"Particle-Mesh coupling","title":"Particle-Mesh coupling","ref":"/scalar-spin/dev/particle_mesh_coupling/#Particle-Mesh-coupling","content":" Particle-Mesh coupling"},{"id":433,"pagetitle":"Particle-Mesh coupling","title":"SpinGEMPIC.ParticleMeshCoupling","ref":"/scalar-spin/dev/particle_mesh_coupling/#SpinGEMPIC.ParticleMeshCoupling","content":" SpinGEMPIC.ParticleMeshCoupling  —  Type ParticleMeshCoupling( mesh,\n                      no_particles, spline_degree, \n                      smoothing_type ) Kernel smoother with splines of arbitrary degree placed on a uniform mesh. Spline with index i starts at point i delta_x  : Value of grid spacing along both directions. xmin, xmax, dimx  : Definition of the domain nx  : Array containing number ofpoints along each direction no_particles  : Number of particles of underlying PIC method  spline_degree  : Degree of smoothing kernel spline n_span  : Number of intervals where spline non zero (spline_degree + 1) scaling  : Scaling factor depending on whether :galerkin or :collocation n_quad_points  : Number of quadrature points spline_val : scratch data for spline evaluation spline_val_more  : more scratch data for spline evaluation quad_x, quad_w  : quadrature weights and points Note This version for Spin problem is very close to functions implemented in  GEMPIC.jl source"},{"id":434,"pagetitle":"Particle-Mesh coupling","title":"SpinGEMPIC.add_charge!","ref":"/scalar-spin/dev/particle_mesh_coupling/#SpinGEMPIC.add_charge!-Tuple{Vector{Float64}, ParticleMeshCoupling, Float64, Float64}","content":" SpinGEMPIC.add_charge!  —  Method add_charge!( rho, p, position, marker_charge) Add charge of one particle p              : kernel smoother object position       : Position of the particle marker_charge  : Particle weights time charge rho_dofs       : Coefficient vector of the charge distribution source"},{"id":435,"pagetitle":"Particle-Mesh coupling","title":"SpinGEMPIC.add_current_update_v!","ref":"/scalar-spin/dev/particle_mesh_coupling/#SpinGEMPIC.add_current_update_v!-Tuple{AbstractArray, ParticleMeshCoupling, Float64, Float64, Float64, Float64, Float64}","content":" SpinGEMPIC.add_current_update_v!  —  Method add_current_update_v!( j_dofs, p, \n                       position_old, position_new, \n                       marker_charge, qoverm, \n                       vi) Add current for one particle and update v (according to  $H_{p1}$  part in Hamiltonian splitting) Read out particle position and velocity Compute index_old, the index of the last DoF on the grid the  particle contributes to, and  r_old , its position (normalized to cell size one). source"},{"id":436,"pagetitle":"Particle-Mesh coupling","title":"SpinGEMPIC.evaluate","ref":"/scalar-spin/dev/particle_mesh_coupling/#SpinGEMPIC.evaluate-Tuple{ParticleMeshCoupling, Float64, Vector{Float64}}","content":" SpinGEMPIC.evaluate  —  Method evaluate(p, position, field_dofs) Evaluate field at  position p  : Kernel smoother object  position  : Position of the particle field_dofs  : Coefficient vector for the field DoFs field_value  : Value(s) of the electric fields at given position source"},{"id":437,"pagetitle":"Particle-Mesh coupling","title":"SpinGEMPIC.update_jv!","ref":"/scalar-spin/dev/particle_mesh_coupling/#SpinGEMPIC.update_jv!-Tuple{AbstractArray, ParticleMeshCoupling, Float64, Float64, Int64, Float64, Float64, Float64, Float64}","content":" SpinGEMPIC.update_jv!  —  Method update_jv!(j_dofs, p, \n           lower, upper, index, marker_charge, \n           qoverm, sign, vi, bfield_dofs) Helper function for  add_current_update_v . source"},{"id":440,"pagetitle":"Particle sampling","title":"Particle sampling","ref":"/scalar-spin/dev/particle_sampling/#Particle-sampling","content":" Particle sampling"},{"id":441,"pagetitle":"Particle sampling","title":"SpinGEMPIC.sample!","ref":"/scalar-spin/dev/particle_sampling/#SpinGEMPIC.sample!-Tuple{Any, Any, SpinGEMPIC.AbstractCosGaussian, Any}","content":" SpinGEMPIC.sample!  —  Method sample!( rng, pg, df, mesh, method) Sample from a Particle sampler rnd   : Random generator  pg    : Particle group df    : Distribution function mesh  : Domain method  :  weighted  or  quietstart  with weigth = 1 source"},{"id":442,"pagetitle":"Particle sampling","title":"SpinGEMPIC.sample_quietstart!","ref":"/scalar-spin/dev/particle_sampling/#SpinGEMPIC.sample_quietstart!-NTuple{4, Any}","content":" SpinGEMPIC.sample_quietstart!  —  Method sample_quietsart!( rng, pg, df, mesh) Sample from a Particle sampler rnd   : Random generator  pg    : Particle group df    : Distribution function mesh  : Domain Input r is a random number  $\\in [0,1]$ \\[    f(x) = 1 + \\alpha cos(k x)\\] on some domain  $[0, 2\\pi/k]$ Solve the equation  $P(x)-r=0$  with Newton’s method \\[    x^{n+1} = x^n – (P(x)-(2\\pi r / k)/f(x) \\] with  \\[P(x) = \\int_0^x (1 + \\alpha cos(k y)) dy\\] \\[P(x) = x + \\frac{\\alpha}{k} sin (k x)\\] source"},{"id":443,"pagetitle":"Particle sampling","title":"SpinGEMPIC.sample_weighted!","ref":"/scalar-spin/dev/particle_sampling/#SpinGEMPIC.sample_weighted!-NTuple{4, Any}","content":" SpinGEMPIC.sample_weighted!  —  Method sample_weighted!( rng, pg, df, mesh) Sample from a Particle sampler rnd   : Random generator  pg    : Particle group df    : Distribution function mesh  : Domain source"},{"id":446,"pagetitle":"Quickstart","title":"Quickstart","ref":"/scalar-spin/dev/quickstart/#Quickstart","content":" Quickstart"},{"id":447,"pagetitle":"Quickstart","title":"Import packages","ref":"/scalar-spin/dev/quickstart/#Import-packages","content":" Import packages using Plots\nusing Random\nusing SpinGEMPIC\n\nimport GEMPIC: OneDGrid, Maxwell1DFEM\nimport GEMPIC:  l2projection!, eval_uniform_periodic_spline_curve"},{"id":448,"pagetitle":"Quickstart","title":"Physics parameters","ref":"/scalar-spin/dev/quickstart/#Physics-parameters","content":" Physics parameters σ, μ = 0.17, 0.0\nkx, α = 1.22, 0.02 (1.22, 0.02)"},{"id":449,"pagetitle":"Quickstart","title":"Initialize mesh","ref":"/scalar-spin/dev/quickstart/#Initialize-mesh","content":" Initialize mesh xmin, xmax = 0, 4pi/kx\nnx = 128\nmesh = OneDGrid( xmin, xmax, nx) GEMPIC.OneDGrid(128, 0.0, 10.300303782261617, 10.300303782261617, 0.08110475419103635, [0.0, 0.08047112329891888, 0.16094224659783776, 0.24141336989675666, 0.3218844931956755, 0.4023556164945944, 0.4828267397935133, 0.5632978630924321, 0.643768986391351, 0.72424010969027  …  9.576063672571347, 9.656534795870266, 9.737005919169185, 9.817477042468104, 9.897948165767023, 9.978419289065942, 10.05889041236486, 10.13936153566378, 10.219832658962698, 10.300303782261617])"},{"id":450,"pagetitle":"Quickstart","title":"Initialize particles","ref":"/scalar-spin/dev/quickstart/#Initialize-particles","content":" Initialize particles n_particles = 10000\n\ndf = CosGaussian(kx, α, σ, μ)\n\nrng = MersenneTwister(123)\nmass, charge = 1.0, 1.0\n\nparticle_group = ParticleGroup( n_particles, mass, charge, 1)\nsample!(rng, particle_group, df, mesh, method = :quietstart) sphereplot(particle_group) xp = view(particle_group.array, 1, :)\nvp = view(particle_group.array, 2, :)\ns1 = view(particle_group.array, 3, :)\ns2 = view(particle_group.array, 4, :)\ns3 = view(particle_group.array, 5, :)\nwp = view(particle_group.array, 6, :)\n\np = plot(layout=(3,1))\nhistogram!(p[1], s1, weights=wp, normalize=true, bins = 100, lab = \"\")\nhistogram!(p[2], s2, weights=wp, normalize=true, bins = 100, lab = \"\")\nhistogram!(p[3], s3, weights=wp, normalize=true, bins = 100, lab = \"\")\nplot!(p[3], x -> (1 + x / 2) / 2, -1, 1, lab=\"\") p = plot(layout=(2,1))\nhistogram!(p[1], xp, weights=wp, normalize= true, bins = 100, lab = \"\")\nplot!(p[1], x-> (1+α*cos(kx*x))/(4π/kx), 0., 4π/kx, lab=\"\")\nylims!(p[1], (0.09,0.11))\nhistogram!(p[2], vp, weights=wp, normalize=true, bins = 100, lab = \"\")\nplot!(p[2], v-> 1/sqrt(2pi)/σ*(exp(-(v-μ)^2 / 2/σ/σ)), -1, 1, lab=\"\")"},{"id":451,"pagetitle":"Quickstart","title":"Initialize Maxwell solver","ref":"/scalar-spin/dev/quickstart/#Initialize-Maxwell-solver","content":" Initialize Maxwell solver spline_degree = 3\n\nkernel_smoother0 = ParticleMeshCoupling( mesh, n_particles, spline_degree)\n\nmaxwell_solver = Maxwell1DFEM(mesh, spline_degree)\n\nrho = zeros(nx)\nefield_poisson = zeros(nx)\n\nsolve_poisson!( efield_poisson, particle_group, kernel_smoother0, maxwell_solver, rho )\nsval = eval_uniform_periodic_spline_curve(spline_degree-1, efield_poisson)\nplot(LinRange(xmin, xmax, nx), sval, label=\"Ex\")"},{"id":456,"pagetitle":"Home","title":"VectorSpin","ref":"/vector-spin/dev/#VectorSpin","content":" VectorSpin"},{"id":457,"pagetitle":"Home","title":"Scalar spin laser plasma model","ref":"/vector-spin/dev/#Scalar-spin-laser-plasma-model","content":" Scalar spin laser plasma model Particle distribution function  $f(x, p, {\\mathbf s}, t)$ ,  $x\\in [0,L]$ ,  $p \\in \\mathbb{R}$  are scalars,  ${\\mathbf s}=(s_1,s_2,s_3) \\in \\mathbb{R}^3$ ,  ${\\mathbf E} = (E_x, {\\mathbf E}_\\perp) = (E_x, E_y, E_z)$ ,  ${\\mathbf A} = (A_x, {\\mathbf A}_\\perp) = (0, A_y, A_z)$ ,  ${\\mathbf B} =\\nabla\\times{\\mathbf  A} = (0,- \\partial_xA_z,  \\partial_xA_y)$ . The scalar spin Vlasov-Maxwell  system is: \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f}{\\partial t} + p \\frac{\\partial f}{\\partial x} + [ E_x - \\mathfrak{h} s_2 \\frac{\\partial^2 A_z}{\\partial x^2} + \\mathfrak{h} s_3 \\frac{\\partial^2 A_y}{\\partial x^2}  - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x} ]\\frac{\\partial f}{\\partial p}  \\\\ \n& \\hspace{3cm}+ [s_3 \\frac{\\partial A_z}{\\partial x} + s_2 \\frac{\\partial A_y}{\\partial x}, -s_1 \\frac{\\partial A_y}{\\partial x}, -s_1 \\frac{\\partial A_z}{\\partial x} ] \\cdot \\frac{\\partial f}{\\partial {\\mathbf s}} = 0,\\\\\n&\\frac{\\partial E_x}{\\partial t} = -\\int_{\\mathbb{R}^4} p f  \\mathrm{d}{p}\\mathrm{d}\\mathrm{\\mathbf s},\\\\\n&\\frac{\\partial E_y}{\\partial t} = - \\frac{\\partial^2 A_y}{\\partial x^2} + A_y \\int_{\\mathbb{R}^4}  f  \\mathrm{d}{p}\\mathrm{d}\\mathrm{\\mathbf s} + \\mathfrak{h}\\int_{\\mathbb{R}^4} s_3 \\frac{\\partial f}{\\partial x}\\mathrm{d}{p}\\mathrm{d}\\mathrm{\\mathbf s},\\\\\n&\\frac{\\partial E_z}{\\partial t} = - \\frac{\\partial^2 A_z}{\\partial x^2} + A_z \\int_{\\mathbb{R}^4}  f  \\mathrm{d}{p}\\mathrm{d}\\mathrm{\\mathbf s} - \\mathfrak{h}\\int_{\\mathbb{R}^4} s_2 \\frac{\\partial f}{\\partial x}\\mathrm{d}{p}\\mathrm{d}\\mathrm{\\mathbf s},\\\\\n& \\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} = - {\\mathbf E}_\\perp,\\\\\n&\\frac{\\partial E_x}{\\partial x} = \\int_{\\mathbb{R}^4} f \\mathrm{d}{p}\\mathrm{d}\\mathrm{\\mathbf s} - 1. \\ \\text{(Poisson equation)}\n\\end{aligned}\n\\right.\\] The system numerically solve is the vector model: \\[f(t, x,p,{\\mathbf{s}})=\\frac{1}{4\\pi}(f_0(t, x,p)+3s_1f_1(t, x,p)+3s_2f_2(t, x,p)+3s_3f_3(t, x,p)).\\] \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f_0}{\\partial t} + p \\frac{\\partial f_0}{\\partial x} + \\left(E_x - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}  \\right) \\frac{\\partial f_0}{\\partial p} - \\mathfrak{h}\\frac{\\partial^2 A_z}{\\partial x^2}\\frac{\\partial f_2}{\\partial p} +  \\mathfrak{h}\\frac{\\partial^2 A_y}{\\partial x^2} \\frac{\\partial f_3}{\\partial p}  = 0,\\\\\n&\\frac{\\partial f_1}{\\partial t} + p \\frac{\\partial f_1}{\\partial x} + \\left(E_x - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}  \\right) \\frac{\\partial f_1}{\\partial p}\n - \\frac{\\partial A_z }{\\partial x}  f_3  -  \\frac{\\partial A_y }{\\partial x} f_2 = 0,\\\\\n& \\frac{\\partial f_2}{\\partial t} + p \\frac{\\partial f_2}{\\partial x} + \\left(E_x - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}  \\right) \\frac{\\partial f_2}{\\partial p} - {\\frac{\\mathfrak{h}}{3}} \\frac{\\partial^2 A_z}{\\partial x^2}\\frac{\\partial f_0}{\\partial p}\n  +  \\frac{\\partial A_y }{\\partial x} f_1 = 0,\\\\\n & \\frac{\\partial f_3}{\\partial t} + p \\frac{\\partial f_3}{\\partial x} + \\left(E_x - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}  \\right) \\frac{\\partial f_3}{\\partial p} + {\\frac{\\mathfrak{h}}{3}}  \\frac{\\partial^2 A_y}{\\partial x^2}\\frac{\\partial f_0}{\\partial p}\n  +  \\frac{\\partial A_z }{\\partial x} f_1 = 0,\\\\\n&\\frac{\\partial E_x}{\\partial t} = -\\int_{\\mathbb{R}} p f_0  \\mathrm{d}\\mathrm{p},\\\\\n&\\frac{\\partial E_y}{\\partial t} = - \\frac{\\partial^2 A_y}{\\partial x^2} + A_y \\int_{\\mathbb{R}}  f_0  \\mathrm{d}\\mathrm{p} + \\mathfrak{h}\\int_{\\mathbb{R}}  \\frac{\\partial f_3}{\\partial x}\\mathrm{d}\\mathrm{p},\\\\\n&\\frac{\\partial E_z}{\\partial t} = - \\frac{\\partial^2 A_z}{\\partial x^2} + A_z \\int_{\\mathbb{R}}  f_0  \\mathrm{d}\\mathrm{p} -\\mathfrak{h} \\int_{\\mathbb{R}}  \\frac{\\partial f_2}{\\partial x}\\mathrm{d}\\mathrm{p},\\\\\n& \\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} = - {\\mathbf E}_\\perp,\\\\\n&\\frac{\\partial E_x}{\\partial x} = \\int_{\\mathbb{R}} f_0 \\mathrm{d}\\mathrm{p} - 1.\\ \\text{(Poisson equation)}\n\\end{aligned}\n\\right.\\]"},{"id":458,"pagetitle":"Home","title":"Time discretization: Hamiltonian splitting method","ref":"/vector-spin/dev/#Time-discretization:-Hamiltonian-splitting-method","content":" Time discretization: Hamiltonian splitting method \\[\\mathcal{H}=\\mathcal{H}_{p}+\\mathcal{H}_{A}+\\mathcal{H}_{E}+\\mathcal{H}_{2}+\\mathcal{H}_{3},\\] where  \\[\\begin{aligned}\n\\mathcal{H}_{p} & = \\frac{1}{2}\\int p^2 f_0 \\mathrm{d}{ x}\\mathrm{d}{p},\\\\\n\\mathcal{H}_{A} &= \\frac{1}{2}\\int |{\\mathbf A}_\\perp|^2 f_0 \\mathrm{d}{ x}\\mathrm{d}{ p}+\\frac{1}{2}\\int \\left|\\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}\\right|^2 \\mathrm{d}{x},\\\\\n\\mathcal{H}_{E} &= \\frac{1}{2}\\int |{\\mathbf E}|^2  \\mathrm{d}{ x}=\\frac{1}{2}\\int (E_x^2+|{\\mathbf E_\\perp}|^2 ) \\mathrm{d}{ x}, \\\\\n\\mathcal{H}_{2} &= \\int_{\\Omega}  \\mathfrak{h} f_2 \\frac{\\partial A_z}{\\partial x} \\mathrm{d}x\\mathrm{d}p,\\\\\n\\mathcal{H}_{3} &= \\int_{\\Omega}  -\\mathfrak{h} f_3 \\frac{\\partial A_y}{\\partial x} \\mathrm{d}x\\mathrm{d}p.\n\\end{aligned} \\]"},{"id":459,"pagetitle":"Home","title":"Subsystem for  $\\mathcal{H}_p$","ref":"/vector-spin/dev/#Subsystem-for-\\\\mathcal{H}_p","content":" Subsystem for  $\\mathcal{H}_p$ The subsystem  $\\frac{\\partial \\mathcal{Z}}{\\partial t} = \\{ \\mathcal{Z}, \\mathcal{H}_p \\}$  associated to  $\\mathcal{H}_{p} = \\frac{1}{2}\\int p^2 f_0 \\mathrm{d}{ x}\\mathrm{d}{p}$  is  \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f_0}{\\partial t} = \\{f_0, \\mathcal{H}_{p} \\} = -p\\frac{\\partial f_0}{\\partial x}, \\\\\n&\\frac{\\partial \\mathbf{f}}{\\partial t} = \\{\\mathbf{f}, \\mathcal{H}_{p} \\}= -p\\frac{\\partial \\mathbf{f}}{\\partial x}, \\\\\n%&\\frac{\\partial f_1}{\\partial t} = \\{f_1, \\mathcal{H}_{p} \\}= -p\\frac{\\partial f_1}{\\partial x}, \\\\\n%&\\frac{\\partial f_2}{\\partial t} = \\{f_2, \\mathcal{H}_{p} \\}= -p\\frac{\\partial f_2}{\\partial x}, \\\\\n%&\\frac{\\partial f_3}{\\partial t} = \\{f_3, \\mathcal{H}_{p} \\}= -p\\frac{\\partial f_3}{\\partial x},\\\\\n& \\frac{\\partial E_x}{\\partial t} = \\{ E_x, \\mathcal{H}_{p} \\} =- \\int_{\\mathbb{R}} p f_0\\mathrm{d}{p},\\\\\n& \\frac{\\partial {\\mathbf E}_\\perp}{\\partial t} =\\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} =0. \n%& \\frac{\\partial {\\mathbf E}_\\perp}{\\partial t} =  \\{ {\\mathbf E}_\\perp, \\mathcal{H}_{p} \\}  = {\\mathbf 0},\\;\\; \\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} =  \\{ {\\mathbf A}_\\perp, \\mathcal{H}_{p} \\}  = {\\mathbf 0}.\n\\end{aligned}\n\\right.\\] We denote the initial value as  $(f_0^0(x,p),\\mathbf{f}^0(x,p), E_x^0(x),{\\mathbf E}_\\perp^0(x),{\\mathbf A}_\\perp^0(x))$  at time  $t=0$ . The solution at time  $t$  of this subsystem can be written explicitly,  \\[\\begin{aligned}\n        &f_0(x,p,t)=f_0^0(x-pt,p), \\;\\;  \\mathbf{f}(x,p,t)=\\mathbf{f}^0(x-pt,p),\\\\ %f_2(x,p,t)=f_2^0(x-pt,p), f_3(x,p,t)=f_3^0(x-pt,p), \\\\\n        &E_x(x,t)=E_x^0(x)-\\int_0^t\\int_{\\mathbb{R}} pf_0(x,p,\\tau) \\mathrm{d}p\\mathrm{d}\\tau=E_x^0(x)-\\int_0^t\\int_{\\mathbb{R}} pf_0^0(x-p\\tau,p) \\mathrm{d}p\\mathrm{d}\\tau, \\\\\n        &{\\mathbf E}_\\perp(x,t)={\\mathbf E}_\\perp^0(x), \\;\\; {\\mathbf A}_\\perp(x,t)={\\mathbf A}_\\perp^0(x). \n    \\end{aligned}\\] Next, we check that the solution propagates the Poisson equation. To do so, we assume that the Poisson equation holds initially, i.e. \\[\\frac{\\partial E_x^0}{\\partial x}=\\int_{\\mathbb{R}} f_0^0\\mathrm{d}{p}-1.\\] Then we have, by differentiating the expression of  $E_x(t, x)$  with respect to  $x$ \\[\\begin{aligned}\n\\frac{\\partial E_x(x,t)}{\\partial x}&=\\frac{\\partial E_x^0}{\\partial x}-\\int_0^t\\int_{\\mathbb{R}} p\\frac{\\partial f_0^0(x-p\\tau,p)}{\\partial x} \\mathrm{d}p\\mathrm{d}\\tau=\\frac{\\partial E_x^0}{\\partial x}+\\int_0^t\\int_{\\mathbb{R}} \\frac{\\partial f_0^0(x-p\\tau,p)}{\\partial \\tau} \\mathrm{d}p\\mathrm{d}\\tau\\\\\n&=\\frac{\\partial E_x^0}{\\partial x}+\\int_{\\mathbb{R}}  f_0^0(x-pt,p)\\mathrm{d}p-\\int_{\\mathbb{R}}  f_0^0(x,p)\\mathrm{d}p=\\int_{\\mathbb{R}}  f_0(x,p,t)\\mathrm{d}p-1, \n\\end{aligned}\\] which proves that the Poisson equation is satisfied at time  $t$ ."},{"id":460,"pagetitle":"Home","title":"Subsystem for  $\\mathcal{H}_A$","ref":"/vector-spin/dev/#Subsystem-for-\\\\mathcal{H}_A","content":" Subsystem for  $\\mathcal{H}_A$ The subsystem  $\\frac{\\partial \\mathcal{Z}}{\\partial t} = \\{ \\mathcal{Z}, \\mathcal{H}_A \\}$  associated to the sub-Hamiltonian  $\\mathcal{H}_{A} = \\frac{1}{2}\\int |{\\mathbf A}_\\perp|^2 f_0 \\mathrm{d}{\\mathbf x}\\mathrm{d}{\\mathbf p}+\\frac{1}{2}\\int |\\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}|^2 \\mathrm{d}{\\mathbf x}$  is  \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f_0}{\\partial t} = \\{f_0, \\mathcal{H}_{A} \\} = {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x}\\frac{\\partial f_0}{\\partial p}, \\\\\n&\\frac{\\partial {\\mathbf f}}{\\partial t} = \\{{\\mathbf f}, \\mathcal{H}_{A} \\}= {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x} \\frac{\\partial {\\mathbf f}}{\\partial p}, \\\\\n%&\\frac{\\partial f_2}{\\partial t} = \\{f_2, \\mathcal{H}_{A} \\}= {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x} \\frac{\\partial f_2}{\\partial p}, \\\\\n%&\\frac{\\partial f_3}{\\partial t} = \\{f_3, \\mathcal{H}_{A} \\}= {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x} \\frac{\\partial f_3}{\\partial p},\\\\\n%& \\frac{\\partial E_x}{\\partial t} = \\{ E_x, \\mathcal{H}_{A} \\} = 0,\\\\\n& \\frac{\\partial {\\mathbf E}_\\perp}{\\partial t} =  \\{ {\\mathbf E}_\\perp, \\mathcal{H}_{A} \\}  = - \\frac{\\partial^2 {\\mathbf A}_\\perp}{\\partial x^2} + {\\mathbf A}_\\perp \\int_{\\mathbb{R}}  f_0  \\mathrm{d}\\mathrm{p},\\\\\n& \\frac{\\partial E_x}{\\partial t} =\\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} = 0. % \\{ {\\mathbf A}_\\perp, \\mathcal{H}_{A} \\}  = {\\mathbf 0}.\n\\end{aligned}\n\\right.\\] We denote by  $(f_0^0(x,p),{\\mathbf f}^0(x,p), E_x^0(x),{\\mathbf E}_\\perp^0(x),{\\mathbf A}_\\perp^0(x))$  the initial value at time  $t=0$ . The exact solution at time t is, \\[\\begin{aligned}\n        &f_0(x,p,t)=f_0^0 \\left( x,p+t{\\mathbf A}_\\perp^0(x) \\cdot \\frac{\\partial {\\mathbf A}_\\perp^0(x)}{\\partial x}  \\right) ,\\\\\n&   {\\mathbf f}(x,p,t)={\\mathbf f}^0 \\left( x,p+t{\\mathbf A}_\\perp^0(x) \\cdot \\frac{\\partial {\\mathbf A}_\\perp^0(x)}{\\partial x}  \\right), \\\\\n        &{\\mathbf E}_\\perp(x,t)={\\mathbf E}_\\perp^0(x)-t\\frac{\\partial^2 {\\mathbf A}_\\perp^0(x)}{\\partial x^2} +t{\\mathbf A}_\\perp^0(x)\\int_{\\mathbb{R}} f_0^0(x,p) \\mathrm{d}p, \\\\\n        &E_x(x,t)=E_x^0(x), \\;\\; {\\mathbf A}_\\perp(x,t)={\\mathbf A}_\\perp^0(x), \\\\\n\\end{aligned}\\]"},{"id":461,"pagetitle":"Home","title":"Subsystem for  $\\mathcal{H}_E$","ref":"/vector-spin/dev/#Subsystem-for-\\\\mathcal{H}_E","content":" Subsystem for  $\\mathcal{H}_E$ The subsystem  $\\frac{\\partial \\mathcal{Z}}{\\partial t} = \\{ \\mathcal{Z}, \\mathcal{H}_E \\}$  associated to the sub-Hamiltonian  $\\mathcal{H}_{E} = \\frac{1}{2}\\int |{\\mathbf E}|^2  \\mathrm{d}{\\mathbf x}$  is  \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f_0}{\\partial t} = \\{f_0, \\mathcal{H}_{E} \\} = -E_x \\frac{\\partial f_0}{\\partial p}, \\\\\n&\\frac{\\partial {\\mathbf f}}{\\partial t} = \\{{\\mathbf f}, \\mathcal{H}_{E} \\}= -E_x \\frac{\\partial {\\mathbf f}}{\\partial p}, \\\\\n%&\\frac{\\partial f_2}{\\partial t} = \\{f_2, \\mathcal{H}_{E} \\}= -E_x \\frac{\\partial f_2}{\\partial p}, \\\\\n%&\\frac{\\partial f_3}{\\partial t} = \\{f_3, \\mathcal{H}_{E} \\}=-E_x \\frac{\\partial f_3}{\\partial p},\\\\\n%& \\frac{\\partial E_x}{\\partial t} = \\{ E_x, \\mathcal{H}_{E} \\} = 0,\\\\\n& \\frac{\\partial {\\mathbf E}_\\perp}{\\partial t} =  \\{ {\\mathbf E}_\\perp, \\mathcal{H}_{E} \\}  = {\\mathbf 0},\\\\\n& \\frac{\\partial E_x}{\\partial t} = \\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} = 0. % \\{ {\\mathbf A}_\\perp, \\mathcal{H}_{E} \\}  =  -{\\mathbf E}_\\perp.\n\\end{aligned}\n\\right.\\] With the initial value $(f_0^0(x,p),{\\mathbf f}^0(x,p),E_x^0(x),{\\mathbf E}_\\perp^0(x),{\\mathbf A}_\\perp^0(x))$  at time  $t=0$ , the solution at time t is as follows,  \\[\\begin{aligned}\n& f_0(x,p,t)=f_0^0 ( x,p-tE_x^0(x) ), \\\\\n& {\\mathbf f}(x,p,t)={\\mathbf f}^0 ( x,p-tE_x^0(x) ),  \\\\\n& E_x(x,t)=E_x^0(x), \\\\\n& {\\mathbf E}_\\perp(x,t)={\\mathbf E}_\\perp^0(x), \\\\\n& {\\mathbf A}_\\perp(x,t)={\\mathbf A}_\\perp^0(x) -t{\\mathbf E}_\\perp^0(x).\n\\end{aligned}\\]"},{"id":462,"pagetitle":"Home","title":"Subsystem for  $\\mathcal{H}_2$","ref":"/vector-spin/dev/#Subsystem-for-\\\\mathcal{H}_2","content":" Subsystem for  $\\mathcal{H}_2$ The subsystem  $\\frac{\\partial \\mathcal{Z}}{\\partial t} = \\{ \\mathcal{Z}, \\mathcal{H}_2 \\}$  associated to the sub-Hamiltonian  $\\mathcal{H}_{2} = \\int_{\\Omega}  \\mathfrak{h} f_2 \\frac{\\partial A_z}{\\partial x} \\mathrm{d}x\\mathrm{d}p$  is  \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f_0}{\\partial t} = \\{f_0, \\mathcal{H}_{2} \\} = \\mathfrak{h}\\frac{\\partial^2 A_z}{\\partial x^2}\\frac{\\partial f_2}{\\partial p},  \\\\\n&\\frac{\\partial f_1}{\\partial t} = \\{f_1, \\mathcal{H}_{2} \\}= \\frac{\\partial A_z }{\\partial x}  f_3, \\\\\n&\\frac{\\partial f_2}{\\partial t} = \\{f_2, \\mathcal{H}_{2} \\}= {{\\frac{\\mathfrak{h}}{3}}} \\frac{\\partial^2 A_z}{\\partial x^2}\\frac{\\partial f_0}{\\partial p}, \\\\\n&\\frac{\\partial f_3}{\\partial t} = \\{f_3, \\mathcal{H}_{2} \\}= -\\frac{\\partial A_z }{\\partial x} f_1,\\\\\n& \\frac{\\partial { E}_z}{\\partial t} =  \\{ {E}_z, \\mathcal{H}_{2} \\}  =-\\mathfrak{h}{ \\int_{\\mathbb{R}}  \\frac{\\partial f_2}{\\partial x}\\mathrm{d}{p}},\\\\\n& \\frac{\\partial E_x}{\\partial t} =\\frac{\\partial { E}_y}{\\partial t} =\\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} =0. \n\\end{aligned}\n\\right.\\] In this subsystem, we observe some coupling between the distribution functions. To write down the exact solution, we reformulate the equations on  $(f_0, {\\mathbf f})$  as, using  $A_z(x, t)=A_z^0(x)$ \\[    \\begin{aligned}\n    & \\partial_t    \\begin{pmatrix}\n            f_1  \\\\\n            f_3\n        \\end{pmatrix}-\\frac{\\partial A_z^0 }{\\partial x} J \\begin{pmatrix}\nf_1  \\\\\nf_3\n\\end{pmatrix} =0,  \\\\\n& \\partial_t    \\begin{pmatrix}\n    f_0 \\\\\n    f_2\n\\end{pmatrix}-\\mathfrak{h}\\frac{\\partial^2 A_z^0}{\\partial x^2} \\begin{pmatrix}\n    0 & 1 \\\\\n    \\frac{1}{3}& 0\n\\end{pmatrix} \\partial_p    \\begin{pmatrix}\nf_0 \\\\\nf_2\n\\end{pmatrix} =0, \\\\\n    \\end{aligned}\\] where  $J$  denotes the symplectic matrix \\[J=\\begin{pmatrix}\n    0 & 1 \\\\\n-1 & 0\n\\end{pmatrix}.\\] With the initial value  $(f_0^0(x,p),{\\mathbf f}^0(x,p),E_x^0(x),{\\mathbf E}_\\perp^0(x),{\\mathbf A}_\\perp^0(x))$  at time  $t=0$ , the exact solution for the first system is \\[\\begin{pmatrix}\n            f_1  \\\\\n            f_3\n        \\end{pmatrix}(x,p,t)=\\exp{\\left(\\frac{\\partial A_z^0(x) }{\\partial x} J t\\right)}\\begin{pmatrix}\nf_1^0(x,p)  \\\\\nf_3^0(x,p)\n\\end{pmatrix},\\  \\text{with}\\ \\exp{(Js)}=\\begin{pmatrix}\n    \\cos(s) & \\sin(s) \\\\\n-\\sin(s) & \\cos(s)\n\\end{pmatrix}.\\] Let us now focus on the second system \\[\\partial_t  \\begin{pmatrix}\n    f_0 \\\\\n    f_2\n\\end{pmatrix}-\\mathfrak{h}\\frac{\\partial^2 A_z^0}{\\partial x^2} \\begin{pmatrix}\n    0 & 1 \\\\\n    \\frac{1}{3}& 0\n\\end{pmatrix} \\partial_p    \\begin{pmatrix}\nf_0 \\\\\nf_2\n\\end{pmatrix} =0. \\] By the eigen-decomposition  \\[\\begin{pmatrix}\n    \\frac{1}{2} & \\frac{\\sqrt{3}}{2} \\\\\n    \\frac{1}{2}& -\\frac{\\sqrt{3}}{2}\n\\end{pmatrix}\n\\begin{pmatrix}\n    0 & 1 \\\\\n    \\frac{1}{3}& 0\n\\end{pmatrix}\n\\begin{pmatrix}\n    1 & 1 \\\\\n    \\frac{1}{\\sqrt{3}}& \\frac{-1}{\\sqrt{3}}\n\\end{pmatrix}\n=\\begin{pmatrix}\n\\frac{1}{\\sqrt{3}}& 0 \\\\\n    0& -\\frac{1}{\\sqrt{3}}\n\\end{pmatrix},\\] then, one can diagonalize the transport equation to get \\[\\partial_t  \\begin{pmatrix}\n    \\frac{1}{2}f_0+\\frac{\\sqrt{3}}{2}f_2 \\\\\n    \\frac{1}{2}f_0-\\frac{\\sqrt{3}}{2}f_2 \n\\end{pmatrix}- \n\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_z^0}{\\partial x^2}\n\\begin{pmatrix}\n    1 & 0 \\\\\n    0& -1\n\\end{pmatrix} \\partial_p    \\begin{pmatrix}\n    \\frac{1}{2}f_0+\\frac{\\sqrt{3}}{2}f_2 \\\\\n    \\frac{1}{2}f_0-\\frac{\\sqrt{3}}{2}f_2 \n\\end{pmatrix} =0.\n\\] Thus, we can solve the transport equation \\[\\Big(\\frac{1}{2}f_0\\pm\\frac{\\sqrt{3}}{2}f_2\\Big)(x,p,t)=\\Big(\\frac{1}{2}f_0^0 \\pm\\frac{\\sqrt{3}}{2}f_2^0\\Big)( x,p\\pm t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_z^0}{\\partial x^2}(x)),\\] and compute the exact solution at time  $t$  as follows,  \\[\\begin{aligned}\n        &f_1(x,p,t)=\\cos(t \\frac{\\partial A_z^0(x) }{\\partial x} )f_1^0 ( x,p)+\\sin(t \\frac{\\partial A_z^0(x) }{\\partial x} )f_3^0 ( x,p), \\\\\n        &f_3(x,p,t)=-\\sin(t \\frac{\\partial A_z^0(x) }{\\partial x} )f_1^0 ( x,p)+\\cos(t \\frac{\\partial A_z^0(x) }{\\partial x} )f_3^0 ( x,p) \\\\\n        &f_0(x,p,t)=\\Big(\\frac{1}{2}f_0^0 +\\frac{\\sqrt{3}}{2}f_2^0\\Big)( x,p+t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_z^0}{\\partial x^2}(x) )+\\Big(\\frac{1}{2}f_0^0 -\\frac{\\sqrt{3}}{2}f_2^0\\Big)( x,p-t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_z^0}{\\partial x^2}(x) ),\\\\\n        &f_2(x,p,t)=\\frac{1}{\\sqrt{3}}\\Big(\\frac{1}{2}f_0^0 +\\frac{\\sqrt{3}}{2}f_2^0\\Big)( x,p+t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_z^0}{\\partial x^2}(x) )-\\frac{1}{\\sqrt{3}}\\Big(\\frac{1}{2}f_0^0 -\\frac{\\sqrt{3}}{2}f_2^0\\Big)( x,p-t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_z^0}{\\partial x^2}(x) ),\\\\\n        &{\\mathbf A}_\\perp(x,t)={\\mathbf A}_\\perp^0(x), E_x(x,t)=E_x^0(x), E_y(x,t)=E_y^0(x),\\\\\n        &E_z(x,t)=E_z^0(x)-t\\mathfrak{h}\\int_{\\mathbb{R}} \\frac{\\partial f_2^0}{\\partial x}\\mathrm{d}{p}.\n    \\end{aligned}\\]"},{"id":463,"pagetitle":"Home","title":"Subsystem for  $\\mathcal{H}_3$","ref":"/vector-spin/dev/#Subsystem-for-\\\\mathcal{H}_3","content":" Subsystem for  $\\mathcal{H}_3$ The subsystem  $\\frac{\\partial \\mathcal{Z}}{\\partial t} = \\{ \\mathcal{Z}, \\mathcal{H}_3 \\}$  associated to the sub-Hamiltonian  $\\mathcal{H}_{3} = -\\int_{\\Omega} \\mathfrak{h} f_3 \\frac{\\partial A_y}{\\partial x} \\mathrm{d}x\\mathrm{d}p$  is  \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f_0}{\\partial t} = \\{f_0, \\mathcal{H}_{3} \\} = -\\mathfrak{h}\\frac{\\partial^2 A_y}{\\partial x^2} \\frac{\\partial f_3}{\\partial p},  \\\\\n&\\frac{\\partial f_1}{\\partial t} = \\{f_1, \\mathcal{H}_{3} \\}=  \\frac{\\partial A_y }{\\partial x} f_2, \\\\\n&\\frac{\\partial f_2}{\\partial t} = \\{f_2, \\mathcal{H}_{3} \\}= - \\frac{\\partial A_y }{\\partial x} f_1,\\\\\n&\\frac{\\partial f_3}{\\partial t} =- \\{f_3, \\mathcal{H}_{3} \\}= -{{\\frac{\\mathfrak{h}}{3}}} \\frac{\\partial^2 A_y}{\\partial x^2} \\frac{\\partial f_0}{\\partial p}, \\\\\n& \\frac{\\partial { E}_y}{\\partial t} =  \\{ {E}_y, \\mathcal{H}_{3} \\}  = {\\mathfrak{h} \\int_{\\mathbb{R}}  \\frac{\\partial f_3}{\\partial x}\\mathrm{d}{p}},\\\\\n& \\frac{\\partial E_x}{\\partial t} = \\frac{\\partial { E}_z}{\\partial t} = \\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} =0. \n\\end{aligned}\n\\right.\\] This subsystem is very similar to the  $\\mathcal{H}_2$  one, hence, as previously, we reformulate the equations on the distribution functions as  \\[\\begin{aligned}\n        & \\partial_t    \\begin{pmatrix}\n            f_1  \\\\\n            f_2\n        \\end{pmatrix}\n        -\\frac{\\partial A_y^0 }{\\partial x} J \n        %\\begin{pmatrix}\n    %       0 & -1 \\\\\n%           1 & 0\n        %\\end{pmatrix} \n        \\begin{pmatrix}\n        f_1  \\\\\n        f_2\n    \\end{pmatrix} =0, \\\\\n        & \\partial_t    \\begin{pmatrix}\n            f_0 \\\\\n            f_3\n        \\end{pmatrix}+\\mathfrak{h}\\frac{\\partial^2 A_y^0}{\\partial x^2} \\begin{pmatrix}\n            0 & 1 \\\\\n            \\frac{1}{3}& 0\n        \\end{pmatrix} \\partial_p    \\begin{pmatrix}\n            f_0 \\\\\n            f_3\n        \\end{pmatrix} =0, \\\\\n    %& \\frac{\\partial E_x}{\\partial t}= 0,\\ \n %\\frac{\\partial { E}_y}{\\partial t} =   {\\mathfrak{h} \\int_{\\mathbb{R}}  \\frac{\\partial f_3}{\\partial x}\\mathrm{d}{p}},\\\\\n    %& \\frac{\\partial { E}_z}{\\partial t} =  \\{ {E}_z, H_{3} \\}  = { 0},\\ \n     %\\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} =  \\{ {\\mathbf A}_\\perp, H_{3} \\}  =  0,\n    \\end{aligned}\\] with initial value $(f_0^0(x,p),{\\mathbf f}^0(x,p),E_x^0(x),{\\mathbf E}_\\perp^0(x),{\\mathbf A}_\\perp^0(x))$  at time  $t=0$ . We derive similar formula with  $\\mathcal{H}_2$  for the exact solution at time  $t$ \\[\\begin{aligned}\n        &f_1(x,p,t)=\\cos(t \\frac{\\partial A_y^0(x) }{\\partial x} )f_1^0 ( x,p)+\\sin(t \\frac{\\partial A_y^0(x) }{\\partial x} )f_2^0 ( x,p), \\\\\n        &f_2(x,p,t)=-\\sin(t \\frac{\\partial A_y^0(x) }{\\partial x} )f_1^0 ( x,p)+\\cos(t \\frac{\\partial A_y^0(x) }{\\partial x} )f_2^0 ( x,p), \\\\\n        &f_0(x,p,t)=\\Big(\\frac{1}{2}f_0^0 +\\frac{\\sqrt{3}}{2}f_3^0\\Big)( x,p-t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_y^0}{\\partial x^2}(x) )+\\Big(\\frac{1}{2}f_0^0 -\\frac{\\sqrt{3}}{2}f_3^0\\Big)( x,p+t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_y^0}{\\partial x^2}(x) ),\\\\\n        &f_3(x,p,t)=\\frac{1}{\\sqrt{3}}\\Big(\\frac{1}{2}f_0^0 +\\frac{\\sqrt{3}}{2}f_3^0\\Big)( x,p-t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_y^0}{\\partial x^2}(x) )-\\frac{1}{\\sqrt{3}}\\Big(\\frac{1}{2}f_0^0 -\\frac{\\sqrt{3}}{2}f_3^0\\Big)( x,p+t\\frac{\\mathfrak{h}}{\\sqrt{3}}\\frac{\\partial^2 A_y^0}{\\partial x^2}(x) ),\n    \\end{aligned} \\] \\[\\begin{aligned}\n& E_y(x,t)=E_y^0(x)+t\\mathfrak{h}\\int_{\\mathbb{R}} \\frac{\\partial f_3^0}{\\partial x}\\mathrm{d}{p}, \\\\\n& {\\mathbf A}_\\perp(x,t)={\\mathbf A}_\\perp^0(x), \\\\\n& E_x(x,t)=E_x^0(x), \\\\\n& E_z(x,t)=E_z^0(x). \n\\end{aligned} \\] To compute the solution  $E_y(x,t)$ , we use the fact that \\[\\int_{\\mathbb{R}} f_3(x,p,t) \\mathrm{d}p =\\int_{\\mathbb{R}} f_3^0(x,p)\\mathrm{d} p.\\]"},{"id":464,"pagetitle":"Home","title":"Fully discrete numerical scheme","ref":"/vector-spin/dev/#Fully-discrete-numerical-scheme","content":" Fully discrete numerical scheme We assume that the computational domain is  $[0,L]\\times[-P_L,P_R]$  for  $x$  and  $v$ . The system is periodic in  $x$ -direction with period  $L$  and has compact support on  $[-P_L,P_R]$  in  $v$ -direction. The mesh is as follows: \\[x_j=(j-1)\\Delta x,\\ j=1,...,M,\\ \\Delta x=L/M, \\ (M \\text{ is odd)}\\] \\[p_{\\ell-1} = (\\ell-1)\\Delta p-P_L,\\  \\ell=1,...,N, \\ \\Delta p=(P_L+P_L)/N.\\] We use the spectral Fourier expansion to approximate  $E_x$  as it is periodic in the  $x$ -direction, \\[E_{x,j}=\\sum_{k=-(M-1)/2}^{(M-1)/2} \\hat{E}_{x,k}(t)e^{2\\pi ijk/M}, \\;\\; \\text{ for } j=1,...,M.\\] For the distribution functions  $(f_0, {\\mathbf f})$ , we use a spectral Fourier expansion for the  $x$ -direction and a finite-volume method for the  $p$ -direction. For simplicity, we only present the representation for  $f_0$ , the notations for  ${\\mathbf f}$  are the same. Here  $f_{0,j,\\ell}(t)$  denotes the average of  $f_0(x_j,p,t)$  over a cell  $C_\\ell=[p_{\\ell-1/2}, p_{l+1/2}]$  with the midpoint  $p_{\\ell-1/2}=(\\ell-1/2)\\Delta p-P_L$ , that is, \\[f_{0,j,\\ell}(t)=\\frac{1}{\\Delta p} \\int_{C_\\ell} f_0(x_j,p,t)\\mathrm{d}{p},\\] and also by Fourier expansion in  $x$ -direction, then \\[f_{0,j,\\ell}(t)=\\sum_{k=-(M-1)/2}^{(M-1)/2} \\hat{f}_{0,k,\\ell}(t)e^{2\\pi ijk/M}, \\;\\; j=1,...,M.\\] To evaluate the value of  $f_0$  off-grid in  $p$ -direction, we need to reconstruct a continuous function by using the cell average quantity  $f_{0,j,\\ell}$ . "},{"id":467,"pagetitle":"API","title":"VectorSpin","ref":"/vector-spin/dev/api/#VectorSpin","content":" VectorSpin Documentation for  VectorSpin . VectorSpin.BSplineAdvection VectorSpin.Mesh VectorSpin.H1fh! VectorSpin.H2fh! VectorSpin.H3fh! VectorSpin.He! VectorSpin.advection! VectorSpin.bspline VectorSpin.init VectorSpin.integrate VectorSpin.numeint VectorSpin.step! VectorSpin.step! VectorSpin.step! VectorSpin.step! VectorSpin.step! VectorSpin.step! VectorSpin.translation!"},{"id":468,"pagetitle":"API","title":"VectorSpin.BSplineAdvection","ref":"/vector-spin/dev/api/#VectorSpin.BSplineAdvection","content":" VectorSpin.BSplineAdvection  —  Type struct BSplineAdvection <: VectorSpin.AbstractAdvection Advection to be computed on each row mesh::Mesh dims::Symbol p::Int64 step::Float64 modes::Vector{Float64} eig_bspl::Vector{Float64} eigalpha::Vector{ComplexF64} fhat::Matrix{ComplexF64} source"},{"id":469,"pagetitle":"API","title":"VectorSpin.Mesh","ref":"/vector-spin/dev/api/#VectorSpin.Mesh","content":" VectorSpin.Mesh  —  Type struct Mesh Mesh type to store domain parameters nv::Int64 : Number of points in v nx::Int64 : Number of points in x vmin::Float64 : Domain size v ∈ ]vmin,vmax[ vmax::Float64 : Domain size v ∈ ]vmin,vmax[ xmin::Float64 : Domain size x ∈ [xmin,xmax] xmax::Float64 : Domain size x ∈ [xmin,xmax] kx::Vector{Float64} : Wave number vector to compute derivative with FFTs dx::Float64 : Size step along x dv::Float64 : Size step along v x::Vector{Float64} : points along x direction v::Vector{Float64} : points along v direction vnode::Vector{Float64} : center points along v direction source"},{"id":470,"pagetitle":"API","title":"VectorSpin.H1fh!","ref":"/vector-spin/dev/api/#VectorSpin.H1fh!-NTuple{10, Any}","content":" VectorSpin.H1fh!  —  Method H1fh!(f0, f1, f2, f3, S1, S2, S3, dt, mesh, tiK)\n compute the subsystem Hs1 M is even number source"},{"id":471,"pagetitle":"API","title":"VectorSpin.H2fh!","ref":"/vector-spin/dev/api/#VectorSpin.H2fh!-NTuple{10, Any}","content":" VectorSpin.H2fh!  —  Method H2fh!(f0, f1, f2, f3, S1, S2, S3, t, mesh, tiK)\n compute the subsystem Hs2 source"},{"id":472,"pagetitle":"API","title":"VectorSpin.H3fh!","ref":"/vector-spin/dev/api/#VectorSpin.H3fh!-NTuple{10, Any}","content":" VectorSpin.H3fh!  —  Method H3fh!(f0, f1, f2, f3, S1, S2, S3, t, mesh, tiK)\n compute the subsystem Hs3 source"},{"id":473,"pagetitle":"API","title":"VectorSpin.He!","ref":"/vector-spin/dev/api/#VectorSpin.He!-NTuple{7, Any}","content":" VectorSpin.He!  —  Method He!(f0, f1, f2, f3, E1, t, H)\n subsystem for He: f t-Ef v=0; source"},{"id":474,"pagetitle":"API","title":"VectorSpin.advection!","ref":"/vector-spin/dev/api/#VectorSpin.advection!-Tuple{Any, PSMAdvection, Any, Any}","content":" VectorSpin.advection!  —  Method advection!(df, adv, v, dt)\n interpolate df(x + delta) with Parabolic Spline Method (PSM)  We consider a linear advection problem in  $p$  direction \\[\\frac{\\partial f}{\\partial t} + a \\frac{\\partial f}{\\partial x} =0.\\] From the conservation of the volume, we have the following identity \\[f_{j,\\ell}(t)=\\frac{1}{\\Delta p} \\int_{p_{\\ell-1/2}} ^{p_{\\ell+1/2}} f(x_j,p,t)\\mathrm{d}{p} =\\frac{1}{\\Delta p} \\int_{p_{\\ell-1/2}-at} ^{p_{\\ell+1/2}-at} f(x_j,p,0)\\mathrm{d}{p}.\\] For simplicity, denote by  $q\\in [1, M]$  the index such that  $p_{\\ell+1/2}-at \\in [p_{q-1/2},p_{q+1/2}]$  i.e.  $p_{\\ell+1/2}-at \\in C_q$ , then we have \\[f_{j,\\ell}(t) =\\frac{1}{\\Delta p} \\int_{p_{q-1/2}-at} ^{p_{q-1/2}} f(x_j,p,0)\\mathrm{d}{p}+f_{j,q}(0)-\\frac{1}{\\Delta p} \\int_{p_{q+1/2}} ^{p_{q+1/2}-at} f(x_j,p,0)\\mathrm{d}{p}.\\] Here we need to reconstruct a polynomial function  $f(x_j,p,0)$  using the averages  $f_{j,l}(0)$  using the PSM approach.  source"},{"id":475,"pagetitle":"API","title":"VectorSpin.bspline","ref":"/vector-spin/dev/api/#VectorSpin.bspline-Tuple{Int64, Int64, Float64}","content":" VectorSpin.bspline  —  Method bspline(p, j, x)\n Return the value at x in [0,1] of the B-spline with integer nodes of degree p with support starting at j.  Implemented recursively using the   De Boor's Algorithm \\[B_{i,0}(x) := \\left\\{\n\\begin{matrix}\n1 & \\mathrm{if}  \\quad t_i ≤ x < t_{i+1} \\\\\n0 & \\mathrm{otherwise} \n\\end{matrix}\n\\right.\\] \\[B_{i,p}(x) := \\frac{x - t_i}{t_{i+p} - t_i} B_{i,p-1}(x) \n+ \\frac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}} B_{i+1,p-1}(x).\\] source"},{"id":476,"pagetitle":"API","title":"VectorSpin.init","ref":"/vector-spin/dev/api/#VectorSpin.init-NTuple{8, Any}","content":" VectorSpin.init  —  Method init(k, x, i, v1int, frequency, a, femi, tiK)\n Initialize the distribution function  source"},{"id":477,"pagetitle":"API","title":"VectorSpin.integrate","ref":"/vector-spin/dev/api/#VectorSpin.integrate-Tuple{Any, Any}","content":" VectorSpin.integrate  —  Method integrate(value, n)\n computation of integral average in each cell using newton-cotes formula source"},{"id":478,"pagetitle":"API","title":"VectorSpin.numeint","ref":"/vector-spin/dev/api/#VectorSpin.numeint-Tuple{Any, Any}","content":" VectorSpin.numeint  —  Method computation of integral average in each cell using newton-cotes formula numeint(value, N)\n source"},{"id":479,"pagetitle":"API","title":"VectorSpin.step!","ref":"/vector-spin/dev/api/#VectorSpin.step!-Tuple{H1fOperator, Vararg{Any, 6}}","content":" VectorSpin.step!  —  Method step!(op, f0, f1, f2, f3, E1, dt)\n \\[\\begin{aligned}\n\\dot{x} & =p \\\\\n\\dot{E}_x & = - \\int (p f ) dp ds\n\\end{aligned}\\] $H_p$  operator source"},{"id":480,"pagetitle":"API","title":"VectorSpin.step!","ref":"/vector-spin/dev/api/#VectorSpin.step!-Tuple{H2fhOperator, Vararg{Any, 8}}","content":" VectorSpin.step!  —  Method compute the subsystem H2 step!(op, f0, f1, f2, f3, E3, A3, dt, h_int)\n source"},{"id":481,"pagetitle":"API","title":"VectorSpin.step!","ref":"/vector-spin/dev/api/#VectorSpin.step!-Tuple{H3fhOperator, Vararg{Any, 8}}","content":" VectorSpin.step!  —  Method step!(op, f0, f1, f2, f3, E2, A2, dt, h_int)\n source"},{"id":482,"pagetitle":"API","title":"VectorSpin.step!","ref":"/vector-spin/dev/api/#VectorSpin.step!-Tuple{HAAOperator, Vararg{Any, 9}}","content":" VectorSpin.step!  —  Method step!(op, f0, f1, f2, f3, E2, E3, A2, A3, dt)\n \\[\\begin{aligned}\n\\dot{p} = (A_y, A_z) \\cdot \\partial_x (A_y, A_z)   \\\\\n\\dot{Ey} = -\\partial_x^2 A_y + A_y \\rho \\\\\n\\dot{Ez} = -\\partial_x^2 A_z + A_z \\rho \\\\\n\\end{aligned}\\] source"},{"id":483,"pagetitle":"API","title":"VectorSpin.step!","ref":"/vector-spin/dev/api/#VectorSpin.step!-Tuple{HeOperator, Vararg{Any, 10}}","content":" VectorSpin.step!  —  Method step!(op, f0, f1, f2, f3, E1, E2, E3, A2, A3, dt)\n compute the first subsystem He() source"},{"id":484,"pagetitle":"API","title":"VectorSpin.step!","ref":"/vector-spin/dev/api/#VectorSpin.step!-Tuple{HvOperator, Vararg{Any, 6}}","content":" VectorSpin.step!  —  Method step!(op, f0, f1, f2, f3, E1, dt)\n subsystem for Hv: \\[f_t + vf_x = 0\\] \\[-E_x = \\rho - 1\\] source"},{"id":485,"pagetitle":"API","title":"VectorSpin.translation!","ref":"/vector-spin/dev/api/#VectorSpin.translation!-Tuple{Any, Vector{Float64}, Any}","content":" VectorSpin.translation!  —  Method translation!(df, delta, mesh)\n interpolate df(x - delta) source"},{"id":488,"pagetitle":"Example","title":"Example","ref":"/vector-spin/dev/example/#Example","content":" Example using Plots\nusing FFTW\nusing VectorSpin\n\nfunction run()\n\n    T = 50 # 4000  # final time\n    nx = 65   # partition of x\n    nv = 129   # partition of v\n    vmin, vmax = -2.5, 2.5\n    ke = 1.2231333040331807\n    xmin, xmax = 0.0, 4pi / ke\n    dt = 0.04\n    nsteps = floor(Int, T / dt + 1.1)\n    a = 0.02 # 0.001; perturbation coefficient\n    h_int = 0.2 # hbar\n    k0 = 2.0 * ke\n    ww = sqrt(1.0 + k0^2.0) # w0\n    ata = 0.2\n    vth = 0.17\n\n    mesh = Mesh(xmin, xmax, nx, vmin, vmax, nv)\n    adv  = PSMAdvection(mesh)\n\n    E1, E2, E3, A2, A3 = initialfields( mesh, a, ww, ke, k0)\n    f0, f1, f2, f3 = initialfunction(mesh, a, ke, vth,  ata)\n\n    results = Diagnostics(f0, f2, f3, E1, E2, E3, A2, A3, mesh, h_int)\n\n    H2fh = H2fhOperator(adv)\n    He = HeOperator(adv)\n    HAA = HAAOperator(adv)\n    H3fh = H3fhOperator(adv)\n    H1f = H1fOperator(adv)\n\n    for i = 1:nsteps # Loop over time\n\n        step!(H2fh, f0, f1, f2, f3, E3, A3, 0.5dt, h_int)\n        step!(He, f0, f1, f2, f3, E1, E2, E3, A2, A3, 0.5dt)\n        step!(HAA, f0, f1, f2, f3, E2, E3, A2, A3, 0.5dt)\n        step!(H3fh, f0, f1, f2, f3, E2, A2, 0.5dt, h_int)\n        step!(H1f, f0, f1, f2, f3, E1, dt)\n        step!(H3fh, f0, f1, f2, f3, E2, A2, 0.5dt, h_int)\n        step!(HAA, f0, f1, f2, f3, E2, E3, A2, A3, 0.5dt)\n        step!(He, f0, f1, f2, f3, E1, E2, E3, A2, A3, 0.5dt)\n        step!(H2fh, f0, f1, f2, f3, E3, A3, 0.5dt, h_int)\n\n        save!(results, i*dt, f0, f2, f3, E1, E2, E3, A2, A3)\n\n    end\n\n    results\n\nend run (generic function with 1 method) data = run() Diagnostics(Mesh(129, 65, -2.5, 2.5, 0.0, 10.273917465024137, [0.0, 0.6115666520165903, 1.2231333040331807, 1.834699956049771, 2.4462666080663613, 3.0578332600829516, 3.669399912099542, 4.280966564116133, 4.892533216132723, 5.5040998681493125  …  -6.115666520165903, -5.5040998681493125, -4.892533216132723, -4.280966564116133, -3.669399912099542, -3.0578332600829516, -2.4462666080663613, -1.834699956049771, -1.2231333040331807, -0.6115666520165903], 0.15806026869267903, 0.03875968992248062, [0.0, 0.15806026869267906, 0.3161205373853581, 0.47418080607803714, 0.6322410747707162, 0.7903013434633953, 0.9483616121560743, 1.1064218808487534, 1.2644821495414325, 1.4225424182341115  …  8.693314778097347, 8.851375046790027, 9.009435315482706, 9.167495584175386, 9.325555852868064, 9.483616121560743, 9.641676390253423, 9.799736658946102, 9.95779692763878, 10.11585719633146], [-2.4612403100775193, -2.4224806201550386, -2.383720930232558, -2.3449612403100772, -2.306201550387597, -2.2674418604651163, -2.2286821705426356, -2.189922480620155, -2.1511627906976742, -2.1124031007751936  …  2.1511627906976742, 2.189922480620155, 2.2286821705426356, 2.2674418604651163, 2.306201550387597, 2.3449612403100777, 2.383720930232558, 2.4224806201550386, 2.4612403100775193, 2.5], [-2.4806201550387597, -2.441860465116279, -2.4031007751937983, -2.3643410852713176, -2.325581395348837, -2.286821705426356, -2.2480620155038755, -2.2093023255813957, -2.170542635658915, -2.1317829457364343  …  2.1317829457364343, 2.170542635658915, 2.2093023255813957, 2.2480620155038755, 2.286821705426356, 2.325581395348837, 2.3643410852713176, 2.4031007751937983, 2.441860465116279, 2.4806201550387597]), 0.2, [0.0006867339048040479, 0.0006855815006367277, 0.0006821341543513193, 0.0006764213443288355, 0.0006684918024950473, 0.0006584129238580474, 0.0006462699548837971, 0.0006321649753168354, 0.0006162156916429366, 0.0005985540635600154  …  0.0008127101068380702, 0.0008031455270508174, 0.0007938876517253352, 0.0007849487176370652, 0.0007763391666521097, 0.0007680661594788583, 0.0007601351339035968, 0.0007525496766575255, 0.0007453124013051416, 0.0007384259663687371], [0.5434797242199628, 0.5434952965246257, 0.5435392892412116, 0.5436036781069667, 0.5436755766981638, 0.5437379429846714, 0.5437705207359453, 0.54375097066741, 0.5436561369891375, 0.543463388304642  …  0.5261932050845055, 0.5267837624258633, 0.5275502819818907, 0.5284510945170748, 0.5294380341078124, 0.5304586345048949, 0.5314585163557319, 0.532383852282623, 0.5331838049588509, 0.5338128334329713], [0.46507594165098376, 0.46506153425426455, 0.46501951350534854, 0.46495338532419983, 0.46486867035408597, 0.46477243895556203, 0.4646726969091194, 0.4645776563733256, 0.46449493353816507, 0.4644307192669572  …  0.44855117706539577, 0.44752245511647704, 0.4463513294035092, 0.44507738106528894, 0.443745706056074, 0.4424049954713025, 0.4411054543892666, 0.43989665105358955, 0.43882538918606734, 0.43793369367007756], [1.2353739321360409, 1.2353739742776206, 1.2353740951204788, 1.2353742782824297, 1.2353744976526195, 1.2353747191160056, 1.23537490284139, 1.235375006014094, 1.235374985870314, 1.2353748028731484  …  1.2350626678657024, 1.2350644388536471, 1.2350674272393347, 1.235071523813956, 1.2350765848323133, 1.235082438188677, 1.2350888910920876, 1.2350957371690008, 1.2351027651265727, 1.2351097660895387], [0.6849278310016093, 0.6849030986027209, 0.6848291903706611, 0.6847069690805672, 0.6845378590383359, 0.6843238258672117, 0.6840673487353576, 0.6837713855393991, 0.6834393316892697, 0.6830749732569018  …  0.35652848382476404, 0.3557018753426084, 0.3548779987502677, 0.35405618695237406, 0.35323574399769114, 0.3524159618939568, 0.3515961369021591, 0.35077558481911986, 0.34995365486902674, 0.34912974196063734], [[0.029605696652845393, 0.02959488193923368, 0.029562840751899397, 0.029510766937399294, 0.02944060075292454, 0.02935495657280721, 0.029257025477592263, 0.029150456355181473, 0.029039219944190727, 0.028927460885230957  …  0.028819343292644545, 0.028927460885230957, 0.02903921994419073, 0.029150456355181473, 0.029257025477592263, 0.02935495657280721, 0.02944060075292454, 0.029510766937399294, 0.029562840751899397, 0.02959488193923368], [0.02961426270803642, 0.029603703834237702, 0.029572297776282012, 0.029521117254024617, 0.029451941881881168, 0.029367223885153202, 0.029270024275405742, 0.029163914636458475, 0.02905284544149488, 0.02894098868897974  …  0.02883271702697646, 0.02894109529549633, 0.02905289294910414, 0.0291638933786825, 0.029269934107736675, 0.029367076621933167, 0.02945176138575965, 0.029520936208033803, 0.029572151416045418, 0.029603622056076986], [0.029639838446929533, 0.02963013793731856, 0.029600697590483494, 0.029552213403958465, 0.029485982236439705, 0.029403980305046665, 0.029308895592793593, 0.029204085797752955, 0.02909345433822676, 0.02898126240765666  …  0.028872873099666598, 0.028981995884970607, 0.0290938495264398, 0.029204064448056507, 0.029308435871014577, 0.029403138869813706, 0.02948490030842714, 0.029551098405376047, 0.029599781372738013, 0.02962962139309654], [0.029682058832395723, 0.029673979653573133, 0.029647936939046052, 0.029603975528060978, 0.02954258901170147, 0.029464982555657118, 0.02937325654690515, 0.029270447086348444, 0.029160405914567027, 0.02904755802615952  …  0.028939701792172142, 0.02904995392448711, 0.029161744975529705, 0.029270466491327272, 0.029371871828627095, 0.0294623624882545, 0.029539178451836616, 0.02960043790571323, 0.02964501917633023, 0.029672331433427335], [0.029740322871026407, 0.029734772184973796, 0.029713634542046178, 0.029676017930357432, 0.029621301117588573, 0.029549646889193298, 0.029462383260450323, 0.029362143954961627, 0.029252742903258768, 0.029138852748399714  …  0.02903280253733356, 0.029144451764081113, 0.029255909677033398, 0.02936226168852924, 0.029459248689077525, 0.029543644722149733, 0.029613457417120907, 0.02966786699213516, 0.029706905442569233, 0.02973096926090251], [0.029813804511727368, 0.02981181387148664, 0.029797136843014032, 0.029767655302937686, 0.029721337345168974, 0.029657059700929755, 0.02957522346399105, 0.029478003648412535, 0.02936920512281167, 0.029253838219721252  …  0.029151491078520452, 0.029264670576642293, 0.029375358389055927, 0.029478289580394723, 0.029569254605580773, 0.029645580276737905, 0.02970632117208867, 0.029752047700965602, 0.029784252419335317, 0.02980453303745176], [0.029901467547748285, 0.029904170151568956, 0.029897529064510462, 0.029877914768185868, 0.02984161051990829, 0.029785993935109084, 0.02971041442397078, 0.029616553596043503, 0.029508247522068196, 0.02939093794374822  …  0.029294810060539106, 0.029409501841686073, 0.029518803801156904, 0.029617083994371445, 0.02970028015365533, 0.029766485908785858, 0.02981610263874324, 0.029851418048309195, 0.029875667460474466, 0.0298918212133156], [0.03000208418208245, 0.030010689882467724, 0.030013651319813577, 0.030005553439311026, 0.029980747284263184, 0.029934930879620562, 0.029866305804743185, 0.029776044283433372, 0.0296680623978811, 0.029548328709068455  …  0.029461542755180817, 0.02957756230877663, 0.029684674096181942, 0.02977689447389427, 0.02985044405792657, 0.029904429657075716, 0.029940914512528397, 0.02996422194610078, 0.029979579778579492, 0.029991454982332584], [0.030114256835271986, 0.030130025649211044, 0.030144119394028588, 0.03014908105565076, 0.030137113010515897, 0.03010208682168446, 0.030040986973184323, 0.029954476194867158, 0.029846605468293423, 0.029723965754710743  …  0.029650229599733333, 0.029767212153197276, 0.029871134220026394, 0.02995571182174076, 0.03001762314412412, 0.030057264051891963, 0.03007868356273912, 0.030088542041965396, 0.030094269793227883, 0.030101903436606747], [0.030236442705279438, 0.03026065759152333, 0.030287349685623587, 0.030306787120837175, 0.03030884121852681, 0.030285443930007507, 0.03023231816840226, 0.03014963034551069, 0.030041625405652306, 0.029915611319196764  …  0.029859187213357577, 0.029976576017651944, 0.03007611051544681, 0.0301512973032044, 0.0301994859142895, 0.030222662568212082, 0.030227187596693145, 0.030222334670126295, 0.030217900356063393, 0.030221510835222194]  …  [0.024743156638405324, 0.02058479066640118, 0.016220387275665618, 0.016284167104176274, 0.020503713016344488, 0.026814248526486832, 0.03555399866774844, 0.046781327782269, 0.05371804380234287, 0.056333091791596644  …  0.013845569831335298, 0.025807559823222817, 0.037721534276778844, 0.033111433604387716, 0.04398099513054472, 0.05107843607410373, 0.04845550442554156, 0.04832926000194712, 0.046147448310866424, 0.033638215488886895], [0.02245280180592022, 0.01811428968578654, 0.015374095809479437, 0.0165128787791941, 0.021949936394812134, 0.029372671502340363, 0.0395331611873616, 0.049554981534885446, 0.055237247446947337, 0.057185550468521834  …  0.015008155300353678, 0.031411353967025823, 0.03708857981449045, 0.03474096015540472, 0.047406589542510744, 0.05100464155491624, 0.04784777670526595, 0.04753752297573908, 0.04258910524833289, 0.02887593985691728], [0.020411711297168678, 0.016081860292977975, 0.015023411485076034, 0.017060160768349836, 0.023964822440594006, 0.03257370160328439, 0.0432789445552337, 0.05172060472910043, 0.05657368599654733, 0.05787412985478991  …  0.018433005131762256, 0.03577944972717886, 0.03595683244216367, 0.03771649355232492, 0.049870232166740136, 0.05055142677175552, 0.04699060005925252, 0.04626753837689913, 0.03803744505590204, 0.024794060242584574], [0.018468039213104376, 0.014703550408022141, 0.014923778608402367, 0.01812630511857305, 0.026576695099862203, 0.036189556444588926, 0.04644627462323936, 0.05349624074637114, 0.0576839071772502, 0.058409298741086  …  0.02362160982367869, 0.03829874857685173, 0.035348115654481864, 0.04135755765285559, 0.051396866528015686, 0.049735138892124324, 0.045925298978187125, 0.04432067503752004, 0.03282543558226927, 0.021660292126972083], [0.01662662010788517, 0.01396450925368494, 0.015024122946328, 0.01989525830534042, 0.029704633439706755, 0.03986162623391262, 0.0489238014720571, 0.05508240207595397, 0.058455754421961346, 0.058809891983622964  …  0.0294240064933375, 0.03909913778372864, 0.03589610471977644, 0.044966257193773916, 0.05214952808245896, 0.048492669475972194, 0.044767556422610134, 0.04141359572994122, 0.02755772808755277, 0.019460837735597213], [0.015007035226248924, 0.013684778402289155, 0.015481314337716746, 0.022429736426780766, 0.033173029325689316, 0.04321108119280505, 0.050833051599652075, 0.056524092582659315, 0.05883692806388806, 0.05902865651487697  …  0.03456921796309394, 0.03889787275889718, 0.03766455043614278, 0.04810324460866165, 0.05221276771394464, 0.04685462176365573, 0.04353132053683546, 0.0373949692990268, 0.02291249984631574, 0.017968790365344763], [0.013743529816121577, 0.01368846340778042, 0.016549888599128742, 0.02563233842323895, 0.036733064080273534, 0.045975008386213684, 0.052407488868882426, 0.057702961154256445, 0.05888254273390449, 0.058922577624978684  …  0.0382284800815174, 0.03858954032754328, 0.040293027650068, 0.05059564906274817, 0.05155556731639675, 0.04501668963271596, 0.04199855610238151, 0.032458986469672234, 0.019393163719586857, 0.01687746790366144], [0.012904284978301955, 0.013947575763471571, 0.018439297653343723, 0.029260240352931666, 0.04010876829338159, 0.04808590146021928, 0.053837423054510045, 0.05843225147824579, 0.05872448844676244, 0.058241233518684155  …  0.040282125117714174, 0.03882920640301852, 0.04331800357516648, 0.0523549833864598, 0.05016583971832577, 0.0432326089285502, 0.03978831430972172, 0.027168750939184038, 0.017187325465825333, 0.015916104683365868], [0.012470726147086485, 0.014626735711129733, 0.02118358469225831, 0.032997886540147306, 0.043060846220958404, 0.04965853442316649, 0.05515051425657367, 0.058613122169655946, 0.05845015103629623, 0.056721417104792546  …  0.04118325448281004, 0.03985263354843047, 0.04638675855919219, 0.05325043702315086, 0.04817556031754084, 0.041631307784241886, 0.036587209866558765, 0.022286736487809992, 0.016146544050696498, 0.014932937191053566], [0.012431557224312174, 0.01595020771557429, 0.02460614545932907, 0.03656912425990952, 0.045429312134399324, 0.05090284416741278, 0.05619932524117998, 0.05832706712079803, 0.05798369817726334, 0.05425928104310296  …  0.0416134712481681, 0.041552497485046296, 0.049263582707442057, 0.053141300680499035, 0.045875971216641484, 0.04008131982433219, 0.03240392218010326, 0.01849907271713302, 0.015879600532572077, 0.013902731366085965]], [0.0, 0.04, 0.08, 0.12, 0.16, 0.2, 0.24, 0.28, 0.32, 0.36  …  49.68, 49.72, 49.76, 49.800000000000004, 49.84, 49.88, 49.92, 49.96, 50.0, 50.04]) plot(data.time, log.(data.Ex_energy)) plot(data.time, data.E_energy) plot(data.time, data.B_energy) plot(data.time, data.energy) plot(data.time, data.Sz)"},{"id":491,"pagetitle":"Validation","title":"SRS without spin","ref":"/vector-spin/dev/srs_without_spin/#SRS-without-spin","content":" SRS without spin using Plots\nusing FFTW\nusing VectorSpin \\[\\left\\{\n\\begin{aligned}\n&\\frac{\\partial f}{\\partial t} + p \\frac{\\partial f}{\\partial x} + [ E_x  - {\\mathbf A}_\\perp \\cdot \\frac{\\partial {\\mathbf A}_\\perp}{\\partial x} ]\\frac{\\partial f}{\\partial p} = 0,\\\\\n&\\frac{\\partial E_x}{\\partial t} = -\\int_{\\mathbb{R}} p f  \\mathrm{d}{p},\\\\\n&\\frac{\\partial E_y}{\\partial t} = - \\frac{\\partial^2 A_y}{\\partial x^2} + A_y \\int_{\\mathbb{R}}  f  \\mathrm{d}{p},\\\\\n&\\frac{\\partial E_z}{\\partial t} = - \\frac{\\partial^2 A_z}{\\partial x^2} + A_z \\int_{\\mathbb{R}}  f  \\mathrm{d}{p},\\\\\n&\\frac{\\partial {\\mathbf A}_\\perp}{\\partial t} = - {\\mathbf E}_\\perp,\\\\\n&\\frac{\\partial E_x}{\\partial x} = \\int_{\\mathbb{R}} f \\mathrm{d}{p} - 1.\n\\end{aligned}\n\\right.\\] We consider the periodic condition with spatial period  $L=4\\pi/k_e$ , also take  $H=5$  for the computational domain in  $v$ -direction. Mathematical domain parameters are taken as  $N_x=129, N_v=129, \\Delta t =0.05$ We take the following values for physical parameters: \\[\\alpha=0.02, k_e=1.2231, k_0=2k_e, v_{th}=0.17,\\] \\[w_0=2.6428, k_s=k_e, w_s=1.5799, w_e=1.0629. \\] We use a perturbed Maxwellian as an initial condition for  $f$ \\[f(t=0,x,p)=(1+\\alpha \\cos(k_e x))\\frac{1}{\\sqrt{2\\pi}v_{th}}e^{-\\frac{p^2}{2v_{th}^2}},\\] and the initial longitudinal electric field \\[E_x(t=0,x)=(\\alpha /k_e)\\sin(k_e x). \\] Here  $\\alpha$  and  $k_e$  are the amplitude and the wave number of the perturbation respectively, and the  $v_{th}$  is the electron thermal speed. For the transverse fields, we consider an incident electromagnetic wave with circular polarization: \\[\\begin{aligned}\n& E_y(t=0,x)=E_0 \\cos(k_0 x), \\\\\n& E_z(t=0,x)=E_0 \\sin(k_0 x),\\\\\n& A_y(t=0,x)=-\\frac{E_0}{w_0} \\sin(k_0 x), \\\\ \n& A_z(t=0,x)=\\frac{E_0}{w_0} \\cos(k_0 x),\n\\end{aligned} \\] where the  $k_0$  and  $w_0$  are the wave number and the amplitude of the transverse electric field respectively.  We also take the amplitude of the incident wave  $E_{ref}=0.325$  as a reference value.  be in the range  $0.25E_{ref} \\leq E_0  \\leq 2E_{ref}.$ time evolution of the longitudinal electric field norm \\[|| E_x (t)|| =\\left(\\frac{1}{2}\\int_0^L E_x^2(t,x) \\mathrm{d}\\mathrm{x}\\right )^{\\frac{1}{2}}\\]"}]